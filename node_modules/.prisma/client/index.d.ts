
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Auth
 * 
 */
export type Auth = $Result.DefaultSelection<Prisma.$AuthPayload>
/**
 * Model AreaConocimiento
 * 
 */
export type AreaConocimiento = $Result.DefaultSelection<Prisma.$AreaConocimientoPayload>
/**
 * Model Propuesta
 * 
 */
export type Propuesta = $Result.DefaultSelection<Prisma.$PropuestaPayload>
/**
 * Model TrabajoTitulacion
 * 
 */
export type TrabajoTitulacion = $Result.DefaultSelection<Prisma.$TrabajoTitulacionPayload>
/**
 * Model Actividad
 * 
 */
export type Actividad = $Result.DefaultSelection<Prisma.$ActividadPayload>
/**
 * Model Evidencia
 * 
 */
export type Evidencia = $Result.DefaultSelection<Prisma.$EvidenciaPayload>
/**
 * Model Comentario
 * 
 */
export type Comentario = $Result.DefaultSelection<Prisma.$ComentarioPayload>
/**
 * Model CatalogoPrerequisito
 * 
 */
export type CatalogoPrerequisito = $Result.DefaultSelection<Prisma.$CatalogoPrerequisitoPayload>
/**
 * Model EstudiantePrerequisito
 * 
 */
export type EstudiantePrerequisito = $Result.DefaultSelection<Prisma.$EstudiantePrerequisitoPayload>
/**
 * Model Notificacion
 * 
 */
export type Notificacion = $Result.DefaultSelection<Prisma.$NotificacionPayload>
/**
 * Model EntregableFinal
 * 
 */
export type EntregableFinal = $Result.DefaultSelection<Prisma.$EntregableFinalPayload>
/**
 * Model Comite
 * 
 */
export type Comite = $Result.DefaultSelection<Prisma.$ComitePayload>
/**
 * Model EstudiantePerfil
 * 
 */
export type EstudiantePerfil = $Result.DefaultSelection<Prisma.$EstudiantePerfilPayload>
/**
 * Model McpAuth
 * 
 */
export type McpAuth = $Result.DefaultSelection<Prisma.$McpAuthPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Rol: {
  ESTUDIANTE: 'ESTUDIANTE',
  TUTOR: 'TUTOR',
  DIRECTOR: 'DIRECTOR',
  COORDINADOR: 'COORDINADOR',
  COMITE: 'COMITE',
  DOCENTE_INTEGRACION: 'DOCENTE_INTEGRACION'
};

export type Rol = (typeof Rol)[keyof typeof Rol]


export const EstadoPropuesta: {
  PENDIENTE: 'PENDIENTE',
  APROBADA: 'APROBADA',
  APROBADA_CON_COMENTARIOS: 'APROBADA_CON_COMENTARIOS',
  RECHAZADA: 'RECHAZADA'
};

export type EstadoPropuesta = (typeof EstadoPropuesta)[keyof typeof EstadoPropuesta]


export const ResultadoDefensa: {
  APROBADO: 'APROBADO',
  REPROBADO: 'REPROBADO',
  PENDIENTE: 'PENDIENTE'
};

export type ResultadoDefensa = (typeof ResultadoDefensa)[keyof typeof ResultadoDefensa]


export const TipoActividad: {
  DOCENCIA: 'DOCENCIA',
  TUTORIA: 'TUTORIA'
};

export type TipoActividad = (typeof TipoActividad)[keyof typeof TipoActividad]


export const EstadoEvidencia: {
  ENTREGADO: 'ENTREGADO',
  NO_ENTREGADO: 'NO_ENTREGADO'
};

export type EstadoEvidencia = (typeof EstadoEvidencia)[keyof typeof EstadoEvidencia]


export const TipoEntregable: {
  TESIS: 'TESIS',
  MANUAL_USUARIO: 'MANUAL_USUARIO',
  REPOSITORIO: 'REPOSITORIO',
  ARTICULO: 'ARTICULO'
};

export type TipoEntregable = (typeof TipoEntregable)[keyof typeof TipoEntregable]


export const RolComite: {
  JURADO_1: 'JURADO_1',
  JURADO_2: 'JURADO_2',
  PRESIDENTE: 'PRESIDENTE'
};

export type RolComite = (typeof RolComite)[keyof typeof RolComite]

}

export type Rol = $Enums.Rol

export const Rol: typeof $Enums.Rol

export type EstadoPropuesta = $Enums.EstadoPropuesta

export const EstadoPropuesta: typeof $Enums.EstadoPropuesta

export type ResultadoDefensa = $Enums.ResultadoDefensa

export const ResultadoDefensa: typeof $Enums.ResultadoDefensa

export type TipoActividad = $Enums.TipoActividad

export const TipoActividad: typeof $Enums.TipoActividad

export type EstadoEvidencia = $Enums.EstadoEvidencia

export const EstadoEvidencia: typeof $Enums.EstadoEvidencia

export type TipoEntregable = $Enums.TipoEntregable

export const TipoEntregable: typeof $Enums.TipoEntregable

export type RolComite = $Enums.RolComite

export const RolComite: typeof $Enums.RolComite

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.auth`: Exposes CRUD operations for the **Auth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auths
    * const auths = await prisma.auth.findMany()
    * ```
    */
  get auth(): Prisma.AuthDelegate<ExtArgs>;

  /**
   * `prisma.areaConocimiento`: Exposes CRUD operations for the **AreaConocimiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AreaConocimientos
    * const areaConocimientos = await prisma.areaConocimiento.findMany()
    * ```
    */
  get areaConocimiento(): Prisma.AreaConocimientoDelegate<ExtArgs>;

  /**
   * `prisma.propuesta`: Exposes CRUD operations for the **Propuesta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Propuestas
    * const propuestas = await prisma.propuesta.findMany()
    * ```
    */
  get propuesta(): Prisma.PropuestaDelegate<ExtArgs>;

  /**
   * `prisma.trabajoTitulacion`: Exposes CRUD operations for the **TrabajoTitulacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrabajoTitulacions
    * const trabajoTitulacions = await prisma.trabajoTitulacion.findMany()
    * ```
    */
  get trabajoTitulacion(): Prisma.TrabajoTitulacionDelegate<ExtArgs>;

  /**
   * `prisma.actividad`: Exposes CRUD operations for the **Actividad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actividads
    * const actividads = await prisma.actividad.findMany()
    * ```
    */
  get actividad(): Prisma.ActividadDelegate<ExtArgs>;

  /**
   * `prisma.evidencia`: Exposes CRUD operations for the **Evidencia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evidencias
    * const evidencias = await prisma.evidencia.findMany()
    * ```
    */
  get evidencia(): Prisma.EvidenciaDelegate<ExtArgs>;

  /**
   * `prisma.comentario`: Exposes CRUD operations for the **Comentario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comentarios
    * const comentarios = await prisma.comentario.findMany()
    * ```
    */
  get comentario(): Prisma.ComentarioDelegate<ExtArgs>;

  /**
   * `prisma.catalogoPrerequisito`: Exposes CRUD operations for the **CatalogoPrerequisito** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogoPrerequisitos
    * const catalogoPrerequisitos = await prisma.catalogoPrerequisito.findMany()
    * ```
    */
  get catalogoPrerequisito(): Prisma.CatalogoPrerequisitoDelegate<ExtArgs>;

  /**
   * `prisma.estudiantePrerequisito`: Exposes CRUD operations for the **EstudiantePrerequisito** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EstudiantePrerequisitos
    * const estudiantePrerequisitos = await prisma.estudiantePrerequisito.findMany()
    * ```
    */
  get estudiantePrerequisito(): Prisma.EstudiantePrerequisitoDelegate<ExtArgs>;

  /**
   * `prisma.notificacion`: Exposes CRUD operations for the **Notificacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notificacions
    * const notificacions = await prisma.notificacion.findMany()
    * ```
    */
  get notificacion(): Prisma.NotificacionDelegate<ExtArgs>;

  /**
   * `prisma.entregableFinal`: Exposes CRUD operations for the **EntregableFinal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EntregableFinals
    * const entregableFinals = await prisma.entregableFinal.findMany()
    * ```
    */
  get entregableFinal(): Prisma.EntregableFinalDelegate<ExtArgs>;

  /**
   * `prisma.comite`: Exposes CRUD operations for the **Comite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comites
    * const comites = await prisma.comite.findMany()
    * ```
    */
  get comite(): Prisma.ComiteDelegate<ExtArgs>;

  /**
   * `prisma.estudiantePerfil`: Exposes CRUD operations for the **EstudiantePerfil** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EstudiantePerfils
    * const estudiantePerfils = await prisma.estudiantePerfil.findMany()
    * ```
    */
  get estudiantePerfil(): Prisma.EstudiantePerfilDelegate<ExtArgs>;

  /**
   * `prisma.mcpAuth`: Exposes CRUD operations for the **McpAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more McpAuths
    * const mcpAuths = await prisma.mcpAuth.findMany()
    * ```
    */
  get mcpAuth(): Prisma.McpAuthDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    Auth: 'Auth',
    AreaConocimiento: 'AreaConocimiento',
    Propuesta: 'Propuesta',
    TrabajoTitulacion: 'TrabajoTitulacion',
    Actividad: 'Actividad',
    Evidencia: 'Evidencia',
    Comentario: 'Comentario',
    CatalogoPrerequisito: 'CatalogoPrerequisito',
    EstudiantePrerequisito: 'EstudiantePrerequisito',
    Notificacion: 'Notificacion',
    EntregableFinal: 'EntregableFinal',
    Comite: 'Comite',
    EstudiantePerfil: 'EstudiantePerfil',
    McpAuth: 'McpAuth'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "usuario" | "auth" | "areaConocimiento" | "propuesta" | "trabajoTitulacion" | "actividad" | "evidencia" | "comentario" | "catalogoPrerequisito" | "estudiantePrerequisito" | "notificacion" | "entregableFinal" | "comite" | "estudiantePerfil" | "mcpAuth"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Auth: {
        payload: Prisma.$AuthPayload<ExtArgs>
        fields: Prisma.AuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          findFirst: {
            args: Prisma.AuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          findMany: {
            args: Prisma.AuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>[]
          }
          create: {
            args: Prisma.AuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          createMany: {
            args: Prisma.AuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          update: {
            args: Prisma.AuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          deleteMany: {
            args: Prisma.AuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          aggregate: {
            args: Prisma.AuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuth>
          }
          groupBy: {
            args: Prisma.AuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthCountArgs<ExtArgs>
            result: $Utils.Optional<AuthCountAggregateOutputType> | number
          }
        }
      }
      AreaConocimiento: {
        payload: Prisma.$AreaConocimientoPayload<ExtArgs>
        fields: Prisma.AreaConocimientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AreaConocimientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaConocimientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AreaConocimientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaConocimientoPayload>
          }
          findFirst: {
            args: Prisma.AreaConocimientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaConocimientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AreaConocimientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaConocimientoPayload>
          }
          findMany: {
            args: Prisma.AreaConocimientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaConocimientoPayload>[]
          }
          create: {
            args: Prisma.AreaConocimientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaConocimientoPayload>
          }
          createMany: {
            args: Prisma.AreaConocimientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AreaConocimientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaConocimientoPayload>
          }
          update: {
            args: Prisma.AreaConocimientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaConocimientoPayload>
          }
          deleteMany: {
            args: Prisma.AreaConocimientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AreaConocimientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AreaConocimientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaConocimientoPayload>
          }
          aggregate: {
            args: Prisma.AreaConocimientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAreaConocimiento>
          }
          groupBy: {
            args: Prisma.AreaConocimientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AreaConocimientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AreaConocimientoCountArgs<ExtArgs>
            result: $Utils.Optional<AreaConocimientoCountAggregateOutputType> | number
          }
        }
      }
      Propuesta: {
        payload: Prisma.$PropuestaPayload<ExtArgs>
        fields: Prisma.PropuestaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropuestaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropuestaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload>
          }
          findFirst: {
            args: Prisma.PropuestaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropuestaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload>
          }
          findMany: {
            args: Prisma.PropuestaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload>[]
          }
          create: {
            args: Prisma.PropuestaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload>
          }
          createMany: {
            args: Prisma.PropuestaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PropuestaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload>
          }
          update: {
            args: Prisma.PropuestaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload>
          }
          deleteMany: {
            args: Prisma.PropuestaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropuestaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropuestaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload>
          }
          aggregate: {
            args: Prisma.PropuestaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropuesta>
          }
          groupBy: {
            args: Prisma.PropuestaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropuestaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropuestaCountArgs<ExtArgs>
            result: $Utils.Optional<PropuestaCountAggregateOutputType> | number
          }
        }
      }
      TrabajoTitulacion: {
        payload: Prisma.$TrabajoTitulacionPayload<ExtArgs>
        fields: Prisma.TrabajoTitulacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrabajoTitulacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrabajoTitulacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrabajoTitulacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrabajoTitulacionPayload>
          }
          findFirst: {
            args: Prisma.TrabajoTitulacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrabajoTitulacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrabajoTitulacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrabajoTitulacionPayload>
          }
          findMany: {
            args: Prisma.TrabajoTitulacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrabajoTitulacionPayload>[]
          }
          create: {
            args: Prisma.TrabajoTitulacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrabajoTitulacionPayload>
          }
          createMany: {
            args: Prisma.TrabajoTitulacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TrabajoTitulacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrabajoTitulacionPayload>
          }
          update: {
            args: Prisma.TrabajoTitulacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrabajoTitulacionPayload>
          }
          deleteMany: {
            args: Prisma.TrabajoTitulacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrabajoTitulacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrabajoTitulacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrabajoTitulacionPayload>
          }
          aggregate: {
            args: Prisma.TrabajoTitulacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrabajoTitulacion>
          }
          groupBy: {
            args: Prisma.TrabajoTitulacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrabajoTitulacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrabajoTitulacionCountArgs<ExtArgs>
            result: $Utils.Optional<TrabajoTitulacionCountAggregateOutputType> | number
          }
        }
      }
      Actividad: {
        payload: Prisma.$ActividadPayload<ExtArgs>
        fields: Prisma.ActividadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActividadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActividadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload>
          }
          findFirst: {
            args: Prisma.ActividadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActividadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload>
          }
          findMany: {
            args: Prisma.ActividadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload>[]
          }
          create: {
            args: Prisma.ActividadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload>
          }
          createMany: {
            args: Prisma.ActividadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ActividadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload>
          }
          update: {
            args: Prisma.ActividadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload>
          }
          deleteMany: {
            args: Prisma.ActividadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActividadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActividadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload>
          }
          aggregate: {
            args: Prisma.ActividadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActividad>
          }
          groupBy: {
            args: Prisma.ActividadGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActividadGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActividadCountArgs<ExtArgs>
            result: $Utils.Optional<ActividadCountAggregateOutputType> | number
          }
        }
      }
      Evidencia: {
        payload: Prisma.$EvidenciaPayload<ExtArgs>
        fields: Prisma.EvidenciaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvidenciaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvidenciaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          findFirst: {
            args: Prisma.EvidenciaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvidenciaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          findMany: {
            args: Prisma.EvidenciaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>[]
          }
          create: {
            args: Prisma.EvidenciaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          createMany: {
            args: Prisma.EvidenciaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EvidenciaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          update: {
            args: Prisma.EvidenciaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          deleteMany: {
            args: Prisma.EvidenciaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvidenciaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvidenciaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          aggregate: {
            args: Prisma.EvidenciaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvidencia>
          }
          groupBy: {
            args: Prisma.EvidenciaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvidenciaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvidenciaCountArgs<ExtArgs>
            result: $Utils.Optional<EvidenciaCountAggregateOutputType> | number
          }
        }
      }
      Comentario: {
        payload: Prisma.$ComentarioPayload<ExtArgs>
        fields: Prisma.ComentarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComentarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComentarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          findFirst: {
            args: Prisma.ComentarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComentarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          findMany: {
            args: Prisma.ComentarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>[]
          }
          create: {
            args: Prisma.ComentarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          createMany: {
            args: Prisma.ComentarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ComentarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          update: {
            args: Prisma.ComentarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          deleteMany: {
            args: Prisma.ComentarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComentarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComentarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          aggregate: {
            args: Prisma.ComentarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComentario>
          }
          groupBy: {
            args: Prisma.ComentarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComentarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComentarioCountArgs<ExtArgs>
            result: $Utils.Optional<ComentarioCountAggregateOutputType> | number
          }
        }
      }
      CatalogoPrerequisito: {
        payload: Prisma.$CatalogoPrerequisitoPayload<ExtArgs>
        fields: Prisma.CatalogoPrerequisitoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogoPrerequisitoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPrerequisitoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogoPrerequisitoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPrerequisitoPayload>
          }
          findFirst: {
            args: Prisma.CatalogoPrerequisitoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPrerequisitoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogoPrerequisitoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPrerequisitoPayload>
          }
          findMany: {
            args: Prisma.CatalogoPrerequisitoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPrerequisitoPayload>[]
          }
          create: {
            args: Prisma.CatalogoPrerequisitoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPrerequisitoPayload>
          }
          createMany: {
            args: Prisma.CatalogoPrerequisitoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CatalogoPrerequisitoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPrerequisitoPayload>
          }
          update: {
            args: Prisma.CatalogoPrerequisitoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPrerequisitoPayload>
          }
          deleteMany: {
            args: Prisma.CatalogoPrerequisitoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogoPrerequisitoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CatalogoPrerequisitoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoPrerequisitoPayload>
          }
          aggregate: {
            args: Prisma.CatalogoPrerequisitoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatalogoPrerequisito>
          }
          groupBy: {
            args: Prisma.CatalogoPrerequisitoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatalogoPrerequisitoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogoPrerequisitoCountArgs<ExtArgs>
            result: $Utils.Optional<CatalogoPrerequisitoCountAggregateOutputType> | number
          }
        }
      }
      EstudiantePrerequisito: {
        payload: Prisma.$EstudiantePrerequisitoPayload<ExtArgs>
        fields: Prisma.EstudiantePrerequisitoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EstudiantePrerequisitoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePrerequisitoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EstudiantePrerequisitoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePrerequisitoPayload>
          }
          findFirst: {
            args: Prisma.EstudiantePrerequisitoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePrerequisitoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EstudiantePrerequisitoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePrerequisitoPayload>
          }
          findMany: {
            args: Prisma.EstudiantePrerequisitoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePrerequisitoPayload>[]
          }
          create: {
            args: Prisma.EstudiantePrerequisitoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePrerequisitoPayload>
          }
          createMany: {
            args: Prisma.EstudiantePrerequisitoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EstudiantePrerequisitoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePrerequisitoPayload>
          }
          update: {
            args: Prisma.EstudiantePrerequisitoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePrerequisitoPayload>
          }
          deleteMany: {
            args: Prisma.EstudiantePrerequisitoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EstudiantePrerequisitoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EstudiantePrerequisitoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePrerequisitoPayload>
          }
          aggregate: {
            args: Prisma.EstudiantePrerequisitoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstudiantePrerequisito>
          }
          groupBy: {
            args: Prisma.EstudiantePrerequisitoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstudiantePrerequisitoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EstudiantePrerequisitoCountArgs<ExtArgs>
            result: $Utils.Optional<EstudiantePrerequisitoCountAggregateOutputType> | number
          }
        }
      }
      Notificacion: {
        payload: Prisma.$NotificacionPayload<ExtArgs>
        fields: Prisma.NotificacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          findFirst: {
            args: Prisma.NotificacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          findMany: {
            args: Prisma.NotificacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>[]
          }
          create: {
            args: Prisma.NotificacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          createMany: {
            args: Prisma.NotificacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          update: {
            args: Prisma.NotificacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          deleteMany: {
            args: Prisma.NotificacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          aggregate: {
            args: Prisma.NotificacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificacion>
          }
          groupBy: {
            args: Prisma.NotificacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificacionCountArgs<ExtArgs>
            result: $Utils.Optional<NotificacionCountAggregateOutputType> | number
          }
        }
      }
      EntregableFinal: {
        payload: Prisma.$EntregableFinalPayload<ExtArgs>
        fields: Prisma.EntregableFinalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntregableFinalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntregableFinalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload>
          }
          findFirst: {
            args: Prisma.EntregableFinalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntregableFinalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload>
          }
          findMany: {
            args: Prisma.EntregableFinalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload>[]
          }
          create: {
            args: Prisma.EntregableFinalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload>
          }
          createMany: {
            args: Prisma.EntregableFinalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EntregableFinalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload>
          }
          update: {
            args: Prisma.EntregableFinalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload>
          }
          deleteMany: {
            args: Prisma.EntregableFinalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EntregableFinalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EntregableFinalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload>
          }
          aggregate: {
            args: Prisma.EntregableFinalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntregableFinal>
          }
          groupBy: {
            args: Prisma.EntregableFinalGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntregableFinalGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntregableFinalCountArgs<ExtArgs>
            result: $Utils.Optional<EntregableFinalCountAggregateOutputType> | number
          }
        }
      }
      Comite: {
        payload: Prisma.$ComitePayload<ExtArgs>
        fields: Prisma.ComiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload>
          }
          findFirst: {
            args: Prisma.ComiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload>
          }
          findMany: {
            args: Prisma.ComiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload>[]
          }
          create: {
            args: Prisma.ComiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload>
          }
          createMany: {
            args: Prisma.ComiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ComiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload>
          }
          update: {
            args: Prisma.ComiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload>
          }
          deleteMany: {
            args: Prisma.ComiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload>
          }
          aggregate: {
            args: Prisma.ComiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComite>
          }
          groupBy: {
            args: Prisma.ComiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComiteCountArgs<ExtArgs>
            result: $Utils.Optional<ComiteCountAggregateOutputType> | number
          }
        }
      }
      EstudiantePerfil: {
        payload: Prisma.$EstudiantePerfilPayload<ExtArgs>
        fields: Prisma.EstudiantePerfilFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EstudiantePerfilFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePerfilPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EstudiantePerfilFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePerfilPayload>
          }
          findFirst: {
            args: Prisma.EstudiantePerfilFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePerfilPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EstudiantePerfilFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePerfilPayload>
          }
          findMany: {
            args: Prisma.EstudiantePerfilFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePerfilPayload>[]
          }
          create: {
            args: Prisma.EstudiantePerfilCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePerfilPayload>
          }
          createMany: {
            args: Prisma.EstudiantePerfilCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EstudiantePerfilDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePerfilPayload>
          }
          update: {
            args: Prisma.EstudiantePerfilUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePerfilPayload>
          }
          deleteMany: {
            args: Prisma.EstudiantePerfilDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EstudiantePerfilUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EstudiantePerfilUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePerfilPayload>
          }
          aggregate: {
            args: Prisma.EstudiantePerfilAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstudiantePerfil>
          }
          groupBy: {
            args: Prisma.EstudiantePerfilGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstudiantePerfilGroupByOutputType>[]
          }
          count: {
            args: Prisma.EstudiantePerfilCountArgs<ExtArgs>
            result: $Utils.Optional<EstudiantePerfilCountAggregateOutputType> | number
          }
        }
      }
      McpAuth: {
        payload: Prisma.$McpAuthPayload<ExtArgs>
        fields: Prisma.McpAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.McpAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McpAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.McpAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McpAuthPayload>
          }
          findFirst: {
            args: Prisma.McpAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McpAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.McpAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McpAuthPayload>
          }
          findMany: {
            args: Prisma.McpAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McpAuthPayload>[]
          }
          create: {
            args: Prisma.McpAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McpAuthPayload>
          }
          createMany: {
            args: Prisma.McpAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.McpAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McpAuthPayload>
          }
          update: {
            args: Prisma.McpAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McpAuthPayload>
          }
          deleteMany: {
            args: Prisma.McpAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.McpAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.McpAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McpAuthPayload>
          }
          aggregate: {
            args: Prisma.McpAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMcpAuth>
          }
          groupBy: {
            args: Prisma.McpAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<McpAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.McpAuthCountArgs<ExtArgs>
            result: $Utils.Optional<McpAuthCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    propuestas: number
    comentarios: number
    notificaciones: number
    comites: number
    prerequisitos: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propuestas?: boolean | UsuarioCountOutputTypeCountPropuestasArgs
    comentarios?: boolean | UsuarioCountOutputTypeCountComentariosArgs
    notificaciones?: boolean | UsuarioCountOutputTypeCountNotificacionesArgs
    comites?: boolean | UsuarioCountOutputTypeCountComitesArgs
    prerequisitos?: boolean | UsuarioCountOutputTypeCountPrerequisitosArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountPropuestasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropuestaWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountComentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountNotificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacionWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountComitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComiteWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountPrerequisitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudiantePrerequisitoWhereInput
  }


  /**
   * Count Type AreaConocimientoCountOutputType
   */

  export type AreaConocimientoCountOutputType = {
    propuestas: number
  }

  export type AreaConocimientoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propuestas?: boolean | AreaConocimientoCountOutputTypeCountPropuestasArgs
  }

  // Custom InputTypes
  /**
   * AreaConocimientoCountOutputType without action
   */
  export type AreaConocimientoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaConocimientoCountOutputType
     */
    select?: AreaConocimientoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AreaConocimientoCountOutputType without action
   */
  export type AreaConocimientoCountOutputTypeCountPropuestasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropuestaWhereInput
  }


  /**
   * Count Type PropuestaCountOutputType
   */

  export type PropuestaCountOutputType = {
    trabajosTitulacion: number
    actividades: number
    comites: number
    entregablesFinales: number
  }

  export type PropuestaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trabajosTitulacion?: boolean | PropuestaCountOutputTypeCountTrabajosTitulacionArgs
    actividades?: boolean | PropuestaCountOutputTypeCountActividadesArgs
    comites?: boolean | PropuestaCountOutputTypeCountComitesArgs
    entregablesFinales?: boolean | PropuestaCountOutputTypeCountEntregablesFinalesArgs
  }

  // Custom InputTypes
  /**
   * PropuestaCountOutputType without action
   */
  export type PropuestaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropuestaCountOutputType
     */
    select?: PropuestaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropuestaCountOutputType without action
   */
  export type PropuestaCountOutputTypeCountTrabajosTitulacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrabajoTitulacionWhereInput
  }

  /**
   * PropuestaCountOutputType without action
   */
  export type PropuestaCountOutputTypeCountActividadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActividadWhereInput
  }

  /**
   * PropuestaCountOutputType without action
   */
  export type PropuestaCountOutputTypeCountComitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComiteWhereInput
  }

  /**
   * PropuestaCountOutputType without action
   */
  export type PropuestaCountOutputTypeCountEntregablesFinalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntregableFinalWhereInput
  }


  /**
   * Count Type ActividadCountOutputType
   */

  export type ActividadCountOutputType = {
    evidencias: number
  }

  export type ActividadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidencias?: boolean | ActividadCountOutputTypeCountEvidenciasArgs
  }

  // Custom InputTypes
  /**
   * ActividadCountOutputType without action
   */
  export type ActividadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadCountOutputType
     */
    select?: ActividadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActividadCountOutputType without action
   */
  export type ActividadCountOutputTypeCountEvidenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenciaWhereInput
  }


  /**
   * Count Type EvidenciaCountOutputType
   */

  export type EvidenciaCountOutputType = {
    comentarios: number
  }

  export type EvidenciaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comentarios?: boolean | EvidenciaCountOutputTypeCountComentariosArgs
  }

  // Custom InputTypes
  /**
   * EvidenciaCountOutputType without action
   */
  export type EvidenciaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenciaCountOutputType
     */
    select?: EvidenciaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EvidenciaCountOutputType without action
   */
  export type EvidenciaCountOutputTypeCountComentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioWhereInput
  }


  /**
   * Count Type CatalogoPrerequisitoCountOutputType
   */

  export type CatalogoPrerequisitoCountOutputType = {
    estudiantePrerequisitos: number
  }

  export type CatalogoPrerequisitoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiantePrerequisitos?: boolean | CatalogoPrerequisitoCountOutputTypeCountEstudiantePrerequisitosArgs
  }

  // Custom InputTypes
  /**
   * CatalogoPrerequisitoCountOutputType without action
   */
  export type CatalogoPrerequisitoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoPrerequisitoCountOutputType
     */
    select?: CatalogoPrerequisitoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CatalogoPrerequisitoCountOutputType without action
   */
  export type CatalogoPrerequisitoCountOutputTypeCountEstudiantePrerequisitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudiantePrerequisitoWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    cedula: string | null
    nombres: string | null
    apellidos: string | null
    correoInstitucional: string | null
    rol: $Enums.Rol | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    cedula: string | null
    nombres: string | null
    apellidos: string | null
    correoInstitucional: string | null
    rol: $Enums.Rol | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    cedula: number
    nombres: number
    apellidos: number
    correoInstitucional: number
    rol: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    cedula?: true
    nombres?: true
    apellidos?: true
    correoInstitucional?: true
    rol?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    cedula?: true
    nombres?: true
    apellidos?: true
    correoInstitucional?: true
    rol?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    cedula?: true
    nombres?: true
    apellidos?: true
    correoInstitucional?: true
    rol?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol: $Enums.Rol
    createdAt: Date
    updatedAt: Date
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cedula?: boolean
    nombres?: boolean
    apellidos?: boolean
    correoInstitucional?: boolean
    rol?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auth?: boolean | Usuario$authArgs<ExtArgs>
    propuestas?: boolean | Usuario$propuestasArgs<ExtArgs>
    comentarios?: boolean | Usuario$comentariosArgs<ExtArgs>
    notificaciones?: boolean | Usuario$notificacionesArgs<ExtArgs>
    comites?: boolean | Usuario$comitesArgs<ExtArgs>
    prerequisitos?: boolean | Usuario$prerequisitosArgs<ExtArgs>
    estudiantePerfil?: boolean | Usuario$estudiantePerfilArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>


  export type UsuarioSelectScalar = {
    id?: boolean
    cedula?: boolean
    nombres?: boolean
    apellidos?: boolean
    correoInstitucional?: boolean
    rol?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth?: boolean | Usuario$authArgs<ExtArgs>
    propuestas?: boolean | Usuario$propuestasArgs<ExtArgs>
    comentarios?: boolean | Usuario$comentariosArgs<ExtArgs>
    notificaciones?: boolean | Usuario$notificacionesArgs<ExtArgs>
    comites?: boolean | Usuario$comitesArgs<ExtArgs>
    prerequisitos?: boolean | Usuario$prerequisitosArgs<ExtArgs>
    estudiantePerfil?: boolean | Usuario$estudiantePerfilArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      auth: Prisma.$AuthPayload<ExtArgs> | null
      propuestas: Prisma.$PropuestaPayload<ExtArgs>[]
      comentarios: Prisma.$ComentarioPayload<ExtArgs>[]
      notificaciones: Prisma.$NotificacionPayload<ExtArgs>[]
      comites: Prisma.$ComitePayload<ExtArgs>[]
      prerequisitos: Prisma.$EstudiantePrerequisitoPayload<ExtArgs>[]
      estudiantePerfil: Prisma.$EstudiantePerfilPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cedula: string
      nombres: string
      apellidos: string
      correoInstitucional: string
      rol: $Enums.Rol
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auth<T extends Usuario$authArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$authArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    propuestas<T extends Usuario$propuestasArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$propuestasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findMany"> | Null>
    comentarios<T extends Usuario$comentariosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$comentariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findMany"> | Null>
    notificaciones<T extends Usuario$notificacionesArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$notificacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findMany"> | Null>
    comites<T extends Usuario$comitesArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$comitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "findMany"> | Null>
    prerequisitos<T extends Usuario$prerequisitosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$prerequisitosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudiantePrerequisitoPayload<ExtArgs>, T, "findMany"> | Null>
    estudiantePerfil<T extends Usuario$estudiantePerfilArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$estudiantePerfilArgs<ExtArgs>>): Prisma__EstudiantePerfilClient<$Result.GetResult<Prisma.$EstudiantePerfilPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly cedula: FieldRef<"Usuario", 'String'>
    readonly nombres: FieldRef<"Usuario", 'String'>
    readonly apellidos: FieldRef<"Usuario", 'String'>
    readonly correoInstitucional: FieldRef<"Usuario", 'String'>
    readonly rol: FieldRef<"Usuario", 'Rol'>
    readonly createdAt: FieldRef<"Usuario", 'DateTime'>
    readonly updatedAt: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario.auth
   */
  export type Usuario$authArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    where?: AuthWhereInput
  }

  /**
   * Usuario.propuestas
   */
  export type Usuario$propuestasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    where?: PropuestaWhereInput
    orderBy?: PropuestaOrderByWithRelationInput | PropuestaOrderByWithRelationInput[]
    cursor?: PropuestaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropuestaScalarFieldEnum | PropuestaScalarFieldEnum[]
  }

  /**
   * Usuario.comentarios
   */
  export type Usuario$comentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    where?: ComentarioWhereInput
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    cursor?: ComentarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Usuario.notificaciones
   */
  export type Usuario$notificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    where?: NotificacionWhereInput
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    cursor?: NotificacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Usuario.comites
   */
  export type Usuario$comitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    where?: ComiteWhereInput
    orderBy?: ComiteOrderByWithRelationInput | ComiteOrderByWithRelationInput[]
    cursor?: ComiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComiteScalarFieldEnum | ComiteScalarFieldEnum[]
  }

  /**
   * Usuario.prerequisitos
   */
  export type Usuario$prerequisitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePrerequisito
     */
    select?: EstudiantePrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePrerequisitoInclude<ExtArgs> | null
    where?: EstudiantePrerequisitoWhereInput
    orderBy?: EstudiantePrerequisitoOrderByWithRelationInput | EstudiantePrerequisitoOrderByWithRelationInput[]
    cursor?: EstudiantePrerequisitoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EstudiantePrerequisitoScalarFieldEnum | EstudiantePrerequisitoScalarFieldEnum[]
  }

  /**
   * Usuario.estudiantePerfil
   */
  export type Usuario$estudiantePerfilArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePerfil
     */
    select?: EstudiantePerfilSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePerfilInclude<ExtArgs> | null
    where?: EstudiantePerfilWhereInput
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Auth
   */

  export type AggregateAuth = {
    _count: AuthCountAggregateOutputType | null
    _avg: AuthAvgAggregateOutputType | null
    _sum: AuthSumAggregateOutputType | null
    _min: AuthMinAggregateOutputType | null
    _max: AuthMaxAggregateOutputType | null
  }

  export type AuthAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type AuthSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type AuthMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    usuarioId: number | null
  }

  export type AuthMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    usuarioId: number | null
  }

  export type AuthCountAggregateOutputType = {
    id: number
    username: number
    password: number
    usuarioId: number
    _all: number
  }


  export type AuthAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type AuthSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type AuthMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    usuarioId?: true
  }

  export type AuthMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    usuarioId?: true
  }

  export type AuthCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    usuarioId?: true
    _all?: true
  }

  export type AuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auth to aggregate.
     */
    where?: AuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auths to fetch.
     */
    orderBy?: AuthOrderByWithRelationInput | AuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Auths
    **/
    _count?: true | AuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthMaxAggregateInputType
  }

  export type GetAuthAggregateType<T extends AuthAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth[P]>
      : GetScalarType<T[P], AggregateAuth[P]>
  }




  export type AuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthWhereInput
    orderBy?: AuthOrderByWithAggregationInput | AuthOrderByWithAggregationInput[]
    by: AuthScalarFieldEnum[] | AuthScalarFieldEnum
    having?: AuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthCountAggregateInputType | true
    _avg?: AuthAvgAggregateInputType
    _sum?: AuthSumAggregateInputType
    _min?: AuthMinAggregateInputType
    _max?: AuthMaxAggregateInputType
  }

  export type AuthGroupByOutputType = {
    id: number
    username: string
    password: string
    usuarioId: number
    _count: AuthCountAggregateOutputType | null
    _avg: AuthAvgAggregateOutputType | null
    _sum: AuthSumAggregateOutputType | null
    _min: AuthMinAggregateOutputType | null
    _max: AuthMaxAggregateOutputType | null
  }

  type GetAuthGroupByPayload<T extends AuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthGroupByOutputType[P]>
            : GetScalarType<T[P], AuthGroupByOutputType[P]>
        }
      >
    >


  export type AuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    usuarioId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auth"]>


  export type AuthSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    usuarioId?: boolean
  }

  export type AuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $AuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Auth"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      usuarioId: number
    }, ExtArgs["result"]["auth"]>
    composites: {}
  }

  type AuthGetPayload<S extends boolean | null | undefined | AuthDefaultArgs> = $Result.GetResult<Prisma.$AuthPayload, S>

  type AuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuthFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuthCountAggregateInputType | true
    }

  export interface AuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Auth'], meta: { name: 'Auth' } }
    /**
     * Find zero or one Auth that matches the filter.
     * @param {AuthFindUniqueArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthFindUniqueArgs>(args: SelectSubset<T, AuthFindUniqueArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Auth that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuthFindUniqueOrThrowArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Auth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthFindFirstArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthFindFirstArgs>(args?: SelectSubset<T, AuthFindFirstArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Auth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthFindFirstOrThrowArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Auths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auths
     * const auths = await prisma.auth.findMany()
     * 
     * // Get first 10 Auths
     * const auths = await prisma.auth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authWithIdOnly = await prisma.auth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthFindManyArgs>(args?: SelectSubset<T, AuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Auth.
     * @param {AuthCreateArgs} args - Arguments to create a Auth.
     * @example
     * // Create one Auth
     * const Auth = await prisma.auth.create({
     *   data: {
     *     // ... data to create a Auth
     *   }
     * })
     * 
     */
    create<T extends AuthCreateArgs>(args: SelectSubset<T, AuthCreateArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Auths.
     * @param {AuthCreateManyArgs} args - Arguments to create many Auths.
     * @example
     * // Create many Auths
     * const auth = await prisma.auth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthCreateManyArgs>(args?: SelectSubset<T, AuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auth.
     * @param {AuthDeleteArgs} args - Arguments to delete one Auth.
     * @example
     * // Delete one Auth
     * const Auth = await prisma.auth.delete({
     *   where: {
     *     // ... filter to delete one Auth
     *   }
     * })
     * 
     */
    delete<T extends AuthDeleteArgs>(args: SelectSubset<T, AuthDeleteArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Auth.
     * @param {AuthUpdateArgs} args - Arguments to update one Auth.
     * @example
     * // Update one Auth
     * const auth = await prisma.auth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthUpdateArgs>(args: SelectSubset<T, AuthUpdateArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Auths.
     * @param {AuthDeleteManyArgs} args - Arguments to filter Auths to delete.
     * @example
     * // Delete a few Auths
     * const { count } = await prisma.auth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthDeleteManyArgs>(args?: SelectSubset<T, AuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auths
     * const auth = await prisma.auth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthUpdateManyArgs>(args: SelectSubset<T, AuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auth.
     * @param {AuthUpsertArgs} args - Arguments to update or create a Auth.
     * @example
     * // Update or create a Auth
     * const auth = await prisma.auth.upsert({
     *   create: {
     *     // ... data to create a Auth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth we want to update
     *   }
     * })
     */
    upsert<T extends AuthUpsertArgs>(args: SelectSubset<T, AuthUpsertArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Auths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthCountArgs} args - Arguments to filter Auths to count.
     * @example
     * // Count the number of Auths
     * const count = await prisma.auth.count({
     *   where: {
     *     // ... the filter for the Auths we want to count
     *   }
     * })
    **/
    count<T extends AuthCountArgs>(
      args?: Subset<T, AuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthAggregateArgs>(args: Subset<T, AuthAggregateArgs>): Prisma.PrismaPromise<GetAuthAggregateType<T>>

    /**
     * Group by Auth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthGroupByArgs['orderBy'] }
        : { orderBy?: AuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Auth model
   */
  readonly fields: AuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Auth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Auth model
   */ 
  interface AuthFieldRefs {
    readonly id: FieldRef<"Auth", 'Int'>
    readonly username: FieldRef<"Auth", 'String'>
    readonly password: FieldRef<"Auth", 'String'>
    readonly usuarioId: FieldRef<"Auth", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Auth findUnique
   */
  export type AuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * Filter, which Auth to fetch.
     */
    where: AuthWhereUniqueInput
  }

  /**
   * Auth findUniqueOrThrow
   */
  export type AuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * Filter, which Auth to fetch.
     */
    where: AuthWhereUniqueInput
  }

  /**
   * Auth findFirst
   */
  export type AuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * Filter, which Auth to fetch.
     */
    where?: AuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auths to fetch.
     */
    orderBy?: AuthOrderByWithRelationInput | AuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auths.
     */
    cursor?: AuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auths.
     */
    distinct?: AuthScalarFieldEnum | AuthScalarFieldEnum[]
  }

  /**
   * Auth findFirstOrThrow
   */
  export type AuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * Filter, which Auth to fetch.
     */
    where?: AuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auths to fetch.
     */
    orderBy?: AuthOrderByWithRelationInput | AuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auths.
     */
    cursor?: AuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auths.
     */
    distinct?: AuthScalarFieldEnum | AuthScalarFieldEnum[]
  }

  /**
   * Auth findMany
   */
  export type AuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * Filter, which Auths to fetch.
     */
    where?: AuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auths to fetch.
     */
    orderBy?: AuthOrderByWithRelationInput | AuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Auths.
     */
    cursor?: AuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auths.
     */
    skip?: number
    distinct?: AuthScalarFieldEnum | AuthScalarFieldEnum[]
  }

  /**
   * Auth create
   */
  export type AuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * The data needed to create a Auth.
     */
    data: XOR<AuthCreateInput, AuthUncheckedCreateInput>
  }

  /**
   * Auth createMany
   */
  export type AuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Auths.
     */
    data: AuthCreateManyInput | AuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Auth update
   */
  export type AuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * The data needed to update a Auth.
     */
    data: XOR<AuthUpdateInput, AuthUncheckedUpdateInput>
    /**
     * Choose, which Auth to update.
     */
    where: AuthWhereUniqueInput
  }

  /**
   * Auth updateMany
   */
  export type AuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Auths.
     */
    data: XOR<AuthUpdateManyMutationInput, AuthUncheckedUpdateManyInput>
    /**
     * Filter which Auths to update
     */
    where?: AuthWhereInput
  }

  /**
   * Auth upsert
   */
  export type AuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * The filter to search for the Auth to update in case it exists.
     */
    where: AuthWhereUniqueInput
    /**
     * In case the Auth found by the `where` argument doesn't exist, create a new Auth with this data.
     */
    create: XOR<AuthCreateInput, AuthUncheckedCreateInput>
    /**
     * In case the Auth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthUpdateInput, AuthUncheckedUpdateInput>
  }

  /**
   * Auth delete
   */
  export type AuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * Filter which Auth to delete.
     */
    where: AuthWhereUniqueInput
  }

  /**
   * Auth deleteMany
   */
  export type AuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auths to delete
     */
    where?: AuthWhereInput
  }

  /**
   * Auth without action
   */
  export type AuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
  }


  /**
   * Model AreaConocimiento
   */

  export type AggregateAreaConocimiento = {
    _count: AreaConocimientoCountAggregateOutputType | null
    _avg: AreaConocimientoAvgAggregateOutputType | null
    _sum: AreaConocimientoSumAggregateOutputType | null
    _min: AreaConocimientoMinAggregateOutputType | null
    _max: AreaConocimientoMaxAggregateOutputType | null
  }

  export type AreaConocimientoAvgAggregateOutputType = {
    id: number | null
  }

  export type AreaConocimientoSumAggregateOutputType = {
    id: number | null
  }

  export type AreaConocimientoMinAggregateOutputType = {
    id: number | null
    codigo: string | null
    nombre: string | null
    descripcion: string | null
  }

  export type AreaConocimientoMaxAggregateOutputType = {
    id: number | null
    codigo: string | null
    nombre: string | null
    descripcion: string | null
  }

  export type AreaConocimientoCountAggregateOutputType = {
    id: number
    codigo: number
    nombre: number
    descripcion: number
    _all: number
  }


  export type AreaConocimientoAvgAggregateInputType = {
    id?: true
  }

  export type AreaConocimientoSumAggregateInputType = {
    id?: true
  }

  export type AreaConocimientoMinAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    descripcion?: true
  }

  export type AreaConocimientoMaxAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    descripcion?: true
  }

  export type AreaConocimientoCountAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    descripcion?: true
    _all?: true
  }

  export type AreaConocimientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AreaConocimiento to aggregate.
     */
    where?: AreaConocimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaConocimientos to fetch.
     */
    orderBy?: AreaConocimientoOrderByWithRelationInput | AreaConocimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AreaConocimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaConocimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaConocimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AreaConocimientos
    **/
    _count?: true | AreaConocimientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AreaConocimientoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AreaConocimientoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AreaConocimientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AreaConocimientoMaxAggregateInputType
  }

  export type GetAreaConocimientoAggregateType<T extends AreaConocimientoAggregateArgs> = {
        [P in keyof T & keyof AggregateAreaConocimiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAreaConocimiento[P]>
      : GetScalarType<T[P], AggregateAreaConocimiento[P]>
  }




  export type AreaConocimientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaConocimientoWhereInput
    orderBy?: AreaConocimientoOrderByWithAggregationInput | AreaConocimientoOrderByWithAggregationInput[]
    by: AreaConocimientoScalarFieldEnum[] | AreaConocimientoScalarFieldEnum
    having?: AreaConocimientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AreaConocimientoCountAggregateInputType | true
    _avg?: AreaConocimientoAvgAggregateInputType
    _sum?: AreaConocimientoSumAggregateInputType
    _min?: AreaConocimientoMinAggregateInputType
    _max?: AreaConocimientoMaxAggregateInputType
  }

  export type AreaConocimientoGroupByOutputType = {
    id: number
    codigo: string
    nombre: string
    descripcion: string | null
    _count: AreaConocimientoCountAggregateOutputType | null
    _avg: AreaConocimientoAvgAggregateOutputType | null
    _sum: AreaConocimientoSumAggregateOutputType | null
    _min: AreaConocimientoMinAggregateOutputType | null
    _max: AreaConocimientoMaxAggregateOutputType | null
  }

  type GetAreaConocimientoGroupByPayload<T extends AreaConocimientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AreaConocimientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AreaConocimientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AreaConocimientoGroupByOutputType[P]>
            : GetScalarType<T[P], AreaConocimientoGroupByOutputType[P]>
        }
      >
    >


  export type AreaConocimientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    propuestas?: boolean | AreaConocimiento$propuestasArgs<ExtArgs>
    _count?: boolean | AreaConocimientoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["areaConocimiento"]>


  export type AreaConocimientoSelectScalar = {
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
  }

  export type AreaConocimientoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propuestas?: boolean | AreaConocimiento$propuestasArgs<ExtArgs>
    _count?: boolean | AreaConocimientoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AreaConocimientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AreaConocimiento"
    objects: {
      propuestas: Prisma.$PropuestaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codigo: string
      nombre: string
      descripcion: string | null
    }, ExtArgs["result"]["areaConocimiento"]>
    composites: {}
  }

  type AreaConocimientoGetPayload<S extends boolean | null | undefined | AreaConocimientoDefaultArgs> = $Result.GetResult<Prisma.$AreaConocimientoPayload, S>

  type AreaConocimientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AreaConocimientoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AreaConocimientoCountAggregateInputType | true
    }

  export interface AreaConocimientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AreaConocimiento'], meta: { name: 'AreaConocimiento' } }
    /**
     * Find zero or one AreaConocimiento that matches the filter.
     * @param {AreaConocimientoFindUniqueArgs} args - Arguments to find a AreaConocimiento
     * @example
     * // Get one AreaConocimiento
     * const areaConocimiento = await prisma.areaConocimiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AreaConocimientoFindUniqueArgs>(args: SelectSubset<T, AreaConocimientoFindUniqueArgs<ExtArgs>>): Prisma__AreaConocimientoClient<$Result.GetResult<Prisma.$AreaConocimientoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AreaConocimiento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AreaConocimientoFindUniqueOrThrowArgs} args - Arguments to find a AreaConocimiento
     * @example
     * // Get one AreaConocimiento
     * const areaConocimiento = await prisma.areaConocimiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AreaConocimientoFindUniqueOrThrowArgs>(args: SelectSubset<T, AreaConocimientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AreaConocimientoClient<$Result.GetResult<Prisma.$AreaConocimientoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AreaConocimiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaConocimientoFindFirstArgs} args - Arguments to find a AreaConocimiento
     * @example
     * // Get one AreaConocimiento
     * const areaConocimiento = await prisma.areaConocimiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AreaConocimientoFindFirstArgs>(args?: SelectSubset<T, AreaConocimientoFindFirstArgs<ExtArgs>>): Prisma__AreaConocimientoClient<$Result.GetResult<Prisma.$AreaConocimientoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AreaConocimiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaConocimientoFindFirstOrThrowArgs} args - Arguments to find a AreaConocimiento
     * @example
     * // Get one AreaConocimiento
     * const areaConocimiento = await prisma.areaConocimiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AreaConocimientoFindFirstOrThrowArgs>(args?: SelectSubset<T, AreaConocimientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AreaConocimientoClient<$Result.GetResult<Prisma.$AreaConocimientoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AreaConocimientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaConocimientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AreaConocimientos
     * const areaConocimientos = await prisma.areaConocimiento.findMany()
     * 
     * // Get first 10 AreaConocimientos
     * const areaConocimientos = await prisma.areaConocimiento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areaConocimientoWithIdOnly = await prisma.areaConocimiento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AreaConocimientoFindManyArgs>(args?: SelectSubset<T, AreaConocimientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaConocimientoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AreaConocimiento.
     * @param {AreaConocimientoCreateArgs} args - Arguments to create a AreaConocimiento.
     * @example
     * // Create one AreaConocimiento
     * const AreaConocimiento = await prisma.areaConocimiento.create({
     *   data: {
     *     // ... data to create a AreaConocimiento
     *   }
     * })
     * 
     */
    create<T extends AreaConocimientoCreateArgs>(args: SelectSubset<T, AreaConocimientoCreateArgs<ExtArgs>>): Prisma__AreaConocimientoClient<$Result.GetResult<Prisma.$AreaConocimientoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AreaConocimientos.
     * @param {AreaConocimientoCreateManyArgs} args - Arguments to create many AreaConocimientos.
     * @example
     * // Create many AreaConocimientos
     * const areaConocimiento = await prisma.areaConocimiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AreaConocimientoCreateManyArgs>(args?: SelectSubset<T, AreaConocimientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AreaConocimiento.
     * @param {AreaConocimientoDeleteArgs} args - Arguments to delete one AreaConocimiento.
     * @example
     * // Delete one AreaConocimiento
     * const AreaConocimiento = await prisma.areaConocimiento.delete({
     *   where: {
     *     // ... filter to delete one AreaConocimiento
     *   }
     * })
     * 
     */
    delete<T extends AreaConocimientoDeleteArgs>(args: SelectSubset<T, AreaConocimientoDeleteArgs<ExtArgs>>): Prisma__AreaConocimientoClient<$Result.GetResult<Prisma.$AreaConocimientoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AreaConocimiento.
     * @param {AreaConocimientoUpdateArgs} args - Arguments to update one AreaConocimiento.
     * @example
     * // Update one AreaConocimiento
     * const areaConocimiento = await prisma.areaConocimiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AreaConocimientoUpdateArgs>(args: SelectSubset<T, AreaConocimientoUpdateArgs<ExtArgs>>): Prisma__AreaConocimientoClient<$Result.GetResult<Prisma.$AreaConocimientoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AreaConocimientos.
     * @param {AreaConocimientoDeleteManyArgs} args - Arguments to filter AreaConocimientos to delete.
     * @example
     * // Delete a few AreaConocimientos
     * const { count } = await prisma.areaConocimiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AreaConocimientoDeleteManyArgs>(args?: SelectSubset<T, AreaConocimientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AreaConocimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaConocimientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AreaConocimientos
     * const areaConocimiento = await prisma.areaConocimiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AreaConocimientoUpdateManyArgs>(args: SelectSubset<T, AreaConocimientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AreaConocimiento.
     * @param {AreaConocimientoUpsertArgs} args - Arguments to update or create a AreaConocimiento.
     * @example
     * // Update or create a AreaConocimiento
     * const areaConocimiento = await prisma.areaConocimiento.upsert({
     *   create: {
     *     // ... data to create a AreaConocimiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AreaConocimiento we want to update
     *   }
     * })
     */
    upsert<T extends AreaConocimientoUpsertArgs>(args: SelectSubset<T, AreaConocimientoUpsertArgs<ExtArgs>>): Prisma__AreaConocimientoClient<$Result.GetResult<Prisma.$AreaConocimientoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AreaConocimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaConocimientoCountArgs} args - Arguments to filter AreaConocimientos to count.
     * @example
     * // Count the number of AreaConocimientos
     * const count = await prisma.areaConocimiento.count({
     *   where: {
     *     // ... the filter for the AreaConocimientos we want to count
     *   }
     * })
    **/
    count<T extends AreaConocimientoCountArgs>(
      args?: Subset<T, AreaConocimientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaConocimientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AreaConocimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaConocimientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreaConocimientoAggregateArgs>(args: Subset<T, AreaConocimientoAggregateArgs>): Prisma.PrismaPromise<GetAreaConocimientoAggregateType<T>>

    /**
     * Group by AreaConocimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaConocimientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AreaConocimientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AreaConocimientoGroupByArgs['orderBy'] }
        : { orderBy?: AreaConocimientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AreaConocimientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAreaConocimientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AreaConocimiento model
   */
  readonly fields: AreaConocimientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AreaConocimiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AreaConocimientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    propuestas<T extends AreaConocimiento$propuestasArgs<ExtArgs> = {}>(args?: Subset<T, AreaConocimiento$propuestasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AreaConocimiento model
   */ 
  interface AreaConocimientoFieldRefs {
    readonly id: FieldRef<"AreaConocimiento", 'Int'>
    readonly codigo: FieldRef<"AreaConocimiento", 'String'>
    readonly nombre: FieldRef<"AreaConocimiento", 'String'>
    readonly descripcion: FieldRef<"AreaConocimiento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AreaConocimiento findUnique
   */
  export type AreaConocimientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaConocimiento
     */
    select?: AreaConocimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaConocimientoInclude<ExtArgs> | null
    /**
     * Filter, which AreaConocimiento to fetch.
     */
    where: AreaConocimientoWhereUniqueInput
  }

  /**
   * AreaConocimiento findUniqueOrThrow
   */
  export type AreaConocimientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaConocimiento
     */
    select?: AreaConocimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaConocimientoInclude<ExtArgs> | null
    /**
     * Filter, which AreaConocimiento to fetch.
     */
    where: AreaConocimientoWhereUniqueInput
  }

  /**
   * AreaConocimiento findFirst
   */
  export type AreaConocimientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaConocimiento
     */
    select?: AreaConocimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaConocimientoInclude<ExtArgs> | null
    /**
     * Filter, which AreaConocimiento to fetch.
     */
    where?: AreaConocimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaConocimientos to fetch.
     */
    orderBy?: AreaConocimientoOrderByWithRelationInput | AreaConocimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AreaConocimientos.
     */
    cursor?: AreaConocimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaConocimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaConocimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AreaConocimientos.
     */
    distinct?: AreaConocimientoScalarFieldEnum | AreaConocimientoScalarFieldEnum[]
  }

  /**
   * AreaConocimiento findFirstOrThrow
   */
  export type AreaConocimientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaConocimiento
     */
    select?: AreaConocimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaConocimientoInclude<ExtArgs> | null
    /**
     * Filter, which AreaConocimiento to fetch.
     */
    where?: AreaConocimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaConocimientos to fetch.
     */
    orderBy?: AreaConocimientoOrderByWithRelationInput | AreaConocimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AreaConocimientos.
     */
    cursor?: AreaConocimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaConocimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaConocimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AreaConocimientos.
     */
    distinct?: AreaConocimientoScalarFieldEnum | AreaConocimientoScalarFieldEnum[]
  }

  /**
   * AreaConocimiento findMany
   */
  export type AreaConocimientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaConocimiento
     */
    select?: AreaConocimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaConocimientoInclude<ExtArgs> | null
    /**
     * Filter, which AreaConocimientos to fetch.
     */
    where?: AreaConocimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AreaConocimientos to fetch.
     */
    orderBy?: AreaConocimientoOrderByWithRelationInput | AreaConocimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AreaConocimientos.
     */
    cursor?: AreaConocimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AreaConocimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AreaConocimientos.
     */
    skip?: number
    distinct?: AreaConocimientoScalarFieldEnum | AreaConocimientoScalarFieldEnum[]
  }

  /**
   * AreaConocimiento create
   */
  export type AreaConocimientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaConocimiento
     */
    select?: AreaConocimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaConocimientoInclude<ExtArgs> | null
    /**
     * The data needed to create a AreaConocimiento.
     */
    data: XOR<AreaConocimientoCreateInput, AreaConocimientoUncheckedCreateInput>
  }

  /**
   * AreaConocimiento createMany
   */
  export type AreaConocimientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AreaConocimientos.
     */
    data: AreaConocimientoCreateManyInput | AreaConocimientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AreaConocimiento update
   */
  export type AreaConocimientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaConocimiento
     */
    select?: AreaConocimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaConocimientoInclude<ExtArgs> | null
    /**
     * The data needed to update a AreaConocimiento.
     */
    data: XOR<AreaConocimientoUpdateInput, AreaConocimientoUncheckedUpdateInput>
    /**
     * Choose, which AreaConocimiento to update.
     */
    where: AreaConocimientoWhereUniqueInput
  }

  /**
   * AreaConocimiento updateMany
   */
  export type AreaConocimientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AreaConocimientos.
     */
    data: XOR<AreaConocimientoUpdateManyMutationInput, AreaConocimientoUncheckedUpdateManyInput>
    /**
     * Filter which AreaConocimientos to update
     */
    where?: AreaConocimientoWhereInput
  }

  /**
   * AreaConocimiento upsert
   */
  export type AreaConocimientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaConocimiento
     */
    select?: AreaConocimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaConocimientoInclude<ExtArgs> | null
    /**
     * The filter to search for the AreaConocimiento to update in case it exists.
     */
    where: AreaConocimientoWhereUniqueInput
    /**
     * In case the AreaConocimiento found by the `where` argument doesn't exist, create a new AreaConocimiento with this data.
     */
    create: XOR<AreaConocimientoCreateInput, AreaConocimientoUncheckedCreateInput>
    /**
     * In case the AreaConocimiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AreaConocimientoUpdateInput, AreaConocimientoUncheckedUpdateInput>
  }

  /**
   * AreaConocimiento delete
   */
  export type AreaConocimientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaConocimiento
     */
    select?: AreaConocimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaConocimientoInclude<ExtArgs> | null
    /**
     * Filter which AreaConocimiento to delete.
     */
    where: AreaConocimientoWhereUniqueInput
  }

  /**
   * AreaConocimiento deleteMany
   */
  export type AreaConocimientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AreaConocimientos to delete
     */
    where?: AreaConocimientoWhereInput
  }

  /**
   * AreaConocimiento.propuestas
   */
  export type AreaConocimiento$propuestasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    where?: PropuestaWhereInput
    orderBy?: PropuestaOrderByWithRelationInput | PropuestaOrderByWithRelationInput[]
    cursor?: PropuestaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropuestaScalarFieldEnum | PropuestaScalarFieldEnum[]
  }

  /**
   * AreaConocimiento without action
   */
  export type AreaConocimientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaConocimiento
     */
    select?: AreaConocimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaConocimientoInclude<ExtArgs> | null
  }


  /**
   * Model Propuesta
   */

  export type AggregatePropuesta = {
    _count: PropuestaCountAggregateOutputType | null
    _avg: PropuestaAvgAggregateOutputType | null
    _sum: PropuestaSumAggregateOutputType | null
    _min: PropuestaMinAggregateOutputType | null
    _max: PropuestaMaxAggregateOutputType | null
  }

  export type PropuestaAvgAggregateOutputType = {
    id: number | null
    areaConocimientoId: number | null
    fkEstudiante: number | null
  }

  export type PropuestaSumAggregateOutputType = {
    id: number | null
    areaConocimientoId: number | null
    fkEstudiante: number | null
  }

  export type PropuestaMinAggregateOutputType = {
    id: number | null
    titulo: string | null
    objetivos: string | null
    problematica: string | null
    areaConocimientoId: number | null
    alcance: string | null
    archivoUrl: string | null
    fechaPublicacion: Date | null
    estado: $Enums.EstadoPropuesta | null
    fkEstudiante: number | null
    fechaDefensa: Date | null
    resultadoDefensa: $Enums.ResultadoDefensa | null
  }

  export type PropuestaMaxAggregateOutputType = {
    id: number | null
    titulo: string | null
    objetivos: string | null
    problematica: string | null
    areaConocimientoId: number | null
    alcance: string | null
    archivoUrl: string | null
    fechaPublicacion: Date | null
    estado: $Enums.EstadoPropuesta | null
    fkEstudiante: number | null
    fechaDefensa: Date | null
    resultadoDefensa: $Enums.ResultadoDefensa | null
  }

  export type PropuestaCountAggregateOutputType = {
    id: number
    titulo: number
    objetivos: number
    problematica: number
    areaConocimientoId: number
    alcance: number
    archivoUrl: number
    fechaPublicacion: number
    estado: number
    fkEstudiante: number
    fechaDefensa: number
    resultadoDefensa: number
    _all: number
  }


  export type PropuestaAvgAggregateInputType = {
    id?: true
    areaConocimientoId?: true
    fkEstudiante?: true
  }

  export type PropuestaSumAggregateInputType = {
    id?: true
    areaConocimientoId?: true
    fkEstudiante?: true
  }

  export type PropuestaMinAggregateInputType = {
    id?: true
    titulo?: true
    objetivos?: true
    problematica?: true
    areaConocimientoId?: true
    alcance?: true
    archivoUrl?: true
    fechaPublicacion?: true
    estado?: true
    fkEstudiante?: true
    fechaDefensa?: true
    resultadoDefensa?: true
  }

  export type PropuestaMaxAggregateInputType = {
    id?: true
    titulo?: true
    objetivos?: true
    problematica?: true
    areaConocimientoId?: true
    alcance?: true
    archivoUrl?: true
    fechaPublicacion?: true
    estado?: true
    fkEstudiante?: true
    fechaDefensa?: true
    resultadoDefensa?: true
  }

  export type PropuestaCountAggregateInputType = {
    id?: true
    titulo?: true
    objetivos?: true
    problematica?: true
    areaConocimientoId?: true
    alcance?: true
    archivoUrl?: true
    fechaPublicacion?: true
    estado?: true
    fkEstudiante?: true
    fechaDefensa?: true
    resultadoDefensa?: true
    _all?: true
  }

  export type PropuestaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Propuesta to aggregate.
     */
    where?: PropuestaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Propuestas to fetch.
     */
    orderBy?: PropuestaOrderByWithRelationInput | PropuestaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropuestaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Propuestas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Propuestas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Propuestas
    **/
    _count?: true | PropuestaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropuestaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropuestaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropuestaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropuestaMaxAggregateInputType
  }

  export type GetPropuestaAggregateType<T extends PropuestaAggregateArgs> = {
        [P in keyof T & keyof AggregatePropuesta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropuesta[P]>
      : GetScalarType<T[P], AggregatePropuesta[P]>
  }




  export type PropuestaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropuestaWhereInput
    orderBy?: PropuestaOrderByWithAggregationInput | PropuestaOrderByWithAggregationInput[]
    by: PropuestaScalarFieldEnum[] | PropuestaScalarFieldEnum
    having?: PropuestaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropuestaCountAggregateInputType | true
    _avg?: PropuestaAvgAggregateInputType
    _sum?: PropuestaSumAggregateInputType
    _min?: PropuestaMinAggregateInputType
    _max?: PropuestaMaxAggregateInputType
  }

  export type PropuestaGroupByOutputType = {
    id: number
    titulo: string
    objetivos: string
    problematica: string | null
    areaConocimientoId: number
    alcance: string | null
    archivoUrl: string | null
    fechaPublicacion: Date
    estado: $Enums.EstadoPropuesta
    fkEstudiante: number
    fechaDefensa: Date | null
    resultadoDefensa: $Enums.ResultadoDefensa | null
    _count: PropuestaCountAggregateOutputType | null
    _avg: PropuestaAvgAggregateOutputType | null
    _sum: PropuestaSumAggregateOutputType | null
    _min: PropuestaMinAggregateOutputType | null
    _max: PropuestaMaxAggregateOutputType | null
  }

  type GetPropuestaGroupByPayload<T extends PropuestaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropuestaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropuestaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropuestaGroupByOutputType[P]>
            : GetScalarType<T[P], PropuestaGroupByOutputType[P]>
        }
      >
    >


  export type PropuestaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    objetivos?: boolean
    problematica?: boolean
    areaConocimientoId?: boolean
    alcance?: boolean
    archivoUrl?: boolean
    fechaPublicacion?: boolean
    estado?: boolean
    fkEstudiante?: boolean
    fechaDefensa?: boolean
    resultadoDefensa?: boolean
    areaConocimiento?: boolean | AreaConocimientoDefaultArgs<ExtArgs>
    estudiante?: boolean | UsuarioDefaultArgs<ExtArgs>
    trabajosTitulacion?: boolean | Propuesta$trabajosTitulacionArgs<ExtArgs>
    actividades?: boolean | Propuesta$actividadesArgs<ExtArgs>
    comites?: boolean | Propuesta$comitesArgs<ExtArgs>
    entregablesFinales?: boolean | Propuesta$entregablesFinalesArgs<ExtArgs>
    _count?: boolean | PropuestaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propuesta"]>


  export type PropuestaSelectScalar = {
    id?: boolean
    titulo?: boolean
    objetivos?: boolean
    problematica?: boolean
    areaConocimientoId?: boolean
    alcance?: boolean
    archivoUrl?: boolean
    fechaPublicacion?: boolean
    estado?: boolean
    fkEstudiante?: boolean
    fechaDefensa?: boolean
    resultadoDefensa?: boolean
  }

  export type PropuestaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    areaConocimiento?: boolean | AreaConocimientoDefaultArgs<ExtArgs>
    estudiante?: boolean | UsuarioDefaultArgs<ExtArgs>
    trabajosTitulacion?: boolean | Propuesta$trabajosTitulacionArgs<ExtArgs>
    actividades?: boolean | Propuesta$actividadesArgs<ExtArgs>
    comites?: boolean | Propuesta$comitesArgs<ExtArgs>
    entregablesFinales?: boolean | Propuesta$entregablesFinalesArgs<ExtArgs>
    _count?: boolean | PropuestaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PropuestaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Propuesta"
    objects: {
      areaConocimiento: Prisma.$AreaConocimientoPayload<ExtArgs>
      estudiante: Prisma.$UsuarioPayload<ExtArgs>
      trabajosTitulacion: Prisma.$TrabajoTitulacionPayload<ExtArgs>[]
      actividades: Prisma.$ActividadPayload<ExtArgs>[]
      comites: Prisma.$ComitePayload<ExtArgs>[]
      entregablesFinales: Prisma.$EntregableFinalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      titulo: string
      objetivos: string
      problematica: string | null
      areaConocimientoId: number
      alcance: string | null
      archivoUrl: string | null
      fechaPublicacion: Date
      estado: $Enums.EstadoPropuesta
      fkEstudiante: number
      fechaDefensa: Date | null
      resultadoDefensa: $Enums.ResultadoDefensa | null
    }, ExtArgs["result"]["propuesta"]>
    composites: {}
  }

  type PropuestaGetPayload<S extends boolean | null | undefined | PropuestaDefaultArgs> = $Result.GetResult<Prisma.$PropuestaPayload, S>

  type PropuestaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropuestaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PropuestaCountAggregateInputType | true
    }

  export interface PropuestaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Propuesta'], meta: { name: 'Propuesta' } }
    /**
     * Find zero or one Propuesta that matches the filter.
     * @param {PropuestaFindUniqueArgs} args - Arguments to find a Propuesta
     * @example
     * // Get one Propuesta
     * const propuesta = await prisma.propuesta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropuestaFindUniqueArgs>(args: SelectSubset<T, PropuestaFindUniqueArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Propuesta that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PropuestaFindUniqueOrThrowArgs} args - Arguments to find a Propuesta
     * @example
     * // Get one Propuesta
     * const propuesta = await prisma.propuesta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropuestaFindUniqueOrThrowArgs>(args: SelectSubset<T, PropuestaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Propuesta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropuestaFindFirstArgs} args - Arguments to find a Propuesta
     * @example
     * // Get one Propuesta
     * const propuesta = await prisma.propuesta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropuestaFindFirstArgs>(args?: SelectSubset<T, PropuestaFindFirstArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Propuesta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropuestaFindFirstOrThrowArgs} args - Arguments to find a Propuesta
     * @example
     * // Get one Propuesta
     * const propuesta = await prisma.propuesta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropuestaFindFirstOrThrowArgs>(args?: SelectSubset<T, PropuestaFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Propuestas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropuestaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Propuestas
     * const propuestas = await prisma.propuesta.findMany()
     * 
     * // Get first 10 Propuestas
     * const propuestas = await prisma.propuesta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propuestaWithIdOnly = await prisma.propuesta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropuestaFindManyArgs>(args?: SelectSubset<T, PropuestaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Propuesta.
     * @param {PropuestaCreateArgs} args - Arguments to create a Propuesta.
     * @example
     * // Create one Propuesta
     * const Propuesta = await prisma.propuesta.create({
     *   data: {
     *     // ... data to create a Propuesta
     *   }
     * })
     * 
     */
    create<T extends PropuestaCreateArgs>(args: SelectSubset<T, PropuestaCreateArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Propuestas.
     * @param {PropuestaCreateManyArgs} args - Arguments to create many Propuestas.
     * @example
     * // Create many Propuestas
     * const propuesta = await prisma.propuesta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropuestaCreateManyArgs>(args?: SelectSubset<T, PropuestaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Propuesta.
     * @param {PropuestaDeleteArgs} args - Arguments to delete one Propuesta.
     * @example
     * // Delete one Propuesta
     * const Propuesta = await prisma.propuesta.delete({
     *   where: {
     *     // ... filter to delete one Propuesta
     *   }
     * })
     * 
     */
    delete<T extends PropuestaDeleteArgs>(args: SelectSubset<T, PropuestaDeleteArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Propuesta.
     * @param {PropuestaUpdateArgs} args - Arguments to update one Propuesta.
     * @example
     * // Update one Propuesta
     * const propuesta = await prisma.propuesta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropuestaUpdateArgs>(args: SelectSubset<T, PropuestaUpdateArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Propuestas.
     * @param {PropuestaDeleteManyArgs} args - Arguments to filter Propuestas to delete.
     * @example
     * // Delete a few Propuestas
     * const { count } = await prisma.propuesta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropuestaDeleteManyArgs>(args?: SelectSubset<T, PropuestaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Propuestas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropuestaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Propuestas
     * const propuesta = await prisma.propuesta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropuestaUpdateManyArgs>(args: SelectSubset<T, PropuestaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Propuesta.
     * @param {PropuestaUpsertArgs} args - Arguments to update or create a Propuesta.
     * @example
     * // Update or create a Propuesta
     * const propuesta = await prisma.propuesta.upsert({
     *   create: {
     *     // ... data to create a Propuesta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Propuesta we want to update
     *   }
     * })
     */
    upsert<T extends PropuestaUpsertArgs>(args: SelectSubset<T, PropuestaUpsertArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Propuestas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropuestaCountArgs} args - Arguments to filter Propuestas to count.
     * @example
     * // Count the number of Propuestas
     * const count = await prisma.propuesta.count({
     *   where: {
     *     // ... the filter for the Propuestas we want to count
     *   }
     * })
    **/
    count<T extends PropuestaCountArgs>(
      args?: Subset<T, PropuestaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropuestaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Propuesta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropuestaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropuestaAggregateArgs>(args: Subset<T, PropuestaAggregateArgs>): Prisma.PrismaPromise<GetPropuestaAggregateType<T>>

    /**
     * Group by Propuesta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropuestaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropuestaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropuestaGroupByArgs['orderBy'] }
        : { orderBy?: PropuestaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropuestaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropuestaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Propuesta model
   */
  readonly fields: PropuestaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Propuesta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropuestaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    areaConocimiento<T extends AreaConocimientoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AreaConocimientoDefaultArgs<ExtArgs>>): Prisma__AreaConocimientoClient<$Result.GetResult<Prisma.$AreaConocimientoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    estudiante<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    trabajosTitulacion<T extends Propuesta$trabajosTitulacionArgs<ExtArgs> = {}>(args?: Subset<T, Propuesta$trabajosTitulacionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrabajoTitulacionPayload<ExtArgs>, T, "findMany"> | Null>
    actividades<T extends Propuesta$actividadesArgs<ExtArgs> = {}>(args?: Subset<T, Propuesta$actividadesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "findMany"> | Null>
    comites<T extends Propuesta$comitesArgs<ExtArgs> = {}>(args?: Subset<T, Propuesta$comitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "findMany"> | Null>
    entregablesFinales<T extends Propuesta$entregablesFinalesArgs<ExtArgs> = {}>(args?: Subset<T, Propuesta$entregablesFinalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Propuesta model
   */ 
  interface PropuestaFieldRefs {
    readonly id: FieldRef<"Propuesta", 'Int'>
    readonly titulo: FieldRef<"Propuesta", 'String'>
    readonly objetivos: FieldRef<"Propuesta", 'String'>
    readonly problematica: FieldRef<"Propuesta", 'String'>
    readonly areaConocimientoId: FieldRef<"Propuesta", 'Int'>
    readonly alcance: FieldRef<"Propuesta", 'String'>
    readonly archivoUrl: FieldRef<"Propuesta", 'String'>
    readonly fechaPublicacion: FieldRef<"Propuesta", 'DateTime'>
    readonly estado: FieldRef<"Propuesta", 'EstadoPropuesta'>
    readonly fkEstudiante: FieldRef<"Propuesta", 'Int'>
    readonly fechaDefensa: FieldRef<"Propuesta", 'DateTime'>
    readonly resultadoDefensa: FieldRef<"Propuesta", 'ResultadoDefensa'>
  }
    

  // Custom InputTypes
  /**
   * Propuesta findUnique
   */
  export type PropuestaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * Filter, which Propuesta to fetch.
     */
    where: PropuestaWhereUniqueInput
  }

  /**
   * Propuesta findUniqueOrThrow
   */
  export type PropuestaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * Filter, which Propuesta to fetch.
     */
    where: PropuestaWhereUniqueInput
  }

  /**
   * Propuesta findFirst
   */
  export type PropuestaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * Filter, which Propuesta to fetch.
     */
    where?: PropuestaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Propuestas to fetch.
     */
    orderBy?: PropuestaOrderByWithRelationInput | PropuestaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Propuestas.
     */
    cursor?: PropuestaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Propuestas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Propuestas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Propuestas.
     */
    distinct?: PropuestaScalarFieldEnum | PropuestaScalarFieldEnum[]
  }

  /**
   * Propuesta findFirstOrThrow
   */
  export type PropuestaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * Filter, which Propuesta to fetch.
     */
    where?: PropuestaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Propuestas to fetch.
     */
    orderBy?: PropuestaOrderByWithRelationInput | PropuestaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Propuestas.
     */
    cursor?: PropuestaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Propuestas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Propuestas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Propuestas.
     */
    distinct?: PropuestaScalarFieldEnum | PropuestaScalarFieldEnum[]
  }

  /**
   * Propuesta findMany
   */
  export type PropuestaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * Filter, which Propuestas to fetch.
     */
    where?: PropuestaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Propuestas to fetch.
     */
    orderBy?: PropuestaOrderByWithRelationInput | PropuestaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Propuestas.
     */
    cursor?: PropuestaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Propuestas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Propuestas.
     */
    skip?: number
    distinct?: PropuestaScalarFieldEnum | PropuestaScalarFieldEnum[]
  }

  /**
   * Propuesta create
   */
  export type PropuestaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * The data needed to create a Propuesta.
     */
    data: XOR<PropuestaCreateInput, PropuestaUncheckedCreateInput>
  }

  /**
   * Propuesta createMany
   */
  export type PropuestaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Propuestas.
     */
    data: PropuestaCreateManyInput | PropuestaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Propuesta update
   */
  export type PropuestaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * The data needed to update a Propuesta.
     */
    data: XOR<PropuestaUpdateInput, PropuestaUncheckedUpdateInput>
    /**
     * Choose, which Propuesta to update.
     */
    where: PropuestaWhereUniqueInput
  }

  /**
   * Propuesta updateMany
   */
  export type PropuestaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Propuestas.
     */
    data: XOR<PropuestaUpdateManyMutationInput, PropuestaUncheckedUpdateManyInput>
    /**
     * Filter which Propuestas to update
     */
    where?: PropuestaWhereInput
  }

  /**
   * Propuesta upsert
   */
  export type PropuestaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * The filter to search for the Propuesta to update in case it exists.
     */
    where: PropuestaWhereUniqueInput
    /**
     * In case the Propuesta found by the `where` argument doesn't exist, create a new Propuesta with this data.
     */
    create: XOR<PropuestaCreateInput, PropuestaUncheckedCreateInput>
    /**
     * In case the Propuesta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropuestaUpdateInput, PropuestaUncheckedUpdateInput>
  }

  /**
   * Propuesta delete
   */
  export type PropuestaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * Filter which Propuesta to delete.
     */
    where: PropuestaWhereUniqueInput
  }

  /**
   * Propuesta deleteMany
   */
  export type PropuestaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Propuestas to delete
     */
    where?: PropuestaWhereInput
  }

  /**
   * Propuesta.trabajosTitulacion
   */
  export type Propuesta$trabajosTitulacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrabajoTitulacion
     */
    select?: TrabajoTitulacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrabajoTitulacionInclude<ExtArgs> | null
    where?: TrabajoTitulacionWhereInput
    orderBy?: TrabajoTitulacionOrderByWithRelationInput | TrabajoTitulacionOrderByWithRelationInput[]
    cursor?: TrabajoTitulacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrabajoTitulacionScalarFieldEnum | TrabajoTitulacionScalarFieldEnum[]
  }

  /**
   * Propuesta.actividades
   */
  export type Propuesta$actividadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    where?: ActividadWhereInput
    orderBy?: ActividadOrderByWithRelationInput | ActividadOrderByWithRelationInput[]
    cursor?: ActividadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActividadScalarFieldEnum | ActividadScalarFieldEnum[]
  }

  /**
   * Propuesta.comites
   */
  export type Propuesta$comitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    where?: ComiteWhereInput
    orderBy?: ComiteOrderByWithRelationInput | ComiteOrderByWithRelationInput[]
    cursor?: ComiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComiteScalarFieldEnum | ComiteScalarFieldEnum[]
  }

  /**
   * Propuesta.entregablesFinales
   */
  export type Propuesta$entregablesFinalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    where?: EntregableFinalWhereInput
    orderBy?: EntregableFinalOrderByWithRelationInput | EntregableFinalOrderByWithRelationInput[]
    cursor?: EntregableFinalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntregableFinalScalarFieldEnum | EntregableFinalScalarFieldEnum[]
  }

  /**
   * Propuesta without action
   */
  export type PropuestaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
  }


  /**
   * Model TrabajoTitulacion
   */

  export type AggregateTrabajoTitulacion = {
    _count: TrabajoTitulacionCountAggregateOutputType | null
    _avg: TrabajoTitulacionAvgAggregateOutputType | null
    _sum: TrabajoTitulacionSumAggregateOutputType | null
    _min: TrabajoTitulacionMinAggregateOutputType | null
    _max: TrabajoTitulacionMaxAggregateOutputType | null
  }

  export type TrabajoTitulacionAvgAggregateOutputType = {
    propuestasId: number | null
    fkTutorId: number | null
  }

  export type TrabajoTitulacionSumAggregateOutputType = {
    propuestasId: number | null
    fkTutorId: number | null
  }

  export type TrabajoTitulacionMinAggregateOutputType = {
    propuestasId: number | null
    fkTutorId: number | null
  }

  export type TrabajoTitulacionMaxAggregateOutputType = {
    propuestasId: number | null
    fkTutorId: number | null
  }

  export type TrabajoTitulacionCountAggregateOutputType = {
    propuestasId: number
    fkTutorId: number
    _all: number
  }


  export type TrabajoTitulacionAvgAggregateInputType = {
    propuestasId?: true
    fkTutorId?: true
  }

  export type TrabajoTitulacionSumAggregateInputType = {
    propuestasId?: true
    fkTutorId?: true
  }

  export type TrabajoTitulacionMinAggregateInputType = {
    propuestasId?: true
    fkTutorId?: true
  }

  export type TrabajoTitulacionMaxAggregateInputType = {
    propuestasId?: true
    fkTutorId?: true
  }

  export type TrabajoTitulacionCountAggregateInputType = {
    propuestasId?: true
    fkTutorId?: true
    _all?: true
  }

  export type TrabajoTitulacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrabajoTitulacion to aggregate.
     */
    where?: TrabajoTitulacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrabajoTitulacions to fetch.
     */
    orderBy?: TrabajoTitulacionOrderByWithRelationInput | TrabajoTitulacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrabajoTitulacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrabajoTitulacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrabajoTitulacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrabajoTitulacions
    **/
    _count?: true | TrabajoTitulacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrabajoTitulacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrabajoTitulacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrabajoTitulacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrabajoTitulacionMaxAggregateInputType
  }

  export type GetTrabajoTitulacionAggregateType<T extends TrabajoTitulacionAggregateArgs> = {
        [P in keyof T & keyof AggregateTrabajoTitulacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrabajoTitulacion[P]>
      : GetScalarType<T[P], AggregateTrabajoTitulacion[P]>
  }




  export type TrabajoTitulacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrabajoTitulacionWhereInput
    orderBy?: TrabajoTitulacionOrderByWithAggregationInput | TrabajoTitulacionOrderByWithAggregationInput[]
    by: TrabajoTitulacionScalarFieldEnum[] | TrabajoTitulacionScalarFieldEnum
    having?: TrabajoTitulacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrabajoTitulacionCountAggregateInputType | true
    _avg?: TrabajoTitulacionAvgAggregateInputType
    _sum?: TrabajoTitulacionSumAggregateInputType
    _min?: TrabajoTitulacionMinAggregateInputType
    _max?: TrabajoTitulacionMaxAggregateInputType
  }

  export type TrabajoTitulacionGroupByOutputType = {
    propuestasId: number
    fkTutorId: number
    _count: TrabajoTitulacionCountAggregateOutputType | null
    _avg: TrabajoTitulacionAvgAggregateOutputType | null
    _sum: TrabajoTitulacionSumAggregateOutputType | null
    _min: TrabajoTitulacionMinAggregateOutputType | null
    _max: TrabajoTitulacionMaxAggregateOutputType | null
  }

  type GetTrabajoTitulacionGroupByPayload<T extends TrabajoTitulacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrabajoTitulacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrabajoTitulacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrabajoTitulacionGroupByOutputType[P]>
            : GetScalarType<T[P], TrabajoTitulacionGroupByOutputType[P]>
        }
      >
    >


  export type TrabajoTitulacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    propuestasId?: boolean
    fkTutorId?: boolean
    propuesta?: boolean | PropuestaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trabajoTitulacion"]>


  export type TrabajoTitulacionSelectScalar = {
    propuestasId?: boolean
    fkTutorId?: boolean
  }

  export type TrabajoTitulacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propuesta?: boolean | PropuestaDefaultArgs<ExtArgs>
  }

  export type $TrabajoTitulacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrabajoTitulacion"
    objects: {
      propuesta: Prisma.$PropuestaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      propuestasId: number
      fkTutorId: number
    }, ExtArgs["result"]["trabajoTitulacion"]>
    composites: {}
  }

  type TrabajoTitulacionGetPayload<S extends boolean | null | undefined | TrabajoTitulacionDefaultArgs> = $Result.GetResult<Prisma.$TrabajoTitulacionPayload, S>

  type TrabajoTitulacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrabajoTitulacionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrabajoTitulacionCountAggregateInputType | true
    }

  export interface TrabajoTitulacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrabajoTitulacion'], meta: { name: 'TrabajoTitulacion' } }
    /**
     * Find zero or one TrabajoTitulacion that matches the filter.
     * @param {TrabajoTitulacionFindUniqueArgs} args - Arguments to find a TrabajoTitulacion
     * @example
     * // Get one TrabajoTitulacion
     * const trabajoTitulacion = await prisma.trabajoTitulacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrabajoTitulacionFindUniqueArgs>(args: SelectSubset<T, TrabajoTitulacionFindUniqueArgs<ExtArgs>>): Prisma__TrabajoTitulacionClient<$Result.GetResult<Prisma.$TrabajoTitulacionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrabajoTitulacion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrabajoTitulacionFindUniqueOrThrowArgs} args - Arguments to find a TrabajoTitulacion
     * @example
     * // Get one TrabajoTitulacion
     * const trabajoTitulacion = await prisma.trabajoTitulacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrabajoTitulacionFindUniqueOrThrowArgs>(args: SelectSubset<T, TrabajoTitulacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrabajoTitulacionClient<$Result.GetResult<Prisma.$TrabajoTitulacionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrabajoTitulacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrabajoTitulacionFindFirstArgs} args - Arguments to find a TrabajoTitulacion
     * @example
     * // Get one TrabajoTitulacion
     * const trabajoTitulacion = await prisma.trabajoTitulacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrabajoTitulacionFindFirstArgs>(args?: SelectSubset<T, TrabajoTitulacionFindFirstArgs<ExtArgs>>): Prisma__TrabajoTitulacionClient<$Result.GetResult<Prisma.$TrabajoTitulacionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrabajoTitulacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrabajoTitulacionFindFirstOrThrowArgs} args - Arguments to find a TrabajoTitulacion
     * @example
     * // Get one TrabajoTitulacion
     * const trabajoTitulacion = await prisma.trabajoTitulacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrabajoTitulacionFindFirstOrThrowArgs>(args?: SelectSubset<T, TrabajoTitulacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrabajoTitulacionClient<$Result.GetResult<Prisma.$TrabajoTitulacionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrabajoTitulacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrabajoTitulacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrabajoTitulacions
     * const trabajoTitulacions = await prisma.trabajoTitulacion.findMany()
     * 
     * // Get first 10 TrabajoTitulacions
     * const trabajoTitulacions = await prisma.trabajoTitulacion.findMany({ take: 10 })
     * 
     * // Only select the `propuestasId`
     * const trabajoTitulacionWithPropuestasIdOnly = await prisma.trabajoTitulacion.findMany({ select: { propuestasId: true } })
     * 
     */
    findMany<T extends TrabajoTitulacionFindManyArgs>(args?: SelectSubset<T, TrabajoTitulacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrabajoTitulacionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrabajoTitulacion.
     * @param {TrabajoTitulacionCreateArgs} args - Arguments to create a TrabajoTitulacion.
     * @example
     * // Create one TrabajoTitulacion
     * const TrabajoTitulacion = await prisma.trabajoTitulacion.create({
     *   data: {
     *     // ... data to create a TrabajoTitulacion
     *   }
     * })
     * 
     */
    create<T extends TrabajoTitulacionCreateArgs>(args: SelectSubset<T, TrabajoTitulacionCreateArgs<ExtArgs>>): Prisma__TrabajoTitulacionClient<$Result.GetResult<Prisma.$TrabajoTitulacionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrabajoTitulacions.
     * @param {TrabajoTitulacionCreateManyArgs} args - Arguments to create many TrabajoTitulacions.
     * @example
     * // Create many TrabajoTitulacions
     * const trabajoTitulacion = await prisma.trabajoTitulacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrabajoTitulacionCreateManyArgs>(args?: SelectSubset<T, TrabajoTitulacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrabajoTitulacion.
     * @param {TrabajoTitulacionDeleteArgs} args - Arguments to delete one TrabajoTitulacion.
     * @example
     * // Delete one TrabajoTitulacion
     * const TrabajoTitulacion = await prisma.trabajoTitulacion.delete({
     *   where: {
     *     // ... filter to delete one TrabajoTitulacion
     *   }
     * })
     * 
     */
    delete<T extends TrabajoTitulacionDeleteArgs>(args: SelectSubset<T, TrabajoTitulacionDeleteArgs<ExtArgs>>): Prisma__TrabajoTitulacionClient<$Result.GetResult<Prisma.$TrabajoTitulacionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrabajoTitulacion.
     * @param {TrabajoTitulacionUpdateArgs} args - Arguments to update one TrabajoTitulacion.
     * @example
     * // Update one TrabajoTitulacion
     * const trabajoTitulacion = await prisma.trabajoTitulacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrabajoTitulacionUpdateArgs>(args: SelectSubset<T, TrabajoTitulacionUpdateArgs<ExtArgs>>): Prisma__TrabajoTitulacionClient<$Result.GetResult<Prisma.$TrabajoTitulacionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrabajoTitulacions.
     * @param {TrabajoTitulacionDeleteManyArgs} args - Arguments to filter TrabajoTitulacions to delete.
     * @example
     * // Delete a few TrabajoTitulacions
     * const { count } = await prisma.trabajoTitulacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrabajoTitulacionDeleteManyArgs>(args?: SelectSubset<T, TrabajoTitulacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrabajoTitulacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrabajoTitulacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrabajoTitulacions
     * const trabajoTitulacion = await prisma.trabajoTitulacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrabajoTitulacionUpdateManyArgs>(args: SelectSubset<T, TrabajoTitulacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrabajoTitulacion.
     * @param {TrabajoTitulacionUpsertArgs} args - Arguments to update or create a TrabajoTitulacion.
     * @example
     * // Update or create a TrabajoTitulacion
     * const trabajoTitulacion = await prisma.trabajoTitulacion.upsert({
     *   create: {
     *     // ... data to create a TrabajoTitulacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrabajoTitulacion we want to update
     *   }
     * })
     */
    upsert<T extends TrabajoTitulacionUpsertArgs>(args: SelectSubset<T, TrabajoTitulacionUpsertArgs<ExtArgs>>): Prisma__TrabajoTitulacionClient<$Result.GetResult<Prisma.$TrabajoTitulacionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrabajoTitulacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrabajoTitulacionCountArgs} args - Arguments to filter TrabajoTitulacions to count.
     * @example
     * // Count the number of TrabajoTitulacions
     * const count = await prisma.trabajoTitulacion.count({
     *   where: {
     *     // ... the filter for the TrabajoTitulacions we want to count
     *   }
     * })
    **/
    count<T extends TrabajoTitulacionCountArgs>(
      args?: Subset<T, TrabajoTitulacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrabajoTitulacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrabajoTitulacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrabajoTitulacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrabajoTitulacionAggregateArgs>(args: Subset<T, TrabajoTitulacionAggregateArgs>): Prisma.PrismaPromise<GetTrabajoTitulacionAggregateType<T>>

    /**
     * Group by TrabajoTitulacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrabajoTitulacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrabajoTitulacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrabajoTitulacionGroupByArgs['orderBy'] }
        : { orderBy?: TrabajoTitulacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrabajoTitulacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrabajoTitulacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrabajoTitulacion model
   */
  readonly fields: TrabajoTitulacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrabajoTitulacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrabajoTitulacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    propuesta<T extends PropuestaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropuestaDefaultArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrabajoTitulacion model
   */ 
  interface TrabajoTitulacionFieldRefs {
    readonly propuestasId: FieldRef<"TrabajoTitulacion", 'Int'>
    readonly fkTutorId: FieldRef<"TrabajoTitulacion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TrabajoTitulacion findUnique
   */
  export type TrabajoTitulacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrabajoTitulacion
     */
    select?: TrabajoTitulacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrabajoTitulacionInclude<ExtArgs> | null
    /**
     * Filter, which TrabajoTitulacion to fetch.
     */
    where: TrabajoTitulacionWhereUniqueInput
  }

  /**
   * TrabajoTitulacion findUniqueOrThrow
   */
  export type TrabajoTitulacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrabajoTitulacion
     */
    select?: TrabajoTitulacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrabajoTitulacionInclude<ExtArgs> | null
    /**
     * Filter, which TrabajoTitulacion to fetch.
     */
    where: TrabajoTitulacionWhereUniqueInput
  }

  /**
   * TrabajoTitulacion findFirst
   */
  export type TrabajoTitulacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrabajoTitulacion
     */
    select?: TrabajoTitulacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrabajoTitulacionInclude<ExtArgs> | null
    /**
     * Filter, which TrabajoTitulacion to fetch.
     */
    where?: TrabajoTitulacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrabajoTitulacions to fetch.
     */
    orderBy?: TrabajoTitulacionOrderByWithRelationInput | TrabajoTitulacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrabajoTitulacions.
     */
    cursor?: TrabajoTitulacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrabajoTitulacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrabajoTitulacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrabajoTitulacions.
     */
    distinct?: TrabajoTitulacionScalarFieldEnum | TrabajoTitulacionScalarFieldEnum[]
  }

  /**
   * TrabajoTitulacion findFirstOrThrow
   */
  export type TrabajoTitulacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrabajoTitulacion
     */
    select?: TrabajoTitulacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrabajoTitulacionInclude<ExtArgs> | null
    /**
     * Filter, which TrabajoTitulacion to fetch.
     */
    where?: TrabajoTitulacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrabajoTitulacions to fetch.
     */
    orderBy?: TrabajoTitulacionOrderByWithRelationInput | TrabajoTitulacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrabajoTitulacions.
     */
    cursor?: TrabajoTitulacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrabajoTitulacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrabajoTitulacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrabajoTitulacions.
     */
    distinct?: TrabajoTitulacionScalarFieldEnum | TrabajoTitulacionScalarFieldEnum[]
  }

  /**
   * TrabajoTitulacion findMany
   */
  export type TrabajoTitulacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrabajoTitulacion
     */
    select?: TrabajoTitulacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrabajoTitulacionInclude<ExtArgs> | null
    /**
     * Filter, which TrabajoTitulacions to fetch.
     */
    where?: TrabajoTitulacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrabajoTitulacions to fetch.
     */
    orderBy?: TrabajoTitulacionOrderByWithRelationInput | TrabajoTitulacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrabajoTitulacions.
     */
    cursor?: TrabajoTitulacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrabajoTitulacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrabajoTitulacions.
     */
    skip?: number
    distinct?: TrabajoTitulacionScalarFieldEnum | TrabajoTitulacionScalarFieldEnum[]
  }

  /**
   * TrabajoTitulacion create
   */
  export type TrabajoTitulacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrabajoTitulacion
     */
    select?: TrabajoTitulacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrabajoTitulacionInclude<ExtArgs> | null
    /**
     * The data needed to create a TrabajoTitulacion.
     */
    data: XOR<TrabajoTitulacionCreateInput, TrabajoTitulacionUncheckedCreateInput>
  }

  /**
   * TrabajoTitulacion createMany
   */
  export type TrabajoTitulacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrabajoTitulacions.
     */
    data: TrabajoTitulacionCreateManyInput | TrabajoTitulacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrabajoTitulacion update
   */
  export type TrabajoTitulacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrabajoTitulacion
     */
    select?: TrabajoTitulacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrabajoTitulacionInclude<ExtArgs> | null
    /**
     * The data needed to update a TrabajoTitulacion.
     */
    data: XOR<TrabajoTitulacionUpdateInput, TrabajoTitulacionUncheckedUpdateInput>
    /**
     * Choose, which TrabajoTitulacion to update.
     */
    where: TrabajoTitulacionWhereUniqueInput
  }

  /**
   * TrabajoTitulacion updateMany
   */
  export type TrabajoTitulacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrabajoTitulacions.
     */
    data: XOR<TrabajoTitulacionUpdateManyMutationInput, TrabajoTitulacionUncheckedUpdateManyInput>
    /**
     * Filter which TrabajoTitulacions to update
     */
    where?: TrabajoTitulacionWhereInput
  }

  /**
   * TrabajoTitulacion upsert
   */
  export type TrabajoTitulacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrabajoTitulacion
     */
    select?: TrabajoTitulacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrabajoTitulacionInclude<ExtArgs> | null
    /**
     * The filter to search for the TrabajoTitulacion to update in case it exists.
     */
    where: TrabajoTitulacionWhereUniqueInput
    /**
     * In case the TrabajoTitulacion found by the `where` argument doesn't exist, create a new TrabajoTitulacion with this data.
     */
    create: XOR<TrabajoTitulacionCreateInput, TrabajoTitulacionUncheckedCreateInput>
    /**
     * In case the TrabajoTitulacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrabajoTitulacionUpdateInput, TrabajoTitulacionUncheckedUpdateInput>
  }

  /**
   * TrabajoTitulacion delete
   */
  export type TrabajoTitulacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrabajoTitulacion
     */
    select?: TrabajoTitulacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrabajoTitulacionInclude<ExtArgs> | null
    /**
     * Filter which TrabajoTitulacion to delete.
     */
    where: TrabajoTitulacionWhereUniqueInput
  }

  /**
   * TrabajoTitulacion deleteMany
   */
  export type TrabajoTitulacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrabajoTitulacions to delete
     */
    where?: TrabajoTitulacionWhereInput
  }

  /**
   * TrabajoTitulacion without action
   */
  export type TrabajoTitulacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrabajoTitulacion
     */
    select?: TrabajoTitulacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrabajoTitulacionInclude<ExtArgs> | null
  }


  /**
   * Model Actividad
   */

  export type AggregateActividad = {
    _count: ActividadCountAggregateOutputType | null
    _avg: ActividadAvgAggregateOutputType | null
    _sum: ActividadSumAggregateOutputType | null
    _min: ActividadMinAggregateOutputType | null
    _max: ActividadMaxAggregateOutputType | null
  }

  export type ActividadAvgAggregateOutputType = {
    id: number | null
    propuestaId: number | null
  }

  export type ActividadSumAggregateOutputType = {
    id: number | null
    propuestaId: number | null
  }

  export type ActividadMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    propuestaId: number | null
    tipo: $Enums.TipoActividad | null
  }

  export type ActividadMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    propuestaId: number | null
    tipo: $Enums.TipoActividad | null
  }

  export type ActividadCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    propuestaId: number
    tipo: number
    _all: number
  }


  export type ActividadAvgAggregateInputType = {
    id?: true
    propuestaId?: true
  }

  export type ActividadSumAggregateInputType = {
    id?: true
    propuestaId?: true
  }

  export type ActividadMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    propuestaId?: true
    tipo?: true
  }

  export type ActividadMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    propuestaId?: true
    tipo?: true
  }

  export type ActividadCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    propuestaId?: true
    tipo?: true
    _all?: true
  }

  export type ActividadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actividad to aggregate.
     */
    where?: ActividadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actividads to fetch.
     */
    orderBy?: ActividadOrderByWithRelationInput | ActividadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActividadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actividads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actividads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actividads
    **/
    _count?: true | ActividadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActividadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActividadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActividadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActividadMaxAggregateInputType
  }

  export type GetActividadAggregateType<T extends ActividadAggregateArgs> = {
        [P in keyof T & keyof AggregateActividad]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActividad[P]>
      : GetScalarType<T[P], AggregateActividad[P]>
  }




  export type ActividadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActividadWhereInput
    orderBy?: ActividadOrderByWithAggregationInput | ActividadOrderByWithAggregationInput[]
    by: ActividadScalarFieldEnum[] | ActividadScalarFieldEnum
    having?: ActividadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActividadCountAggregateInputType | true
    _avg?: ActividadAvgAggregateInputType
    _sum?: ActividadSumAggregateInputType
    _min?: ActividadMinAggregateInputType
    _max?: ActividadMaxAggregateInputType
  }

  export type ActividadGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string | null
    propuestaId: number
    tipo: $Enums.TipoActividad
    _count: ActividadCountAggregateOutputType | null
    _avg: ActividadAvgAggregateOutputType | null
    _sum: ActividadSumAggregateOutputType | null
    _min: ActividadMinAggregateOutputType | null
    _max: ActividadMaxAggregateOutputType | null
  }

  type GetActividadGroupByPayload<T extends ActividadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActividadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActividadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActividadGroupByOutputType[P]>
            : GetScalarType<T[P], ActividadGroupByOutputType[P]>
        }
      >
    >


  export type ActividadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    propuestaId?: boolean
    tipo?: boolean
    propuesta?: boolean | PropuestaDefaultArgs<ExtArgs>
    evidencias?: boolean | Actividad$evidenciasArgs<ExtArgs>
    _count?: boolean | ActividadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actividad"]>


  export type ActividadSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    propuestaId?: boolean
    tipo?: boolean
  }

  export type ActividadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propuesta?: boolean | PropuestaDefaultArgs<ExtArgs>
    evidencias?: boolean | Actividad$evidenciasArgs<ExtArgs>
    _count?: boolean | ActividadCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ActividadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Actividad"
    objects: {
      propuesta: Prisma.$PropuestaPayload<ExtArgs>
      evidencias: Prisma.$EvidenciaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string | null
      propuestaId: number
      tipo: $Enums.TipoActividad
    }, ExtArgs["result"]["actividad"]>
    composites: {}
  }

  type ActividadGetPayload<S extends boolean | null | undefined | ActividadDefaultArgs> = $Result.GetResult<Prisma.$ActividadPayload, S>

  type ActividadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActividadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActividadCountAggregateInputType | true
    }

  export interface ActividadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Actividad'], meta: { name: 'Actividad' } }
    /**
     * Find zero or one Actividad that matches the filter.
     * @param {ActividadFindUniqueArgs} args - Arguments to find a Actividad
     * @example
     * // Get one Actividad
     * const actividad = await prisma.actividad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActividadFindUniqueArgs>(args: SelectSubset<T, ActividadFindUniqueArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Actividad that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActividadFindUniqueOrThrowArgs} args - Arguments to find a Actividad
     * @example
     * // Get one Actividad
     * const actividad = await prisma.actividad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActividadFindUniqueOrThrowArgs>(args: SelectSubset<T, ActividadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Actividad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadFindFirstArgs} args - Arguments to find a Actividad
     * @example
     * // Get one Actividad
     * const actividad = await prisma.actividad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActividadFindFirstArgs>(args?: SelectSubset<T, ActividadFindFirstArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Actividad that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadFindFirstOrThrowArgs} args - Arguments to find a Actividad
     * @example
     * // Get one Actividad
     * const actividad = await prisma.actividad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActividadFindFirstOrThrowArgs>(args?: SelectSubset<T, ActividadFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Actividads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actividads
     * const actividads = await prisma.actividad.findMany()
     * 
     * // Get first 10 Actividads
     * const actividads = await prisma.actividad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actividadWithIdOnly = await prisma.actividad.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActividadFindManyArgs>(args?: SelectSubset<T, ActividadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Actividad.
     * @param {ActividadCreateArgs} args - Arguments to create a Actividad.
     * @example
     * // Create one Actividad
     * const Actividad = await prisma.actividad.create({
     *   data: {
     *     // ... data to create a Actividad
     *   }
     * })
     * 
     */
    create<T extends ActividadCreateArgs>(args: SelectSubset<T, ActividadCreateArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Actividads.
     * @param {ActividadCreateManyArgs} args - Arguments to create many Actividads.
     * @example
     * // Create many Actividads
     * const actividad = await prisma.actividad.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActividadCreateManyArgs>(args?: SelectSubset<T, ActividadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Actividad.
     * @param {ActividadDeleteArgs} args - Arguments to delete one Actividad.
     * @example
     * // Delete one Actividad
     * const Actividad = await prisma.actividad.delete({
     *   where: {
     *     // ... filter to delete one Actividad
     *   }
     * })
     * 
     */
    delete<T extends ActividadDeleteArgs>(args: SelectSubset<T, ActividadDeleteArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Actividad.
     * @param {ActividadUpdateArgs} args - Arguments to update one Actividad.
     * @example
     * // Update one Actividad
     * const actividad = await prisma.actividad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActividadUpdateArgs>(args: SelectSubset<T, ActividadUpdateArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Actividads.
     * @param {ActividadDeleteManyArgs} args - Arguments to filter Actividads to delete.
     * @example
     * // Delete a few Actividads
     * const { count } = await prisma.actividad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActividadDeleteManyArgs>(args?: SelectSubset<T, ActividadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actividads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actividads
     * const actividad = await prisma.actividad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActividadUpdateManyArgs>(args: SelectSubset<T, ActividadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Actividad.
     * @param {ActividadUpsertArgs} args - Arguments to update or create a Actividad.
     * @example
     * // Update or create a Actividad
     * const actividad = await prisma.actividad.upsert({
     *   create: {
     *     // ... data to create a Actividad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Actividad we want to update
     *   }
     * })
     */
    upsert<T extends ActividadUpsertArgs>(args: SelectSubset<T, ActividadUpsertArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Actividads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadCountArgs} args - Arguments to filter Actividads to count.
     * @example
     * // Count the number of Actividads
     * const count = await prisma.actividad.count({
     *   where: {
     *     // ... the filter for the Actividads we want to count
     *   }
     * })
    **/
    count<T extends ActividadCountArgs>(
      args?: Subset<T, ActividadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActividadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Actividad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActividadAggregateArgs>(args: Subset<T, ActividadAggregateArgs>): Prisma.PrismaPromise<GetActividadAggregateType<T>>

    /**
     * Group by Actividad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActividadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActividadGroupByArgs['orderBy'] }
        : { orderBy?: ActividadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActividadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActividadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Actividad model
   */
  readonly fields: ActividadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Actividad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActividadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    propuesta<T extends PropuestaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropuestaDefaultArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    evidencias<T extends Actividad$evidenciasArgs<ExtArgs> = {}>(args?: Subset<T, Actividad$evidenciasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Actividad model
   */ 
  interface ActividadFieldRefs {
    readonly id: FieldRef<"Actividad", 'Int'>
    readonly nombre: FieldRef<"Actividad", 'String'>
    readonly descripcion: FieldRef<"Actividad", 'String'>
    readonly propuestaId: FieldRef<"Actividad", 'Int'>
    readonly tipo: FieldRef<"Actividad", 'TipoActividad'>
  }
    

  // Custom InputTypes
  /**
   * Actividad findUnique
   */
  export type ActividadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * Filter, which Actividad to fetch.
     */
    where: ActividadWhereUniqueInput
  }

  /**
   * Actividad findUniqueOrThrow
   */
  export type ActividadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * Filter, which Actividad to fetch.
     */
    where: ActividadWhereUniqueInput
  }

  /**
   * Actividad findFirst
   */
  export type ActividadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * Filter, which Actividad to fetch.
     */
    where?: ActividadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actividads to fetch.
     */
    orderBy?: ActividadOrderByWithRelationInput | ActividadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actividads.
     */
    cursor?: ActividadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actividads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actividads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actividads.
     */
    distinct?: ActividadScalarFieldEnum | ActividadScalarFieldEnum[]
  }

  /**
   * Actividad findFirstOrThrow
   */
  export type ActividadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * Filter, which Actividad to fetch.
     */
    where?: ActividadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actividads to fetch.
     */
    orderBy?: ActividadOrderByWithRelationInput | ActividadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actividads.
     */
    cursor?: ActividadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actividads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actividads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actividads.
     */
    distinct?: ActividadScalarFieldEnum | ActividadScalarFieldEnum[]
  }

  /**
   * Actividad findMany
   */
  export type ActividadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * Filter, which Actividads to fetch.
     */
    where?: ActividadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actividads to fetch.
     */
    orderBy?: ActividadOrderByWithRelationInput | ActividadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actividads.
     */
    cursor?: ActividadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actividads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actividads.
     */
    skip?: number
    distinct?: ActividadScalarFieldEnum | ActividadScalarFieldEnum[]
  }

  /**
   * Actividad create
   */
  export type ActividadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * The data needed to create a Actividad.
     */
    data: XOR<ActividadCreateInput, ActividadUncheckedCreateInput>
  }

  /**
   * Actividad createMany
   */
  export type ActividadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Actividads.
     */
    data: ActividadCreateManyInput | ActividadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Actividad update
   */
  export type ActividadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * The data needed to update a Actividad.
     */
    data: XOR<ActividadUpdateInput, ActividadUncheckedUpdateInput>
    /**
     * Choose, which Actividad to update.
     */
    where: ActividadWhereUniqueInput
  }

  /**
   * Actividad updateMany
   */
  export type ActividadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Actividads.
     */
    data: XOR<ActividadUpdateManyMutationInput, ActividadUncheckedUpdateManyInput>
    /**
     * Filter which Actividads to update
     */
    where?: ActividadWhereInput
  }

  /**
   * Actividad upsert
   */
  export type ActividadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * The filter to search for the Actividad to update in case it exists.
     */
    where: ActividadWhereUniqueInput
    /**
     * In case the Actividad found by the `where` argument doesn't exist, create a new Actividad with this data.
     */
    create: XOR<ActividadCreateInput, ActividadUncheckedCreateInput>
    /**
     * In case the Actividad was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActividadUpdateInput, ActividadUncheckedUpdateInput>
  }

  /**
   * Actividad delete
   */
  export type ActividadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * Filter which Actividad to delete.
     */
    where: ActividadWhereUniqueInput
  }

  /**
   * Actividad deleteMany
   */
  export type ActividadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actividads to delete
     */
    where?: ActividadWhereInput
  }

  /**
   * Actividad.evidencias
   */
  export type Actividad$evidenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    where?: EvidenciaWhereInput
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    cursor?: EvidenciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * Actividad without action
   */
  export type ActividadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
  }


  /**
   * Model Evidencia
   */

  export type AggregateEvidencia = {
    _count: EvidenciaCountAggregateOutputType | null
    _avg: EvidenciaAvgAggregateOutputType | null
    _sum: EvidenciaSumAggregateOutputType | null
    _min: EvidenciaMinAggregateOutputType | null
    _max: EvidenciaMaxAggregateOutputType | null
  }

  export type EvidenciaAvgAggregateOutputType = {
    id: number | null
    semana: number | null
    calificacion: Decimal | null
    actividadId: number | null
  }

  export type EvidenciaSumAggregateOutputType = {
    id: number | null
    semana: number | null
    calificacion: Decimal | null
    actividadId: number | null
  }

  export type EvidenciaMinAggregateOutputType = {
    id: number | null
    semana: number | null
    contenido: string | null
    archivoUrl: string | null
    fechaEntrega: Date | null
    estado: $Enums.EstadoEvidencia | null
    calificacion: Decimal | null
    actividadId: number | null
  }

  export type EvidenciaMaxAggregateOutputType = {
    id: number | null
    semana: number | null
    contenido: string | null
    archivoUrl: string | null
    fechaEntrega: Date | null
    estado: $Enums.EstadoEvidencia | null
    calificacion: Decimal | null
    actividadId: number | null
  }

  export type EvidenciaCountAggregateOutputType = {
    id: number
    semana: number
    contenido: number
    archivoUrl: number
    fechaEntrega: number
    estado: number
    calificacion: number
    actividadId: number
    _all: number
  }


  export type EvidenciaAvgAggregateInputType = {
    id?: true
    semana?: true
    calificacion?: true
    actividadId?: true
  }

  export type EvidenciaSumAggregateInputType = {
    id?: true
    semana?: true
    calificacion?: true
    actividadId?: true
  }

  export type EvidenciaMinAggregateInputType = {
    id?: true
    semana?: true
    contenido?: true
    archivoUrl?: true
    fechaEntrega?: true
    estado?: true
    calificacion?: true
    actividadId?: true
  }

  export type EvidenciaMaxAggregateInputType = {
    id?: true
    semana?: true
    contenido?: true
    archivoUrl?: true
    fechaEntrega?: true
    estado?: true
    calificacion?: true
    actividadId?: true
  }

  export type EvidenciaCountAggregateInputType = {
    id?: true
    semana?: true
    contenido?: true
    archivoUrl?: true
    fechaEntrega?: true
    estado?: true
    calificacion?: true
    actividadId?: true
    _all?: true
  }

  export type EvidenciaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evidencia to aggregate.
     */
    where?: EvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidencias to fetch.
     */
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evidencias
    **/
    _count?: true | EvidenciaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvidenciaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvidenciaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvidenciaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvidenciaMaxAggregateInputType
  }

  export type GetEvidenciaAggregateType<T extends EvidenciaAggregateArgs> = {
        [P in keyof T & keyof AggregateEvidencia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvidencia[P]>
      : GetScalarType<T[P], AggregateEvidencia[P]>
  }




  export type EvidenciaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenciaWhereInput
    orderBy?: EvidenciaOrderByWithAggregationInput | EvidenciaOrderByWithAggregationInput[]
    by: EvidenciaScalarFieldEnum[] | EvidenciaScalarFieldEnum
    having?: EvidenciaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvidenciaCountAggregateInputType | true
    _avg?: EvidenciaAvgAggregateInputType
    _sum?: EvidenciaSumAggregateInputType
    _min?: EvidenciaMinAggregateInputType
    _max?: EvidenciaMaxAggregateInputType
  }

  export type EvidenciaGroupByOutputType = {
    id: number
    semana: number
    contenido: string
    archivoUrl: string | null
    fechaEntrega: Date
    estado: $Enums.EstadoEvidencia
    calificacion: Decimal | null
    actividadId: number
    _count: EvidenciaCountAggregateOutputType | null
    _avg: EvidenciaAvgAggregateOutputType | null
    _sum: EvidenciaSumAggregateOutputType | null
    _min: EvidenciaMinAggregateOutputType | null
    _max: EvidenciaMaxAggregateOutputType | null
  }

  type GetEvidenciaGroupByPayload<T extends EvidenciaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvidenciaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvidenciaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvidenciaGroupByOutputType[P]>
            : GetScalarType<T[P], EvidenciaGroupByOutputType[P]>
        }
      >
    >


  export type EvidenciaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    semana?: boolean
    contenido?: boolean
    archivoUrl?: boolean
    fechaEntrega?: boolean
    estado?: boolean
    calificacion?: boolean
    actividadId?: boolean
    actividad?: boolean | ActividadDefaultArgs<ExtArgs>
    comentarios?: boolean | Evidencia$comentariosArgs<ExtArgs>
    _count?: boolean | EvidenciaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evidencia"]>


  export type EvidenciaSelectScalar = {
    id?: boolean
    semana?: boolean
    contenido?: boolean
    archivoUrl?: boolean
    fechaEntrega?: boolean
    estado?: boolean
    calificacion?: boolean
    actividadId?: boolean
  }

  export type EvidenciaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actividad?: boolean | ActividadDefaultArgs<ExtArgs>
    comentarios?: boolean | Evidencia$comentariosArgs<ExtArgs>
    _count?: boolean | EvidenciaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EvidenciaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evidencia"
    objects: {
      actividad: Prisma.$ActividadPayload<ExtArgs>
      comentarios: Prisma.$ComentarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      semana: number
      contenido: string
      archivoUrl: string | null
      fechaEntrega: Date
      estado: $Enums.EstadoEvidencia
      calificacion: Prisma.Decimal | null
      actividadId: number
    }, ExtArgs["result"]["evidencia"]>
    composites: {}
  }

  type EvidenciaGetPayload<S extends boolean | null | undefined | EvidenciaDefaultArgs> = $Result.GetResult<Prisma.$EvidenciaPayload, S>

  type EvidenciaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvidenciaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvidenciaCountAggregateInputType | true
    }

  export interface EvidenciaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evidencia'], meta: { name: 'Evidencia' } }
    /**
     * Find zero or one Evidencia that matches the filter.
     * @param {EvidenciaFindUniqueArgs} args - Arguments to find a Evidencia
     * @example
     * // Get one Evidencia
     * const evidencia = await prisma.evidencia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvidenciaFindUniqueArgs>(args: SelectSubset<T, EvidenciaFindUniqueArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Evidencia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvidenciaFindUniqueOrThrowArgs} args - Arguments to find a Evidencia
     * @example
     * // Get one Evidencia
     * const evidencia = await prisma.evidencia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvidenciaFindUniqueOrThrowArgs>(args: SelectSubset<T, EvidenciaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Evidencia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaFindFirstArgs} args - Arguments to find a Evidencia
     * @example
     * // Get one Evidencia
     * const evidencia = await prisma.evidencia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvidenciaFindFirstArgs>(args?: SelectSubset<T, EvidenciaFindFirstArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Evidencia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaFindFirstOrThrowArgs} args - Arguments to find a Evidencia
     * @example
     * // Get one Evidencia
     * const evidencia = await prisma.evidencia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvidenciaFindFirstOrThrowArgs>(args?: SelectSubset<T, EvidenciaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Evidencias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evidencias
     * const evidencias = await prisma.evidencia.findMany()
     * 
     * // Get first 10 Evidencias
     * const evidencias = await prisma.evidencia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evidenciaWithIdOnly = await prisma.evidencia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvidenciaFindManyArgs>(args?: SelectSubset<T, EvidenciaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Evidencia.
     * @param {EvidenciaCreateArgs} args - Arguments to create a Evidencia.
     * @example
     * // Create one Evidencia
     * const Evidencia = await prisma.evidencia.create({
     *   data: {
     *     // ... data to create a Evidencia
     *   }
     * })
     * 
     */
    create<T extends EvidenciaCreateArgs>(args: SelectSubset<T, EvidenciaCreateArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Evidencias.
     * @param {EvidenciaCreateManyArgs} args - Arguments to create many Evidencias.
     * @example
     * // Create many Evidencias
     * const evidencia = await prisma.evidencia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvidenciaCreateManyArgs>(args?: SelectSubset<T, EvidenciaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Evidencia.
     * @param {EvidenciaDeleteArgs} args - Arguments to delete one Evidencia.
     * @example
     * // Delete one Evidencia
     * const Evidencia = await prisma.evidencia.delete({
     *   where: {
     *     // ... filter to delete one Evidencia
     *   }
     * })
     * 
     */
    delete<T extends EvidenciaDeleteArgs>(args: SelectSubset<T, EvidenciaDeleteArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Evidencia.
     * @param {EvidenciaUpdateArgs} args - Arguments to update one Evidencia.
     * @example
     * // Update one Evidencia
     * const evidencia = await prisma.evidencia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvidenciaUpdateArgs>(args: SelectSubset<T, EvidenciaUpdateArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Evidencias.
     * @param {EvidenciaDeleteManyArgs} args - Arguments to filter Evidencias to delete.
     * @example
     * // Delete a few Evidencias
     * const { count } = await prisma.evidencia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvidenciaDeleteManyArgs>(args?: SelectSubset<T, EvidenciaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evidencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evidencias
     * const evidencia = await prisma.evidencia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvidenciaUpdateManyArgs>(args: SelectSubset<T, EvidenciaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evidencia.
     * @param {EvidenciaUpsertArgs} args - Arguments to update or create a Evidencia.
     * @example
     * // Update or create a Evidencia
     * const evidencia = await prisma.evidencia.upsert({
     *   create: {
     *     // ... data to create a Evidencia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evidencia we want to update
     *   }
     * })
     */
    upsert<T extends EvidenciaUpsertArgs>(args: SelectSubset<T, EvidenciaUpsertArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Evidencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaCountArgs} args - Arguments to filter Evidencias to count.
     * @example
     * // Count the number of Evidencias
     * const count = await prisma.evidencia.count({
     *   where: {
     *     // ... the filter for the Evidencias we want to count
     *   }
     * })
    **/
    count<T extends EvidenciaCountArgs>(
      args?: Subset<T, EvidenciaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvidenciaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evidencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvidenciaAggregateArgs>(args: Subset<T, EvidenciaAggregateArgs>): Prisma.PrismaPromise<GetEvidenciaAggregateType<T>>

    /**
     * Group by Evidencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvidenciaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvidenciaGroupByArgs['orderBy'] }
        : { orderBy?: EvidenciaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvidenciaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvidenciaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evidencia model
   */
  readonly fields: EvidenciaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evidencia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvidenciaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actividad<T extends ActividadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActividadDefaultArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comentarios<T extends Evidencia$comentariosArgs<ExtArgs> = {}>(args?: Subset<T, Evidencia$comentariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evidencia model
   */ 
  interface EvidenciaFieldRefs {
    readonly id: FieldRef<"Evidencia", 'Int'>
    readonly semana: FieldRef<"Evidencia", 'Int'>
    readonly contenido: FieldRef<"Evidencia", 'String'>
    readonly archivoUrl: FieldRef<"Evidencia", 'String'>
    readonly fechaEntrega: FieldRef<"Evidencia", 'DateTime'>
    readonly estado: FieldRef<"Evidencia", 'EstadoEvidencia'>
    readonly calificacion: FieldRef<"Evidencia", 'Decimal'>
    readonly actividadId: FieldRef<"Evidencia", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Evidencia findUnique
   */
  export type EvidenciaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencia to fetch.
     */
    where: EvidenciaWhereUniqueInput
  }

  /**
   * Evidencia findUniqueOrThrow
   */
  export type EvidenciaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencia to fetch.
     */
    where: EvidenciaWhereUniqueInput
  }

  /**
   * Evidencia findFirst
   */
  export type EvidenciaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencia to fetch.
     */
    where?: EvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidencias to fetch.
     */
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evidencias.
     */
    cursor?: EvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evidencias.
     */
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * Evidencia findFirstOrThrow
   */
  export type EvidenciaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencia to fetch.
     */
    where?: EvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidencias to fetch.
     */
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evidencias.
     */
    cursor?: EvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evidencias.
     */
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * Evidencia findMany
   */
  export type EvidenciaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencias to fetch.
     */
    where?: EvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidencias to fetch.
     */
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evidencias.
     */
    cursor?: EvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidencias.
     */
    skip?: number
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * Evidencia create
   */
  export type EvidenciaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * The data needed to create a Evidencia.
     */
    data: XOR<EvidenciaCreateInput, EvidenciaUncheckedCreateInput>
  }

  /**
   * Evidencia createMany
   */
  export type EvidenciaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evidencias.
     */
    data: EvidenciaCreateManyInput | EvidenciaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evidencia update
   */
  export type EvidenciaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * The data needed to update a Evidencia.
     */
    data: XOR<EvidenciaUpdateInput, EvidenciaUncheckedUpdateInput>
    /**
     * Choose, which Evidencia to update.
     */
    where: EvidenciaWhereUniqueInput
  }

  /**
   * Evidencia updateMany
   */
  export type EvidenciaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evidencias.
     */
    data: XOR<EvidenciaUpdateManyMutationInput, EvidenciaUncheckedUpdateManyInput>
    /**
     * Filter which Evidencias to update
     */
    where?: EvidenciaWhereInput
  }

  /**
   * Evidencia upsert
   */
  export type EvidenciaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * The filter to search for the Evidencia to update in case it exists.
     */
    where: EvidenciaWhereUniqueInput
    /**
     * In case the Evidencia found by the `where` argument doesn't exist, create a new Evidencia with this data.
     */
    create: XOR<EvidenciaCreateInput, EvidenciaUncheckedCreateInput>
    /**
     * In case the Evidencia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvidenciaUpdateInput, EvidenciaUncheckedUpdateInput>
  }

  /**
   * Evidencia delete
   */
  export type EvidenciaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter which Evidencia to delete.
     */
    where: EvidenciaWhereUniqueInput
  }

  /**
   * Evidencia deleteMany
   */
  export type EvidenciaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evidencias to delete
     */
    where?: EvidenciaWhereInput
  }

  /**
   * Evidencia.comentarios
   */
  export type Evidencia$comentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    where?: ComentarioWhereInput
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    cursor?: ComentarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Evidencia without action
   */
  export type EvidenciaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
  }


  /**
   * Model Comentario
   */

  export type AggregateComentario = {
    _count: ComentarioCountAggregateOutputType | null
    _avg: ComentarioAvgAggregateOutputType | null
    _sum: ComentarioSumAggregateOutputType | null
    _min: ComentarioMinAggregateOutputType | null
    _max: ComentarioMaxAggregateOutputType | null
  }

  export type ComentarioAvgAggregateOutputType = {
    id: number | null
    evidenciaId: number | null
    usuarioId: number | null
  }

  export type ComentarioSumAggregateOutputType = {
    id: number | null
    evidenciaId: number | null
    usuarioId: number | null
  }

  export type ComentarioMinAggregateOutputType = {
    id: number | null
    evidenciaId: number | null
    usuarioId: number | null
    descripcion: string | null
  }

  export type ComentarioMaxAggregateOutputType = {
    id: number | null
    evidenciaId: number | null
    usuarioId: number | null
    descripcion: string | null
  }

  export type ComentarioCountAggregateOutputType = {
    id: number
    evidenciaId: number
    usuarioId: number
    descripcion: number
    _all: number
  }


  export type ComentarioAvgAggregateInputType = {
    id?: true
    evidenciaId?: true
    usuarioId?: true
  }

  export type ComentarioSumAggregateInputType = {
    id?: true
    evidenciaId?: true
    usuarioId?: true
  }

  export type ComentarioMinAggregateInputType = {
    id?: true
    evidenciaId?: true
    usuarioId?: true
    descripcion?: true
  }

  export type ComentarioMaxAggregateInputType = {
    id?: true
    evidenciaId?: true
    usuarioId?: true
    descripcion?: true
  }

  export type ComentarioCountAggregateInputType = {
    id?: true
    evidenciaId?: true
    usuarioId?: true
    descripcion?: true
    _all?: true
  }

  export type ComentarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comentario to aggregate.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comentarios
    **/
    _count?: true | ComentarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComentarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComentarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComentarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComentarioMaxAggregateInputType
  }

  export type GetComentarioAggregateType<T extends ComentarioAggregateArgs> = {
        [P in keyof T & keyof AggregateComentario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComentario[P]>
      : GetScalarType<T[P], AggregateComentario[P]>
  }




  export type ComentarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioWhereInput
    orderBy?: ComentarioOrderByWithAggregationInput | ComentarioOrderByWithAggregationInput[]
    by: ComentarioScalarFieldEnum[] | ComentarioScalarFieldEnum
    having?: ComentarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComentarioCountAggregateInputType | true
    _avg?: ComentarioAvgAggregateInputType
    _sum?: ComentarioSumAggregateInputType
    _min?: ComentarioMinAggregateInputType
    _max?: ComentarioMaxAggregateInputType
  }

  export type ComentarioGroupByOutputType = {
    id: number
    evidenciaId: number
    usuarioId: number
    descripcion: string | null
    _count: ComentarioCountAggregateOutputType | null
    _avg: ComentarioAvgAggregateOutputType | null
    _sum: ComentarioSumAggregateOutputType | null
    _min: ComentarioMinAggregateOutputType | null
    _max: ComentarioMaxAggregateOutputType | null
  }

  type GetComentarioGroupByPayload<T extends ComentarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComentarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComentarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComentarioGroupByOutputType[P]>
            : GetScalarType<T[P], ComentarioGroupByOutputType[P]>
        }
      >
    >


  export type ComentarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evidenciaId?: boolean
    usuarioId?: boolean
    descripcion?: boolean
    evidencia?: boolean | EvidenciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentario"]>


  export type ComentarioSelectScalar = {
    id?: boolean
    evidenciaId?: boolean
    usuarioId?: boolean
    descripcion?: boolean
  }

  export type ComentarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidencia?: boolean | EvidenciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $ComentarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comentario"
    objects: {
      evidencia: Prisma.$EvidenciaPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      evidenciaId: number
      usuarioId: number
      descripcion: string | null
    }, ExtArgs["result"]["comentario"]>
    composites: {}
  }

  type ComentarioGetPayload<S extends boolean | null | undefined | ComentarioDefaultArgs> = $Result.GetResult<Prisma.$ComentarioPayload, S>

  type ComentarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComentarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComentarioCountAggregateInputType | true
    }

  export interface ComentarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comentario'], meta: { name: 'Comentario' } }
    /**
     * Find zero or one Comentario that matches the filter.
     * @param {ComentarioFindUniqueArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComentarioFindUniqueArgs>(args: SelectSubset<T, ComentarioFindUniqueArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comentario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComentarioFindUniqueOrThrowArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComentarioFindUniqueOrThrowArgs>(args: SelectSubset<T, ComentarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comentario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioFindFirstArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComentarioFindFirstArgs>(args?: SelectSubset<T, ComentarioFindFirstArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comentario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioFindFirstOrThrowArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComentarioFindFirstOrThrowArgs>(args?: SelectSubset<T, ComentarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comentarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comentarios
     * const comentarios = await prisma.comentario.findMany()
     * 
     * // Get first 10 Comentarios
     * const comentarios = await prisma.comentario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comentarioWithIdOnly = await prisma.comentario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComentarioFindManyArgs>(args?: SelectSubset<T, ComentarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comentario.
     * @param {ComentarioCreateArgs} args - Arguments to create a Comentario.
     * @example
     * // Create one Comentario
     * const Comentario = await prisma.comentario.create({
     *   data: {
     *     // ... data to create a Comentario
     *   }
     * })
     * 
     */
    create<T extends ComentarioCreateArgs>(args: SelectSubset<T, ComentarioCreateArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comentarios.
     * @param {ComentarioCreateManyArgs} args - Arguments to create many Comentarios.
     * @example
     * // Create many Comentarios
     * const comentario = await prisma.comentario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComentarioCreateManyArgs>(args?: SelectSubset<T, ComentarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comentario.
     * @param {ComentarioDeleteArgs} args - Arguments to delete one Comentario.
     * @example
     * // Delete one Comentario
     * const Comentario = await prisma.comentario.delete({
     *   where: {
     *     // ... filter to delete one Comentario
     *   }
     * })
     * 
     */
    delete<T extends ComentarioDeleteArgs>(args: SelectSubset<T, ComentarioDeleteArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comentario.
     * @param {ComentarioUpdateArgs} args - Arguments to update one Comentario.
     * @example
     * // Update one Comentario
     * const comentario = await prisma.comentario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComentarioUpdateArgs>(args: SelectSubset<T, ComentarioUpdateArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comentarios.
     * @param {ComentarioDeleteManyArgs} args - Arguments to filter Comentarios to delete.
     * @example
     * // Delete a few Comentarios
     * const { count } = await prisma.comentario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComentarioDeleteManyArgs>(args?: SelectSubset<T, ComentarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comentarios
     * const comentario = await prisma.comentario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComentarioUpdateManyArgs>(args: SelectSubset<T, ComentarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comentario.
     * @param {ComentarioUpsertArgs} args - Arguments to update or create a Comentario.
     * @example
     * // Update or create a Comentario
     * const comentario = await prisma.comentario.upsert({
     *   create: {
     *     // ... data to create a Comentario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comentario we want to update
     *   }
     * })
     */
    upsert<T extends ComentarioUpsertArgs>(args: SelectSubset<T, ComentarioUpsertArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioCountArgs} args - Arguments to filter Comentarios to count.
     * @example
     * // Count the number of Comentarios
     * const count = await prisma.comentario.count({
     *   where: {
     *     // ... the filter for the Comentarios we want to count
     *   }
     * })
    **/
    count<T extends ComentarioCountArgs>(
      args?: Subset<T, ComentarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComentarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comentario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComentarioAggregateArgs>(args: Subset<T, ComentarioAggregateArgs>): Prisma.PrismaPromise<GetComentarioAggregateType<T>>

    /**
     * Group by Comentario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComentarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComentarioGroupByArgs['orderBy'] }
        : { orderBy?: ComentarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComentarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComentarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comentario model
   */
  readonly fields: ComentarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comentario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComentarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evidencia<T extends EvidenciaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvidenciaDefaultArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comentario model
   */ 
  interface ComentarioFieldRefs {
    readonly id: FieldRef<"Comentario", 'Int'>
    readonly evidenciaId: FieldRef<"Comentario", 'Int'>
    readonly usuarioId: FieldRef<"Comentario", 'Int'>
    readonly descripcion: FieldRef<"Comentario", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Comentario findUnique
   */
  export type ComentarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where: ComentarioWhereUniqueInput
  }

  /**
   * Comentario findUniqueOrThrow
   */
  export type ComentarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where: ComentarioWhereUniqueInput
  }

  /**
   * Comentario findFirst
   */
  export type ComentarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comentarios.
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comentarios.
     */
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Comentario findFirstOrThrow
   */
  export type ComentarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comentarios.
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comentarios.
     */
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Comentario findMany
   */
  export type ComentarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentarios to fetch.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comentarios.
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Comentario create
   */
  export type ComentarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Comentario.
     */
    data: XOR<ComentarioCreateInput, ComentarioUncheckedCreateInput>
  }

  /**
   * Comentario createMany
   */
  export type ComentarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comentarios.
     */
    data: ComentarioCreateManyInput | ComentarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comentario update
   */
  export type ComentarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Comentario.
     */
    data: XOR<ComentarioUpdateInput, ComentarioUncheckedUpdateInput>
    /**
     * Choose, which Comentario to update.
     */
    where: ComentarioWhereUniqueInput
  }

  /**
   * Comentario updateMany
   */
  export type ComentarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comentarios.
     */
    data: XOR<ComentarioUpdateManyMutationInput, ComentarioUncheckedUpdateManyInput>
    /**
     * Filter which Comentarios to update
     */
    where?: ComentarioWhereInput
  }

  /**
   * Comentario upsert
   */
  export type ComentarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Comentario to update in case it exists.
     */
    where: ComentarioWhereUniqueInput
    /**
     * In case the Comentario found by the `where` argument doesn't exist, create a new Comentario with this data.
     */
    create: XOR<ComentarioCreateInput, ComentarioUncheckedCreateInput>
    /**
     * In case the Comentario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComentarioUpdateInput, ComentarioUncheckedUpdateInput>
  }

  /**
   * Comentario delete
   */
  export type ComentarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter which Comentario to delete.
     */
    where: ComentarioWhereUniqueInput
  }

  /**
   * Comentario deleteMany
   */
  export type ComentarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comentarios to delete
     */
    where?: ComentarioWhereInput
  }

  /**
   * Comentario without action
   */
  export type ComentarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
  }


  /**
   * Model CatalogoPrerequisito
   */

  export type AggregateCatalogoPrerequisito = {
    _count: CatalogoPrerequisitoCountAggregateOutputType | null
    _avg: CatalogoPrerequisitoAvgAggregateOutputType | null
    _sum: CatalogoPrerequisitoSumAggregateOutputType | null
    _min: CatalogoPrerequisitoMinAggregateOutputType | null
    _max: CatalogoPrerequisitoMaxAggregateOutputType | null
  }

  export type CatalogoPrerequisitoAvgAggregateOutputType = {
    id: number | null
    orden: number | null
  }

  export type CatalogoPrerequisitoSumAggregateOutputType = {
    id: number | null
    orden: number | null
  }

  export type CatalogoPrerequisitoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    orden: number | null
    activo: boolean | null
  }

  export type CatalogoPrerequisitoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    orden: number | null
    activo: boolean | null
  }

  export type CatalogoPrerequisitoCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    orden: number
    activo: number
    _all: number
  }


  export type CatalogoPrerequisitoAvgAggregateInputType = {
    id?: true
    orden?: true
  }

  export type CatalogoPrerequisitoSumAggregateInputType = {
    id?: true
    orden?: true
  }

  export type CatalogoPrerequisitoMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    orden?: true
    activo?: true
  }

  export type CatalogoPrerequisitoMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    orden?: true
    activo?: true
  }

  export type CatalogoPrerequisitoCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    orden?: true
    activo?: true
    _all?: true
  }

  export type CatalogoPrerequisitoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogoPrerequisito to aggregate.
     */
    where?: CatalogoPrerequisitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogoPrerequisitos to fetch.
     */
    orderBy?: CatalogoPrerequisitoOrderByWithRelationInput | CatalogoPrerequisitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogoPrerequisitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogoPrerequisitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogoPrerequisitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogoPrerequisitos
    **/
    _count?: true | CatalogoPrerequisitoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogoPrerequisitoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogoPrerequisitoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogoPrerequisitoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogoPrerequisitoMaxAggregateInputType
  }

  export type GetCatalogoPrerequisitoAggregateType<T extends CatalogoPrerequisitoAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogoPrerequisito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogoPrerequisito[P]>
      : GetScalarType<T[P], AggregateCatalogoPrerequisito[P]>
  }




  export type CatalogoPrerequisitoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogoPrerequisitoWhereInput
    orderBy?: CatalogoPrerequisitoOrderByWithAggregationInput | CatalogoPrerequisitoOrderByWithAggregationInput[]
    by: CatalogoPrerequisitoScalarFieldEnum[] | CatalogoPrerequisitoScalarFieldEnum
    having?: CatalogoPrerequisitoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogoPrerequisitoCountAggregateInputType | true
    _avg?: CatalogoPrerequisitoAvgAggregateInputType
    _sum?: CatalogoPrerequisitoSumAggregateInputType
    _min?: CatalogoPrerequisitoMinAggregateInputType
    _max?: CatalogoPrerequisitoMaxAggregateInputType
  }

  export type CatalogoPrerequisitoGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string | null
    orden: number
    activo: boolean
    _count: CatalogoPrerequisitoCountAggregateOutputType | null
    _avg: CatalogoPrerequisitoAvgAggregateOutputType | null
    _sum: CatalogoPrerequisitoSumAggregateOutputType | null
    _min: CatalogoPrerequisitoMinAggregateOutputType | null
    _max: CatalogoPrerequisitoMaxAggregateOutputType | null
  }

  type GetCatalogoPrerequisitoGroupByPayload<T extends CatalogoPrerequisitoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogoPrerequisitoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogoPrerequisitoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogoPrerequisitoGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogoPrerequisitoGroupByOutputType[P]>
        }
      >
    >


  export type CatalogoPrerequisitoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    orden?: boolean
    activo?: boolean
    estudiantePrerequisitos?: boolean | CatalogoPrerequisito$estudiantePrerequisitosArgs<ExtArgs>
    _count?: boolean | CatalogoPrerequisitoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogoPrerequisito"]>


  export type CatalogoPrerequisitoSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    orden?: boolean
    activo?: boolean
  }

  export type CatalogoPrerequisitoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiantePrerequisitos?: boolean | CatalogoPrerequisito$estudiantePrerequisitosArgs<ExtArgs>
    _count?: boolean | CatalogoPrerequisitoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CatalogoPrerequisitoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogoPrerequisito"
    objects: {
      estudiantePrerequisitos: Prisma.$EstudiantePrerequisitoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string | null
      orden: number
      activo: boolean
    }, ExtArgs["result"]["catalogoPrerequisito"]>
    composites: {}
  }

  type CatalogoPrerequisitoGetPayload<S extends boolean | null | undefined | CatalogoPrerequisitoDefaultArgs> = $Result.GetResult<Prisma.$CatalogoPrerequisitoPayload, S>

  type CatalogoPrerequisitoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogoPrerequisitoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogoPrerequisitoCountAggregateInputType | true
    }

  export interface CatalogoPrerequisitoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogoPrerequisito'], meta: { name: 'CatalogoPrerequisito' } }
    /**
     * Find zero or one CatalogoPrerequisito that matches the filter.
     * @param {CatalogoPrerequisitoFindUniqueArgs} args - Arguments to find a CatalogoPrerequisito
     * @example
     * // Get one CatalogoPrerequisito
     * const catalogoPrerequisito = await prisma.catalogoPrerequisito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatalogoPrerequisitoFindUniqueArgs>(args: SelectSubset<T, CatalogoPrerequisitoFindUniqueArgs<ExtArgs>>): Prisma__CatalogoPrerequisitoClient<$Result.GetResult<Prisma.$CatalogoPrerequisitoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CatalogoPrerequisito that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogoPrerequisitoFindUniqueOrThrowArgs} args - Arguments to find a CatalogoPrerequisito
     * @example
     * // Get one CatalogoPrerequisito
     * const catalogoPrerequisito = await prisma.catalogoPrerequisito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatalogoPrerequisitoFindUniqueOrThrowArgs>(args: SelectSubset<T, CatalogoPrerequisitoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatalogoPrerequisitoClient<$Result.GetResult<Prisma.$CatalogoPrerequisitoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CatalogoPrerequisito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoPrerequisitoFindFirstArgs} args - Arguments to find a CatalogoPrerequisito
     * @example
     * // Get one CatalogoPrerequisito
     * const catalogoPrerequisito = await prisma.catalogoPrerequisito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatalogoPrerequisitoFindFirstArgs>(args?: SelectSubset<T, CatalogoPrerequisitoFindFirstArgs<ExtArgs>>): Prisma__CatalogoPrerequisitoClient<$Result.GetResult<Prisma.$CatalogoPrerequisitoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CatalogoPrerequisito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoPrerequisitoFindFirstOrThrowArgs} args - Arguments to find a CatalogoPrerequisito
     * @example
     * // Get one CatalogoPrerequisito
     * const catalogoPrerequisito = await prisma.catalogoPrerequisito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatalogoPrerequisitoFindFirstOrThrowArgs>(args?: SelectSubset<T, CatalogoPrerequisitoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatalogoPrerequisitoClient<$Result.GetResult<Prisma.$CatalogoPrerequisitoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CatalogoPrerequisitos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoPrerequisitoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogoPrerequisitos
     * const catalogoPrerequisitos = await prisma.catalogoPrerequisito.findMany()
     * 
     * // Get first 10 CatalogoPrerequisitos
     * const catalogoPrerequisitos = await prisma.catalogoPrerequisito.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogoPrerequisitoWithIdOnly = await prisma.catalogoPrerequisito.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatalogoPrerequisitoFindManyArgs>(args?: SelectSubset<T, CatalogoPrerequisitoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogoPrerequisitoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CatalogoPrerequisito.
     * @param {CatalogoPrerequisitoCreateArgs} args - Arguments to create a CatalogoPrerequisito.
     * @example
     * // Create one CatalogoPrerequisito
     * const CatalogoPrerequisito = await prisma.catalogoPrerequisito.create({
     *   data: {
     *     // ... data to create a CatalogoPrerequisito
     *   }
     * })
     * 
     */
    create<T extends CatalogoPrerequisitoCreateArgs>(args: SelectSubset<T, CatalogoPrerequisitoCreateArgs<ExtArgs>>): Prisma__CatalogoPrerequisitoClient<$Result.GetResult<Prisma.$CatalogoPrerequisitoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CatalogoPrerequisitos.
     * @param {CatalogoPrerequisitoCreateManyArgs} args - Arguments to create many CatalogoPrerequisitos.
     * @example
     * // Create many CatalogoPrerequisitos
     * const catalogoPrerequisito = await prisma.catalogoPrerequisito.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatalogoPrerequisitoCreateManyArgs>(args?: SelectSubset<T, CatalogoPrerequisitoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CatalogoPrerequisito.
     * @param {CatalogoPrerequisitoDeleteArgs} args - Arguments to delete one CatalogoPrerequisito.
     * @example
     * // Delete one CatalogoPrerequisito
     * const CatalogoPrerequisito = await prisma.catalogoPrerequisito.delete({
     *   where: {
     *     // ... filter to delete one CatalogoPrerequisito
     *   }
     * })
     * 
     */
    delete<T extends CatalogoPrerequisitoDeleteArgs>(args: SelectSubset<T, CatalogoPrerequisitoDeleteArgs<ExtArgs>>): Prisma__CatalogoPrerequisitoClient<$Result.GetResult<Prisma.$CatalogoPrerequisitoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CatalogoPrerequisito.
     * @param {CatalogoPrerequisitoUpdateArgs} args - Arguments to update one CatalogoPrerequisito.
     * @example
     * // Update one CatalogoPrerequisito
     * const catalogoPrerequisito = await prisma.catalogoPrerequisito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatalogoPrerequisitoUpdateArgs>(args: SelectSubset<T, CatalogoPrerequisitoUpdateArgs<ExtArgs>>): Prisma__CatalogoPrerequisitoClient<$Result.GetResult<Prisma.$CatalogoPrerequisitoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CatalogoPrerequisitos.
     * @param {CatalogoPrerequisitoDeleteManyArgs} args - Arguments to filter CatalogoPrerequisitos to delete.
     * @example
     * // Delete a few CatalogoPrerequisitos
     * const { count } = await prisma.catalogoPrerequisito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatalogoPrerequisitoDeleteManyArgs>(args?: SelectSubset<T, CatalogoPrerequisitoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogoPrerequisitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoPrerequisitoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogoPrerequisitos
     * const catalogoPrerequisito = await prisma.catalogoPrerequisito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatalogoPrerequisitoUpdateManyArgs>(args: SelectSubset<T, CatalogoPrerequisitoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogoPrerequisito.
     * @param {CatalogoPrerequisitoUpsertArgs} args - Arguments to update or create a CatalogoPrerequisito.
     * @example
     * // Update or create a CatalogoPrerequisito
     * const catalogoPrerequisito = await prisma.catalogoPrerequisito.upsert({
     *   create: {
     *     // ... data to create a CatalogoPrerequisito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogoPrerequisito we want to update
     *   }
     * })
     */
    upsert<T extends CatalogoPrerequisitoUpsertArgs>(args: SelectSubset<T, CatalogoPrerequisitoUpsertArgs<ExtArgs>>): Prisma__CatalogoPrerequisitoClient<$Result.GetResult<Prisma.$CatalogoPrerequisitoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CatalogoPrerequisitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoPrerequisitoCountArgs} args - Arguments to filter CatalogoPrerequisitos to count.
     * @example
     * // Count the number of CatalogoPrerequisitos
     * const count = await prisma.catalogoPrerequisito.count({
     *   where: {
     *     // ... the filter for the CatalogoPrerequisitos we want to count
     *   }
     * })
    **/
    count<T extends CatalogoPrerequisitoCountArgs>(
      args?: Subset<T, CatalogoPrerequisitoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogoPrerequisitoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogoPrerequisito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoPrerequisitoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogoPrerequisitoAggregateArgs>(args: Subset<T, CatalogoPrerequisitoAggregateArgs>): Prisma.PrismaPromise<GetCatalogoPrerequisitoAggregateType<T>>

    /**
     * Group by CatalogoPrerequisito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoPrerequisitoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogoPrerequisitoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogoPrerequisitoGroupByArgs['orderBy'] }
        : { orderBy?: CatalogoPrerequisitoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogoPrerequisitoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogoPrerequisitoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogoPrerequisito model
   */
  readonly fields: CatalogoPrerequisitoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogoPrerequisito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogoPrerequisitoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudiantePrerequisitos<T extends CatalogoPrerequisito$estudiantePrerequisitosArgs<ExtArgs> = {}>(args?: Subset<T, CatalogoPrerequisito$estudiantePrerequisitosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudiantePrerequisitoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatalogoPrerequisito model
   */ 
  interface CatalogoPrerequisitoFieldRefs {
    readonly id: FieldRef<"CatalogoPrerequisito", 'Int'>
    readonly nombre: FieldRef<"CatalogoPrerequisito", 'String'>
    readonly descripcion: FieldRef<"CatalogoPrerequisito", 'String'>
    readonly orden: FieldRef<"CatalogoPrerequisito", 'Int'>
    readonly activo: FieldRef<"CatalogoPrerequisito", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * CatalogoPrerequisito findUnique
   */
  export type CatalogoPrerequisitoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoPrerequisito
     */
    select?: CatalogoPrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoPrerequisitoInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoPrerequisito to fetch.
     */
    where: CatalogoPrerequisitoWhereUniqueInput
  }

  /**
   * CatalogoPrerequisito findUniqueOrThrow
   */
  export type CatalogoPrerequisitoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoPrerequisito
     */
    select?: CatalogoPrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoPrerequisitoInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoPrerequisito to fetch.
     */
    where: CatalogoPrerequisitoWhereUniqueInput
  }

  /**
   * CatalogoPrerequisito findFirst
   */
  export type CatalogoPrerequisitoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoPrerequisito
     */
    select?: CatalogoPrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoPrerequisitoInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoPrerequisito to fetch.
     */
    where?: CatalogoPrerequisitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogoPrerequisitos to fetch.
     */
    orderBy?: CatalogoPrerequisitoOrderByWithRelationInput | CatalogoPrerequisitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogoPrerequisitos.
     */
    cursor?: CatalogoPrerequisitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogoPrerequisitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogoPrerequisitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogoPrerequisitos.
     */
    distinct?: CatalogoPrerequisitoScalarFieldEnum | CatalogoPrerequisitoScalarFieldEnum[]
  }

  /**
   * CatalogoPrerequisito findFirstOrThrow
   */
  export type CatalogoPrerequisitoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoPrerequisito
     */
    select?: CatalogoPrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoPrerequisitoInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoPrerequisito to fetch.
     */
    where?: CatalogoPrerequisitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogoPrerequisitos to fetch.
     */
    orderBy?: CatalogoPrerequisitoOrderByWithRelationInput | CatalogoPrerequisitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogoPrerequisitos.
     */
    cursor?: CatalogoPrerequisitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogoPrerequisitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogoPrerequisitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogoPrerequisitos.
     */
    distinct?: CatalogoPrerequisitoScalarFieldEnum | CatalogoPrerequisitoScalarFieldEnum[]
  }

  /**
   * CatalogoPrerequisito findMany
   */
  export type CatalogoPrerequisitoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoPrerequisito
     */
    select?: CatalogoPrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoPrerequisitoInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoPrerequisitos to fetch.
     */
    where?: CatalogoPrerequisitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogoPrerequisitos to fetch.
     */
    orderBy?: CatalogoPrerequisitoOrderByWithRelationInput | CatalogoPrerequisitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogoPrerequisitos.
     */
    cursor?: CatalogoPrerequisitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogoPrerequisitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogoPrerequisitos.
     */
    skip?: number
    distinct?: CatalogoPrerequisitoScalarFieldEnum | CatalogoPrerequisitoScalarFieldEnum[]
  }

  /**
   * CatalogoPrerequisito create
   */
  export type CatalogoPrerequisitoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoPrerequisito
     */
    select?: CatalogoPrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoPrerequisitoInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogoPrerequisito.
     */
    data: XOR<CatalogoPrerequisitoCreateInput, CatalogoPrerequisitoUncheckedCreateInput>
  }

  /**
   * CatalogoPrerequisito createMany
   */
  export type CatalogoPrerequisitoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogoPrerequisitos.
     */
    data: CatalogoPrerequisitoCreateManyInput | CatalogoPrerequisitoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogoPrerequisito update
   */
  export type CatalogoPrerequisitoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoPrerequisito
     */
    select?: CatalogoPrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoPrerequisitoInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogoPrerequisito.
     */
    data: XOR<CatalogoPrerequisitoUpdateInput, CatalogoPrerequisitoUncheckedUpdateInput>
    /**
     * Choose, which CatalogoPrerequisito to update.
     */
    where: CatalogoPrerequisitoWhereUniqueInput
  }

  /**
   * CatalogoPrerequisito updateMany
   */
  export type CatalogoPrerequisitoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogoPrerequisitos.
     */
    data: XOR<CatalogoPrerequisitoUpdateManyMutationInput, CatalogoPrerequisitoUncheckedUpdateManyInput>
    /**
     * Filter which CatalogoPrerequisitos to update
     */
    where?: CatalogoPrerequisitoWhereInput
  }

  /**
   * CatalogoPrerequisito upsert
   */
  export type CatalogoPrerequisitoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoPrerequisito
     */
    select?: CatalogoPrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoPrerequisitoInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogoPrerequisito to update in case it exists.
     */
    where: CatalogoPrerequisitoWhereUniqueInput
    /**
     * In case the CatalogoPrerequisito found by the `where` argument doesn't exist, create a new CatalogoPrerequisito with this data.
     */
    create: XOR<CatalogoPrerequisitoCreateInput, CatalogoPrerequisitoUncheckedCreateInput>
    /**
     * In case the CatalogoPrerequisito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogoPrerequisitoUpdateInput, CatalogoPrerequisitoUncheckedUpdateInput>
  }

  /**
   * CatalogoPrerequisito delete
   */
  export type CatalogoPrerequisitoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoPrerequisito
     */
    select?: CatalogoPrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoPrerequisitoInclude<ExtArgs> | null
    /**
     * Filter which CatalogoPrerequisito to delete.
     */
    where: CatalogoPrerequisitoWhereUniqueInput
  }

  /**
   * CatalogoPrerequisito deleteMany
   */
  export type CatalogoPrerequisitoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogoPrerequisitos to delete
     */
    where?: CatalogoPrerequisitoWhereInput
  }

  /**
   * CatalogoPrerequisito.estudiantePrerequisitos
   */
  export type CatalogoPrerequisito$estudiantePrerequisitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePrerequisito
     */
    select?: EstudiantePrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePrerequisitoInclude<ExtArgs> | null
    where?: EstudiantePrerequisitoWhereInput
    orderBy?: EstudiantePrerequisitoOrderByWithRelationInput | EstudiantePrerequisitoOrderByWithRelationInput[]
    cursor?: EstudiantePrerequisitoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EstudiantePrerequisitoScalarFieldEnum | EstudiantePrerequisitoScalarFieldEnum[]
  }

  /**
   * CatalogoPrerequisito without action
   */
  export type CatalogoPrerequisitoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoPrerequisito
     */
    select?: CatalogoPrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoPrerequisitoInclude<ExtArgs> | null
  }


  /**
   * Model EstudiantePrerequisito
   */

  export type AggregateEstudiantePrerequisito = {
    _count: EstudiantePrerequisitoCountAggregateOutputType | null
    _avg: EstudiantePrerequisitoAvgAggregateOutputType | null
    _sum: EstudiantePrerequisitoSumAggregateOutputType | null
    _min: EstudiantePrerequisitoMinAggregateOutputType | null
    _max: EstudiantePrerequisitoMaxAggregateOutputType | null
  }

  export type EstudiantePrerequisitoAvgAggregateOutputType = {
    id: number | null
    prerequisitoId: number | null
    fkEstudiante: number | null
  }

  export type EstudiantePrerequisitoSumAggregateOutputType = {
    id: number | null
    prerequisitoId: number | null
    fkEstudiante: number | null
  }

  export type EstudiantePrerequisitoMinAggregateOutputType = {
    id: number | null
    prerequisitoId: number | null
    cumplido: boolean | null
    archivoUrl: string | null
    fechaCumplimiento: Date | null
    fkEstudiante: number | null
  }

  export type EstudiantePrerequisitoMaxAggregateOutputType = {
    id: number | null
    prerequisitoId: number | null
    cumplido: boolean | null
    archivoUrl: string | null
    fechaCumplimiento: Date | null
    fkEstudiante: number | null
  }

  export type EstudiantePrerequisitoCountAggregateOutputType = {
    id: number
    prerequisitoId: number
    cumplido: number
    archivoUrl: number
    fechaCumplimiento: number
    fkEstudiante: number
    _all: number
  }


  export type EstudiantePrerequisitoAvgAggregateInputType = {
    id?: true
    prerequisitoId?: true
    fkEstudiante?: true
  }

  export type EstudiantePrerequisitoSumAggregateInputType = {
    id?: true
    prerequisitoId?: true
    fkEstudiante?: true
  }

  export type EstudiantePrerequisitoMinAggregateInputType = {
    id?: true
    prerequisitoId?: true
    cumplido?: true
    archivoUrl?: true
    fechaCumplimiento?: true
    fkEstudiante?: true
  }

  export type EstudiantePrerequisitoMaxAggregateInputType = {
    id?: true
    prerequisitoId?: true
    cumplido?: true
    archivoUrl?: true
    fechaCumplimiento?: true
    fkEstudiante?: true
  }

  export type EstudiantePrerequisitoCountAggregateInputType = {
    id?: true
    prerequisitoId?: true
    cumplido?: true
    archivoUrl?: true
    fechaCumplimiento?: true
    fkEstudiante?: true
    _all?: true
  }

  export type EstudiantePrerequisitoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EstudiantePrerequisito to aggregate.
     */
    where?: EstudiantePrerequisitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstudiantePrerequisitos to fetch.
     */
    orderBy?: EstudiantePrerequisitoOrderByWithRelationInput | EstudiantePrerequisitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EstudiantePrerequisitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstudiantePrerequisitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstudiantePrerequisitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EstudiantePrerequisitos
    **/
    _count?: true | EstudiantePrerequisitoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstudiantePrerequisitoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstudiantePrerequisitoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstudiantePrerequisitoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstudiantePrerequisitoMaxAggregateInputType
  }

  export type GetEstudiantePrerequisitoAggregateType<T extends EstudiantePrerequisitoAggregateArgs> = {
        [P in keyof T & keyof AggregateEstudiantePrerequisito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstudiantePrerequisito[P]>
      : GetScalarType<T[P], AggregateEstudiantePrerequisito[P]>
  }




  export type EstudiantePrerequisitoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudiantePrerequisitoWhereInput
    orderBy?: EstudiantePrerequisitoOrderByWithAggregationInput | EstudiantePrerequisitoOrderByWithAggregationInput[]
    by: EstudiantePrerequisitoScalarFieldEnum[] | EstudiantePrerequisitoScalarFieldEnum
    having?: EstudiantePrerequisitoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstudiantePrerequisitoCountAggregateInputType | true
    _avg?: EstudiantePrerequisitoAvgAggregateInputType
    _sum?: EstudiantePrerequisitoSumAggregateInputType
    _min?: EstudiantePrerequisitoMinAggregateInputType
    _max?: EstudiantePrerequisitoMaxAggregateInputType
  }

  export type EstudiantePrerequisitoGroupByOutputType = {
    id: number
    prerequisitoId: number
    cumplido: boolean
    archivoUrl: string | null
    fechaCumplimiento: Date | null
    fkEstudiante: number
    _count: EstudiantePrerequisitoCountAggregateOutputType | null
    _avg: EstudiantePrerequisitoAvgAggregateOutputType | null
    _sum: EstudiantePrerequisitoSumAggregateOutputType | null
    _min: EstudiantePrerequisitoMinAggregateOutputType | null
    _max: EstudiantePrerequisitoMaxAggregateOutputType | null
  }

  type GetEstudiantePrerequisitoGroupByPayload<T extends EstudiantePrerequisitoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstudiantePrerequisitoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstudiantePrerequisitoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstudiantePrerequisitoGroupByOutputType[P]>
            : GetScalarType<T[P], EstudiantePrerequisitoGroupByOutputType[P]>
        }
      >
    >


  export type EstudiantePrerequisitoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prerequisitoId?: boolean
    cumplido?: boolean
    archivoUrl?: boolean
    fechaCumplimiento?: boolean
    fkEstudiante?: boolean
    prerequisito?: boolean | CatalogoPrerequisitoDefaultArgs<ExtArgs>
    estudiante?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estudiantePrerequisito"]>


  export type EstudiantePrerequisitoSelectScalar = {
    id?: boolean
    prerequisitoId?: boolean
    cumplido?: boolean
    archivoUrl?: boolean
    fechaCumplimiento?: boolean
    fkEstudiante?: boolean
  }

  export type EstudiantePrerequisitoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prerequisito?: boolean | CatalogoPrerequisitoDefaultArgs<ExtArgs>
    estudiante?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $EstudiantePrerequisitoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EstudiantePrerequisito"
    objects: {
      prerequisito: Prisma.$CatalogoPrerequisitoPayload<ExtArgs>
      estudiante: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      prerequisitoId: number
      cumplido: boolean
      archivoUrl: string | null
      fechaCumplimiento: Date | null
      fkEstudiante: number
    }, ExtArgs["result"]["estudiantePrerequisito"]>
    composites: {}
  }

  type EstudiantePrerequisitoGetPayload<S extends boolean | null | undefined | EstudiantePrerequisitoDefaultArgs> = $Result.GetResult<Prisma.$EstudiantePrerequisitoPayload, S>

  type EstudiantePrerequisitoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EstudiantePrerequisitoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EstudiantePrerequisitoCountAggregateInputType | true
    }

  export interface EstudiantePrerequisitoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EstudiantePrerequisito'], meta: { name: 'EstudiantePrerequisito' } }
    /**
     * Find zero or one EstudiantePrerequisito that matches the filter.
     * @param {EstudiantePrerequisitoFindUniqueArgs} args - Arguments to find a EstudiantePrerequisito
     * @example
     * // Get one EstudiantePrerequisito
     * const estudiantePrerequisito = await prisma.estudiantePrerequisito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EstudiantePrerequisitoFindUniqueArgs>(args: SelectSubset<T, EstudiantePrerequisitoFindUniqueArgs<ExtArgs>>): Prisma__EstudiantePrerequisitoClient<$Result.GetResult<Prisma.$EstudiantePrerequisitoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EstudiantePrerequisito that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EstudiantePrerequisitoFindUniqueOrThrowArgs} args - Arguments to find a EstudiantePrerequisito
     * @example
     * // Get one EstudiantePrerequisito
     * const estudiantePrerequisito = await prisma.estudiantePrerequisito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EstudiantePrerequisitoFindUniqueOrThrowArgs>(args: SelectSubset<T, EstudiantePrerequisitoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EstudiantePrerequisitoClient<$Result.GetResult<Prisma.$EstudiantePrerequisitoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EstudiantePrerequisito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantePrerequisitoFindFirstArgs} args - Arguments to find a EstudiantePrerequisito
     * @example
     * // Get one EstudiantePrerequisito
     * const estudiantePrerequisito = await prisma.estudiantePrerequisito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EstudiantePrerequisitoFindFirstArgs>(args?: SelectSubset<T, EstudiantePrerequisitoFindFirstArgs<ExtArgs>>): Prisma__EstudiantePrerequisitoClient<$Result.GetResult<Prisma.$EstudiantePrerequisitoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EstudiantePrerequisito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantePrerequisitoFindFirstOrThrowArgs} args - Arguments to find a EstudiantePrerequisito
     * @example
     * // Get one EstudiantePrerequisito
     * const estudiantePrerequisito = await prisma.estudiantePrerequisito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EstudiantePrerequisitoFindFirstOrThrowArgs>(args?: SelectSubset<T, EstudiantePrerequisitoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EstudiantePrerequisitoClient<$Result.GetResult<Prisma.$EstudiantePrerequisitoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EstudiantePrerequisitos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantePrerequisitoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EstudiantePrerequisitos
     * const estudiantePrerequisitos = await prisma.estudiantePrerequisito.findMany()
     * 
     * // Get first 10 EstudiantePrerequisitos
     * const estudiantePrerequisitos = await prisma.estudiantePrerequisito.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estudiantePrerequisitoWithIdOnly = await prisma.estudiantePrerequisito.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EstudiantePrerequisitoFindManyArgs>(args?: SelectSubset<T, EstudiantePrerequisitoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudiantePrerequisitoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EstudiantePrerequisito.
     * @param {EstudiantePrerequisitoCreateArgs} args - Arguments to create a EstudiantePrerequisito.
     * @example
     * // Create one EstudiantePrerequisito
     * const EstudiantePrerequisito = await prisma.estudiantePrerequisito.create({
     *   data: {
     *     // ... data to create a EstudiantePrerequisito
     *   }
     * })
     * 
     */
    create<T extends EstudiantePrerequisitoCreateArgs>(args: SelectSubset<T, EstudiantePrerequisitoCreateArgs<ExtArgs>>): Prisma__EstudiantePrerequisitoClient<$Result.GetResult<Prisma.$EstudiantePrerequisitoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EstudiantePrerequisitos.
     * @param {EstudiantePrerequisitoCreateManyArgs} args - Arguments to create many EstudiantePrerequisitos.
     * @example
     * // Create many EstudiantePrerequisitos
     * const estudiantePrerequisito = await prisma.estudiantePrerequisito.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EstudiantePrerequisitoCreateManyArgs>(args?: SelectSubset<T, EstudiantePrerequisitoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EstudiantePrerequisito.
     * @param {EstudiantePrerequisitoDeleteArgs} args - Arguments to delete one EstudiantePrerequisito.
     * @example
     * // Delete one EstudiantePrerequisito
     * const EstudiantePrerequisito = await prisma.estudiantePrerequisito.delete({
     *   where: {
     *     // ... filter to delete one EstudiantePrerequisito
     *   }
     * })
     * 
     */
    delete<T extends EstudiantePrerequisitoDeleteArgs>(args: SelectSubset<T, EstudiantePrerequisitoDeleteArgs<ExtArgs>>): Prisma__EstudiantePrerequisitoClient<$Result.GetResult<Prisma.$EstudiantePrerequisitoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EstudiantePrerequisito.
     * @param {EstudiantePrerequisitoUpdateArgs} args - Arguments to update one EstudiantePrerequisito.
     * @example
     * // Update one EstudiantePrerequisito
     * const estudiantePrerequisito = await prisma.estudiantePrerequisito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EstudiantePrerequisitoUpdateArgs>(args: SelectSubset<T, EstudiantePrerequisitoUpdateArgs<ExtArgs>>): Prisma__EstudiantePrerequisitoClient<$Result.GetResult<Prisma.$EstudiantePrerequisitoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EstudiantePrerequisitos.
     * @param {EstudiantePrerequisitoDeleteManyArgs} args - Arguments to filter EstudiantePrerequisitos to delete.
     * @example
     * // Delete a few EstudiantePrerequisitos
     * const { count } = await prisma.estudiantePrerequisito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EstudiantePrerequisitoDeleteManyArgs>(args?: SelectSubset<T, EstudiantePrerequisitoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EstudiantePrerequisitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantePrerequisitoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EstudiantePrerequisitos
     * const estudiantePrerequisito = await prisma.estudiantePrerequisito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EstudiantePrerequisitoUpdateManyArgs>(args: SelectSubset<T, EstudiantePrerequisitoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EstudiantePrerequisito.
     * @param {EstudiantePrerequisitoUpsertArgs} args - Arguments to update or create a EstudiantePrerequisito.
     * @example
     * // Update or create a EstudiantePrerequisito
     * const estudiantePrerequisito = await prisma.estudiantePrerequisito.upsert({
     *   create: {
     *     // ... data to create a EstudiantePrerequisito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EstudiantePrerequisito we want to update
     *   }
     * })
     */
    upsert<T extends EstudiantePrerequisitoUpsertArgs>(args: SelectSubset<T, EstudiantePrerequisitoUpsertArgs<ExtArgs>>): Prisma__EstudiantePrerequisitoClient<$Result.GetResult<Prisma.$EstudiantePrerequisitoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EstudiantePrerequisitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantePrerequisitoCountArgs} args - Arguments to filter EstudiantePrerequisitos to count.
     * @example
     * // Count the number of EstudiantePrerequisitos
     * const count = await prisma.estudiantePrerequisito.count({
     *   where: {
     *     // ... the filter for the EstudiantePrerequisitos we want to count
     *   }
     * })
    **/
    count<T extends EstudiantePrerequisitoCountArgs>(
      args?: Subset<T, EstudiantePrerequisitoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstudiantePrerequisitoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EstudiantePrerequisito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantePrerequisitoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstudiantePrerequisitoAggregateArgs>(args: Subset<T, EstudiantePrerequisitoAggregateArgs>): Prisma.PrismaPromise<GetEstudiantePrerequisitoAggregateType<T>>

    /**
     * Group by EstudiantePrerequisito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantePrerequisitoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstudiantePrerequisitoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstudiantePrerequisitoGroupByArgs['orderBy'] }
        : { orderBy?: EstudiantePrerequisitoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstudiantePrerequisitoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstudiantePrerequisitoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EstudiantePrerequisito model
   */
  readonly fields: EstudiantePrerequisitoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EstudiantePrerequisito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EstudiantePrerequisitoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prerequisito<T extends CatalogoPrerequisitoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatalogoPrerequisitoDefaultArgs<ExtArgs>>): Prisma__CatalogoPrerequisitoClient<$Result.GetResult<Prisma.$CatalogoPrerequisitoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    estudiante<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EstudiantePrerequisito model
   */ 
  interface EstudiantePrerequisitoFieldRefs {
    readonly id: FieldRef<"EstudiantePrerequisito", 'Int'>
    readonly prerequisitoId: FieldRef<"EstudiantePrerequisito", 'Int'>
    readonly cumplido: FieldRef<"EstudiantePrerequisito", 'Boolean'>
    readonly archivoUrl: FieldRef<"EstudiantePrerequisito", 'String'>
    readonly fechaCumplimiento: FieldRef<"EstudiantePrerequisito", 'DateTime'>
    readonly fkEstudiante: FieldRef<"EstudiantePrerequisito", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EstudiantePrerequisito findUnique
   */
  export type EstudiantePrerequisitoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePrerequisito
     */
    select?: EstudiantePrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePrerequisitoInclude<ExtArgs> | null
    /**
     * Filter, which EstudiantePrerequisito to fetch.
     */
    where: EstudiantePrerequisitoWhereUniqueInput
  }

  /**
   * EstudiantePrerequisito findUniqueOrThrow
   */
  export type EstudiantePrerequisitoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePrerequisito
     */
    select?: EstudiantePrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePrerequisitoInclude<ExtArgs> | null
    /**
     * Filter, which EstudiantePrerequisito to fetch.
     */
    where: EstudiantePrerequisitoWhereUniqueInput
  }

  /**
   * EstudiantePrerequisito findFirst
   */
  export type EstudiantePrerequisitoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePrerequisito
     */
    select?: EstudiantePrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePrerequisitoInclude<ExtArgs> | null
    /**
     * Filter, which EstudiantePrerequisito to fetch.
     */
    where?: EstudiantePrerequisitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstudiantePrerequisitos to fetch.
     */
    orderBy?: EstudiantePrerequisitoOrderByWithRelationInput | EstudiantePrerequisitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EstudiantePrerequisitos.
     */
    cursor?: EstudiantePrerequisitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstudiantePrerequisitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstudiantePrerequisitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EstudiantePrerequisitos.
     */
    distinct?: EstudiantePrerequisitoScalarFieldEnum | EstudiantePrerequisitoScalarFieldEnum[]
  }

  /**
   * EstudiantePrerequisito findFirstOrThrow
   */
  export type EstudiantePrerequisitoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePrerequisito
     */
    select?: EstudiantePrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePrerequisitoInclude<ExtArgs> | null
    /**
     * Filter, which EstudiantePrerequisito to fetch.
     */
    where?: EstudiantePrerequisitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstudiantePrerequisitos to fetch.
     */
    orderBy?: EstudiantePrerequisitoOrderByWithRelationInput | EstudiantePrerequisitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EstudiantePrerequisitos.
     */
    cursor?: EstudiantePrerequisitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstudiantePrerequisitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstudiantePrerequisitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EstudiantePrerequisitos.
     */
    distinct?: EstudiantePrerequisitoScalarFieldEnum | EstudiantePrerequisitoScalarFieldEnum[]
  }

  /**
   * EstudiantePrerequisito findMany
   */
  export type EstudiantePrerequisitoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePrerequisito
     */
    select?: EstudiantePrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePrerequisitoInclude<ExtArgs> | null
    /**
     * Filter, which EstudiantePrerequisitos to fetch.
     */
    where?: EstudiantePrerequisitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstudiantePrerequisitos to fetch.
     */
    orderBy?: EstudiantePrerequisitoOrderByWithRelationInput | EstudiantePrerequisitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EstudiantePrerequisitos.
     */
    cursor?: EstudiantePrerequisitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstudiantePrerequisitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstudiantePrerequisitos.
     */
    skip?: number
    distinct?: EstudiantePrerequisitoScalarFieldEnum | EstudiantePrerequisitoScalarFieldEnum[]
  }

  /**
   * EstudiantePrerequisito create
   */
  export type EstudiantePrerequisitoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePrerequisito
     */
    select?: EstudiantePrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePrerequisitoInclude<ExtArgs> | null
    /**
     * The data needed to create a EstudiantePrerequisito.
     */
    data: XOR<EstudiantePrerequisitoCreateInput, EstudiantePrerequisitoUncheckedCreateInput>
  }

  /**
   * EstudiantePrerequisito createMany
   */
  export type EstudiantePrerequisitoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EstudiantePrerequisitos.
     */
    data: EstudiantePrerequisitoCreateManyInput | EstudiantePrerequisitoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EstudiantePrerequisito update
   */
  export type EstudiantePrerequisitoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePrerequisito
     */
    select?: EstudiantePrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePrerequisitoInclude<ExtArgs> | null
    /**
     * The data needed to update a EstudiantePrerequisito.
     */
    data: XOR<EstudiantePrerequisitoUpdateInput, EstudiantePrerequisitoUncheckedUpdateInput>
    /**
     * Choose, which EstudiantePrerequisito to update.
     */
    where: EstudiantePrerequisitoWhereUniqueInput
  }

  /**
   * EstudiantePrerequisito updateMany
   */
  export type EstudiantePrerequisitoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EstudiantePrerequisitos.
     */
    data: XOR<EstudiantePrerequisitoUpdateManyMutationInput, EstudiantePrerequisitoUncheckedUpdateManyInput>
    /**
     * Filter which EstudiantePrerequisitos to update
     */
    where?: EstudiantePrerequisitoWhereInput
  }

  /**
   * EstudiantePrerequisito upsert
   */
  export type EstudiantePrerequisitoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePrerequisito
     */
    select?: EstudiantePrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePrerequisitoInclude<ExtArgs> | null
    /**
     * The filter to search for the EstudiantePrerequisito to update in case it exists.
     */
    where: EstudiantePrerequisitoWhereUniqueInput
    /**
     * In case the EstudiantePrerequisito found by the `where` argument doesn't exist, create a new EstudiantePrerequisito with this data.
     */
    create: XOR<EstudiantePrerequisitoCreateInput, EstudiantePrerequisitoUncheckedCreateInput>
    /**
     * In case the EstudiantePrerequisito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EstudiantePrerequisitoUpdateInput, EstudiantePrerequisitoUncheckedUpdateInput>
  }

  /**
   * EstudiantePrerequisito delete
   */
  export type EstudiantePrerequisitoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePrerequisito
     */
    select?: EstudiantePrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePrerequisitoInclude<ExtArgs> | null
    /**
     * Filter which EstudiantePrerequisito to delete.
     */
    where: EstudiantePrerequisitoWhereUniqueInput
  }

  /**
   * EstudiantePrerequisito deleteMany
   */
  export type EstudiantePrerequisitoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EstudiantePrerequisitos to delete
     */
    where?: EstudiantePrerequisitoWhereInput
  }

  /**
   * EstudiantePrerequisito without action
   */
  export type EstudiantePrerequisitoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePrerequisito
     */
    select?: EstudiantePrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePrerequisitoInclude<ExtArgs> | null
  }


  /**
   * Model Notificacion
   */

  export type AggregateNotificacion = {
    _count: NotificacionCountAggregateOutputType | null
    _avg: NotificacionAvgAggregateOutputType | null
    _sum: NotificacionSumAggregateOutputType | null
    _min: NotificacionMinAggregateOutputType | null
    _max: NotificacionMaxAggregateOutputType | null
  }

  export type NotificacionAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type NotificacionSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type NotificacionMinAggregateOutputType = {
    id: number | null
    mensaje: string | null
    leido: boolean | null
    fechaCreacion: Date | null
    usuarioId: number | null
  }

  export type NotificacionMaxAggregateOutputType = {
    id: number | null
    mensaje: string | null
    leido: boolean | null
    fechaCreacion: Date | null
    usuarioId: number | null
  }

  export type NotificacionCountAggregateOutputType = {
    id: number
    mensaje: number
    leido: number
    fechaCreacion: number
    usuarioId: number
    _all: number
  }


  export type NotificacionAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type NotificacionSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type NotificacionMinAggregateInputType = {
    id?: true
    mensaje?: true
    leido?: true
    fechaCreacion?: true
    usuarioId?: true
  }

  export type NotificacionMaxAggregateInputType = {
    id?: true
    mensaje?: true
    leido?: true
    fechaCreacion?: true
    usuarioId?: true
  }

  export type NotificacionCountAggregateInputType = {
    id?: true
    mensaje?: true
    leido?: true
    fechaCreacion?: true
    usuarioId?: true
    _all?: true
  }

  export type NotificacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacion to aggregate.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notificacions
    **/
    _count?: true | NotificacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificacionMaxAggregateInputType
  }

  export type GetNotificacionAggregateType<T extends NotificacionAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificacion[P]>
      : GetScalarType<T[P], AggregateNotificacion[P]>
  }




  export type NotificacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacionWhereInput
    orderBy?: NotificacionOrderByWithAggregationInput | NotificacionOrderByWithAggregationInput[]
    by: NotificacionScalarFieldEnum[] | NotificacionScalarFieldEnum
    having?: NotificacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificacionCountAggregateInputType | true
    _avg?: NotificacionAvgAggregateInputType
    _sum?: NotificacionSumAggregateInputType
    _min?: NotificacionMinAggregateInputType
    _max?: NotificacionMaxAggregateInputType
  }

  export type NotificacionGroupByOutputType = {
    id: number
    mensaje: string
    leido: boolean
    fechaCreacion: Date
    usuarioId: number
    _count: NotificacionCountAggregateOutputType | null
    _avg: NotificacionAvgAggregateOutputType | null
    _sum: NotificacionSumAggregateOutputType | null
    _min: NotificacionMinAggregateOutputType | null
    _max: NotificacionMaxAggregateOutputType | null
  }

  type GetNotificacionGroupByPayload<T extends NotificacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificacionGroupByOutputType[P]>
            : GetScalarType<T[P], NotificacionGroupByOutputType[P]>
        }
      >
    >


  export type NotificacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mensaje?: boolean
    leido?: boolean
    fechaCreacion?: boolean
    usuarioId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificacion"]>


  export type NotificacionSelectScalar = {
    id?: boolean
    mensaje?: boolean
    leido?: boolean
    fechaCreacion?: boolean
    usuarioId?: boolean
  }

  export type NotificacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $NotificacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notificacion"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mensaje: string
      leido: boolean
      fechaCreacion: Date
      usuarioId: number
    }, ExtArgs["result"]["notificacion"]>
    composites: {}
  }

  type NotificacionGetPayload<S extends boolean | null | undefined | NotificacionDefaultArgs> = $Result.GetResult<Prisma.$NotificacionPayload, S>

  type NotificacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificacionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificacionCountAggregateInputType | true
    }

  export interface NotificacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notificacion'], meta: { name: 'Notificacion' } }
    /**
     * Find zero or one Notificacion that matches the filter.
     * @param {NotificacionFindUniqueArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificacionFindUniqueArgs>(args: SelectSubset<T, NotificacionFindUniqueArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notificacion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificacionFindUniqueOrThrowArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificacionFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notificacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindFirstArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificacionFindFirstArgs>(args?: SelectSubset<T, NotificacionFindFirstArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notificacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindFirstOrThrowArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificacionFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notificacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notificacions
     * const notificacions = await prisma.notificacion.findMany()
     * 
     * // Get first 10 Notificacions
     * const notificacions = await prisma.notificacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificacionWithIdOnly = await prisma.notificacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificacionFindManyArgs>(args?: SelectSubset<T, NotificacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notificacion.
     * @param {NotificacionCreateArgs} args - Arguments to create a Notificacion.
     * @example
     * // Create one Notificacion
     * const Notificacion = await prisma.notificacion.create({
     *   data: {
     *     // ... data to create a Notificacion
     *   }
     * })
     * 
     */
    create<T extends NotificacionCreateArgs>(args: SelectSubset<T, NotificacionCreateArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notificacions.
     * @param {NotificacionCreateManyArgs} args - Arguments to create many Notificacions.
     * @example
     * // Create many Notificacions
     * const notificacion = await prisma.notificacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificacionCreateManyArgs>(args?: SelectSubset<T, NotificacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notificacion.
     * @param {NotificacionDeleteArgs} args - Arguments to delete one Notificacion.
     * @example
     * // Delete one Notificacion
     * const Notificacion = await prisma.notificacion.delete({
     *   where: {
     *     // ... filter to delete one Notificacion
     *   }
     * })
     * 
     */
    delete<T extends NotificacionDeleteArgs>(args: SelectSubset<T, NotificacionDeleteArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notificacion.
     * @param {NotificacionUpdateArgs} args - Arguments to update one Notificacion.
     * @example
     * // Update one Notificacion
     * const notificacion = await prisma.notificacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificacionUpdateArgs>(args: SelectSubset<T, NotificacionUpdateArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notificacions.
     * @param {NotificacionDeleteManyArgs} args - Arguments to filter Notificacions to delete.
     * @example
     * // Delete a few Notificacions
     * const { count } = await prisma.notificacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificacionDeleteManyArgs>(args?: SelectSubset<T, NotificacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notificacions
     * const notificacion = await prisma.notificacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificacionUpdateManyArgs>(args: SelectSubset<T, NotificacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notificacion.
     * @param {NotificacionUpsertArgs} args - Arguments to update or create a Notificacion.
     * @example
     * // Update or create a Notificacion
     * const notificacion = await prisma.notificacion.upsert({
     *   create: {
     *     // ... data to create a Notificacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notificacion we want to update
     *   }
     * })
     */
    upsert<T extends NotificacionUpsertArgs>(args: SelectSubset<T, NotificacionUpsertArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionCountArgs} args - Arguments to filter Notificacions to count.
     * @example
     * // Count the number of Notificacions
     * const count = await prisma.notificacion.count({
     *   where: {
     *     // ... the filter for the Notificacions we want to count
     *   }
     * })
    **/
    count<T extends NotificacionCountArgs>(
      args?: Subset<T, NotificacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificacionAggregateArgs>(args: Subset<T, NotificacionAggregateArgs>): Prisma.PrismaPromise<GetNotificacionAggregateType<T>>

    /**
     * Group by Notificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificacionGroupByArgs['orderBy'] }
        : { orderBy?: NotificacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notificacion model
   */
  readonly fields: NotificacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notificacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notificacion model
   */ 
  interface NotificacionFieldRefs {
    readonly id: FieldRef<"Notificacion", 'Int'>
    readonly mensaje: FieldRef<"Notificacion", 'String'>
    readonly leido: FieldRef<"Notificacion", 'Boolean'>
    readonly fechaCreacion: FieldRef<"Notificacion", 'DateTime'>
    readonly usuarioId: FieldRef<"Notificacion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Notificacion findUnique
   */
  export type NotificacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion findUniqueOrThrow
   */
  export type NotificacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion findFirst
   */
  export type NotificacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacions.
     */
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion findFirstOrThrow
   */
  export type NotificacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacions.
     */
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion findMany
   */
  export type NotificacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacions to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion create
   */
  export type NotificacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Notificacion.
     */
    data: XOR<NotificacionCreateInput, NotificacionUncheckedCreateInput>
  }

  /**
   * Notificacion createMany
   */
  export type NotificacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notificacions.
     */
    data: NotificacionCreateManyInput | NotificacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notificacion update
   */
  export type NotificacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Notificacion.
     */
    data: XOR<NotificacionUpdateInput, NotificacionUncheckedUpdateInput>
    /**
     * Choose, which Notificacion to update.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion updateMany
   */
  export type NotificacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notificacions.
     */
    data: XOR<NotificacionUpdateManyMutationInput, NotificacionUncheckedUpdateManyInput>
    /**
     * Filter which Notificacions to update
     */
    where?: NotificacionWhereInput
  }

  /**
   * Notificacion upsert
   */
  export type NotificacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Notificacion to update in case it exists.
     */
    where: NotificacionWhereUniqueInput
    /**
     * In case the Notificacion found by the `where` argument doesn't exist, create a new Notificacion with this data.
     */
    create: XOR<NotificacionCreateInput, NotificacionUncheckedCreateInput>
    /**
     * In case the Notificacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificacionUpdateInput, NotificacionUncheckedUpdateInput>
  }

  /**
   * Notificacion delete
   */
  export type NotificacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter which Notificacion to delete.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion deleteMany
   */
  export type NotificacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacions to delete
     */
    where?: NotificacionWhereInput
  }

  /**
   * Notificacion without action
   */
  export type NotificacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
  }


  /**
   * Model EntregableFinal
   */

  export type AggregateEntregableFinal = {
    _count: EntregableFinalCountAggregateOutputType | null
    _avg: EntregableFinalAvgAggregateOutputType | null
    _sum: EntregableFinalSumAggregateOutputType | null
    _min: EntregableFinalMinAggregateOutputType | null
    _max: EntregableFinalMaxAggregateOutputType | null
  }

  export type EntregableFinalAvgAggregateOutputType = {
    id: number | null
    propuestasId: number | null
  }

  export type EntregableFinalSumAggregateOutputType = {
    id: number | null
    propuestasId: number | null
  }

  export type EntregableFinalMinAggregateOutputType = {
    id: number | null
    tipo: $Enums.TipoEntregable | null
    urlArchivo: string | null
    fechaSubida: Date | null
    propuestasId: number | null
  }

  export type EntregableFinalMaxAggregateOutputType = {
    id: number | null
    tipo: $Enums.TipoEntregable | null
    urlArchivo: string | null
    fechaSubida: Date | null
    propuestasId: number | null
  }

  export type EntregableFinalCountAggregateOutputType = {
    id: number
    tipo: number
    urlArchivo: number
    fechaSubida: number
    propuestasId: number
    _all: number
  }


  export type EntregableFinalAvgAggregateInputType = {
    id?: true
    propuestasId?: true
  }

  export type EntregableFinalSumAggregateInputType = {
    id?: true
    propuestasId?: true
  }

  export type EntregableFinalMinAggregateInputType = {
    id?: true
    tipo?: true
    urlArchivo?: true
    fechaSubida?: true
    propuestasId?: true
  }

  export type EntregableFinalMaxAggregateInputType = {
    id?: true
    tipo?: true
    urlArchivo?: true
    fechaSubida?: true
    propuestasId?: true
  }

  export type EntregableFinalCountAggregateInputType = {
    id?: true
    tipo?: true
    urlArchivo?: true
    fechaSubida?: true
    propuestasId?: true
    _all?: true
  }

  export type EntregableFinalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntregableFinal to aggregate.
     */
    where?: EntregableFinalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntregableFinals to fetch.
     */
    orderBy?: EntregableFinalOrderByWithRelationInput | EntregableFinalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntregableFinalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntregableFinals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntregableFinals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EntregableFinals
    **/
    _count?: true | EntregableFinalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntregableFinalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntregableFinalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntregableFinalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntregableFinalMaxAggregateInputType
  }

  export type GetEntregableFinalAggregateType<T extends EntregableFinalAggregateArgs> = {
        [P in keyof T & keyof AggregateEntregableFinal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntregableFinal[P]>
      : GetScalarType<T[P], AggregateEntregableFinal[P]>
  }




  export type EntregableFinalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntregableFinalWhereInput
    orderBy?: EntregableFinalOrderByWithAggregationInput | EntregableFinalOrderByWithAggregationInput[]
    by: EntregableFinalScalarFieldEnum[] | EntregableFinalScalarFieldEnum
    having?: EntregableFinalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntregableFinalCountAggregateInputType | true
    _avg?: EntregableFinalAvgAggregateInputType
    _sum?: EntregableFinalSumAggregateInputType
    _min?: EntregableFinalMinAggregateInputType
    _max?: EntregableFinalMaxAggregateInputType
  }

  export type EntregableFinalGroupByOutputType = {
    id: number
    tipo: $Enums.TipoEntregable
    urlArchivo: string
    fechaSubida: Date
    propuestasId: number
    _count: EntregableFinalCountAggregateOutputType | null
    _avg: EntregableFinalAvgAggregateOutputType | null
    _sum: EntregableFinalSumAggregateOutputType | null
    _min: EntregableFinalMinAggregateOutputType | null
    _max: EntregableFinalMaxAggregateOutputType | null
  }

  type GetEntregableFinalGroupByPayload<T extends EntregableFinalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntregableFinalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntregableFinalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntregableFinalGroupByOutputType[P]>
            : GetScalarType<T[P], EntregableFinalGroupByOutputType[P]>
        }
      >
    >


  export type EntregableFinalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    urlArchivo?: boolean
    fechaSubida?: boolean
    propuestasId?: boolean
    propuesta?: boolean | PropuestaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entregableFinal"]>


  export type EntregableFinalSelectScalar = {
    id?: boolean
    tipo?: boolean
    urlArchivo?: boolean
    fechaSubida?: boolean
    propuestasId?: boolean
  }

  export type EntregableFinalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propuesta?: boolean | PropuestaDefaultArgs<ExtArgs>
  }

  export type $EntregableFinalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EntregableFinal"
    objects: {
      propuesta: Prisma.$PropuestaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipo: $Enums.TipoEntregable
      urlArchivo: string
      fechaSubida: Date
      propuestasId: number
    }, ExtArgs["result"]["entregableFinal"]>
    composites: {}
  }

  type EntregableFinalGetPayload<S extends boolean | null | undefined | EntregableFinalDefaultArgs> = $Result.GetResult<Prisma.$EntregableFinalPayload, S>

  type EntregableFinalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EntregableFinalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntregableFinalCountAggregateInputType | true
    }

  export interface EntregableFinalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EntregableFinal'], meta: { name: 'EntregableFinal' } }
    /**
     * Find zero or one EntregableFinal that matches the filter.
     * @param {EntregableFinalFindUniqueArgs} args - Arguments to find a EntregableFinal
     * @example
     * // Get one EntregableFinal
     * const entregableFinal = await prisma.entregableFinal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EntregableFinalFindUniqueArgs>(args: SelectSubset<T, EntregableFinalFindUniqueArgs<ExtArgs>>): Prisma__EntregableFinalClient<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EntregableFinal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EntregableFinalFindUniqueOrThrowArgs} args - Arguments to find a EntregableFinal
     * @example
     * // Get one EntregableFinal
     * const entregableFinal = await prisma.entregableFinal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EntregableFinalFindUniqueOrThrowArgs>(args: SelectSubset<T, EntregableFinalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EntregableFinalClient<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EntregableFinal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregableFinalFindFirstArgs} args - Arguments to find a EntregableFinal
     * @example
     * // Get one EntregableFinal
     * const entregableFinal = await prisma.entregableFinal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EntregableFinalFindFirstArgs>(args?: SelectSubset<T, EntregableFinalFindFirstArgs<ExtArgs>>): Prisma__EntregableFinalClient<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EntregableFinal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregableFinalFindFirstOrThrowArgs} args - Arguments to find a EntregableFinal
     * @example
     * // Get one EntregableFinal
     * const entregableFinal = await prisma.entregableFinal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EntregableFinalFindFirstOrThrowArgs>(args?: SelectSubset<T, EntregableFinalFindFirstOrThrowArgs<ExtArgs>>): Prisma__EntregableFinalClient<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EntregableFinals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregableFinalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EntregableFinals
     * const entregableFinals = await prisma.entregableFinal.findMany()
     * 
     * // Get first 10 EntregableFinals
     * const entregableFinals = await prisma.entregableFinal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entregableFinalWithIdOnly = await prisma.entregableFinal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EntregableFinalFindManyArgs>(args?: SelectSubset<T, EntregableFinalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EntregableFinal.
     * @param {EntregableFinalCreateArgs} args - Arguments to create a EntregableFinal.
     * @example
     * // Create one EntregableFinal
     * const EntregableFinal = await prisma.entregableFinal.create({
     *   data: {
     *     // ... data to create a EntregableFinal
     *   }
     * })
     * 
     */
    create<T extends EntregableFinalCreateArgs>(args: SelectSubset<T, EntregableFinalCreateArgs<ExtArgs>>): Prisma__EntregableFinalClient<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EntregableFinals.
     * @param {EntregableFinalCreateManyArgs} args - Arguments to create many EntregableFinals.
     * @example
     * // Create many EntregableFinals
     * const entregableFinal = await prisma.entregableFinal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EntregableFinalCreateManyArgs>(args?: SelectSubset<T, EntregableFinalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EntregableFinal.
     * @param {EntregableFinalDeleteArgs} args - Arguments to delete one EntregableFinal.
     * @example
     * // Delete one EntregableFinal
     * const EntregableFinal = await prisma.entregableFinal.delete({
     *   where: {
     *     // ... filter to delete one EntregableFinal
     *   }
     * })
     * 
     */
    delete<T extends EntregableFinalDeleteArgs>(args: SelectSubset<T, EntregableFinalDeleteArgs<ExtArgs>>): Prisma__EntregableFinalClient<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EntregableFinal.
     * @param {EntregableFinalUpdateArgs} args - Arguments to update one EntregableFinal.
     * @example
     * // Update one EntregableFinal
     * const entregableFinal = await prisma.entregableFinal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EntregableFinalUpdateArgs>(args: SelectSubset<T, EntregableFinalUpdateArgs<ExtArgs>>): Prisma__EntregableFinalClient<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EntregableFinals.
     * @param {EntregableFinalDeleteManyArgs} args - Arguments to filter EntregableFinals to delete.
     * @example
     * // Delete a few EntregableFinals
     * const { count } = await prisma.entregableFinal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EntregableFinalDeleteManyArgs>(args?: SelectSubset<T, EntregableFinalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EntregableFinals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregableFinalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EntregableFinals
     * const entregableFinal = await prisma.entregableFinal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EntregableFinalUpdateManyArgs>(args: SelectSubset<T, EntregableFinalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EntregableFinal.
     * @param {EntregableFinalUpsertArgs} args - Arguments to update or create a EntregableFinal.
     * @example
     * // Update or create a EntregableFinal
     * const entregableFinal = await prisma.entregableFinal.upsert({
     *   create: {
     *     // ... data to create a EntregableFinal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EntregableFinal we want to update
     *   }
     * })
     */
    upsert<T extends EntregableFinalUpsertArgs>(args: SelectSubset<T, EntregableFinalUpsertArgs<ExtArgs>>): Prisma__EntregableFinalClient<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EntregableFinals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregableFinalCountArgs} args - Arguments to filter EntregableFinals to count.
     * @example
     * // Count the number of EntregableFinals
     * const count = await prisma.entregableFinal.count({
     *   where: {
     *     // ... the filter for the EntregableFinals we want to count
     *   }
     * })
    **/
    count<T extends EntregableFinalCountArgs>(
      args?: Subset<T, EntregableFinalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntregableFinalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EntregableFinal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregableFinalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntregableFinalAggregateArgs>(args: Subset<T, EntregableFinalAggregateArgs>): Prisma.PrismaPromise<GetEntregableFinalAggregateType<T>>

    /**
     * Group by EntregableFinal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregableFinalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntregableFinalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntregableFinalGroupByArgs['orderBy'] }
        : { orderBy?: EntregableFinalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntregableFinalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntregableFinalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EntregableFinal model
   */
  readonly fields: EntregableFinalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EntregableFinal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntregableFinalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    propuesta<T extends PropuestaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropuestaDefaultArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EntregableFinal model
   */ 
  interface EntregableFinalFieldRefs {
    readonly id: FieldRef<"EntregableFinal", 'Int'>
    readonly tipo: FieldRef<"EntregableFinal", 'TipoEntregable'>
    readonly urlArchivo: FieldRef<"EntregableFinal", 'String'>
    readonly fechaSubida: FieldRef<"EntregableFinal", 'DateTime'>
    readonly propuestasId: FieldRef<"EntregableFinal", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EntregableFinal findUnique
   */
  export type EntregableFinalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * Filter, which EntregableFinal to fetch.
     */
    where: EntregableFinalWhereUniqueInput
  }

  /**
   * EntregableFinal findUniqueOrThrow
   */
  export type EntregableFinalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * Filter, which EntregableFinal to fetch.
     */
    where: EntregableFinalWhereUniqueInput
  }

  /**
   * EntregableFinal findFirst
   */
  export type EntregableFinalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * Filter, which EntregableFinal to fetch.
     */
    where?: EntregableFinalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntregableFinals to fetch.
     */
    orderBy?: EntregableFinalOrderByWithRelationInput | EntregableFinalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntregableFinals.
     */
    cursor?: EntregableFinalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntregableFinals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntregableFinals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntregableFinals.
     */
    distinct?: EntregableFinalScalarFieldEnum | EntregableFinalScalarFieldEnum[]
  }

  /**
   * EntregableFinal findFirstOrThrow
   */
  export type EntregableFinalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * Filter, which EntregableFinal to fetch.
     */
    where?: EntregableFinalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntregableFinals to fetch.
     */
    orderBy?: EntregableFinalOrderByWithRelationInput | EntregableFinalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntregableFinals.
     */
    cursor?: EntregableFinalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntregableFinals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntregableFinals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntregableFinals.
     */
    distinct?: EntregableFinalScalarFieldEnum | EntregableFinalScalarFieldEnum[]
  }

  /**
   * EntregableFinal findMany
   */
  export type EntregableFinalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * Filter, which EntregableFinals to fetch.
     */
    where?: EntregableFinalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntregableFinals to fetch.
     */
    orderBy?: EntregableFinalOrderByWithRelationInput | EntregableFinalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EntregableFinals.
     */
    cursor?: EntregableFinalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntregableFinals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntregableFinals.
     */
    skip?: number
    distinct?: EntregableFinalScalarFieldEnum | EntregableFinalScalarFieldEnum[]
  }

  /**
   * EntregableFinal create
   */
  export type EntregableFinalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * The data needed to create a EntregableFinal.
     */
    data: XOR<EntregableFinalCreateInput, EntregableFinalUncheckedCreateInput>
  }

  /**
   * EntregableFinal createMany
   */
  export type EntregableFinalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EntregableFinals.
     */
    data: EntregableFinalCreateManyInput | EntregableFinalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EntregableFinal update
   */
  export type EntregableFinalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * The data needed to update a EntregableFinal.
     */
    data: XOR<EntregableFinalUpdateInput, EntregableFinalUncheckedUpdateInput>
    /**
     * Choose, which EntregableFinal to update.
     */
    where: EntregableFinalWhereUniqueInput
  }

  /**
   * EntregableFinal updateMany
   */
  export type EntregableFinalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EntregableFinals.
     */
    data: XOR<EntregableFinalUpdateManyMutationInput, EntregableFinalUncheckedUpdateManyInput>
    /**
     * Filter which EntregableFinals to update
     */
    where?: EntregableFinalWhereInput
  }

  /**
   * EntregableFinal upsert
   */
  export type EntregableFinalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * The filter to search for the EntregableFinal to update in case it exists.
     */
    where: EntregableFinalWhereUniqueInput
    /**
     * In case the EntregableFinal found by the `where` argument doesn't exist, create a new EntregableFinal with this data.
     */
    create: XOR<EntregableFinalCreateInput, EntregableFinalUncheckedCreateInput>
    /**
     * In case the EntregableFinal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntregableFinalUpdateInput, EntregableFinalUncheckedUpdateInput>
  }

  /**
   * EntregableFinal delete
   */
  export type EntregableFinalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * Filter which EntregableFinal to delete.
     */
    where: EntregableFinalWhereUniqueInput
  }

  /**
   * EntregableFinal deleteMany
   */
  export type EntregableFinalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntregableFinals to delete
     */
    where?: EntregableFinalWhereInput
  }

  /**
   * EntregableFinal without action
   */
  export type EntregableFinalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
  }


  /**
   * Model Comite
   */

  export type AggregateComite = {
    _count: ComiteCountAggregateOutputType | null
    _avg: ComiteAvgAggregateOutputType | null
    _sum: ComiteSumAggregateOutputType | null
    _min: ComiteMinAggregateOutputType | null
    _max: ComiteMaxAggregateOutputType | null
  }

  export type ComiteAvgAggregateOutputType = {
    usuarioId: number | null
    propuestaId: number | null
    calificacion: Decimal | null
  }

  export type ComiteSumAggregateOutputType = {
    usuarioId: number | null
    propuestaId: number | null
    calificacion: Decimal | null
  }

  export type ComiteMinAggregateOutputType = {
    usuarioId: number | null
    propuestaId: number | null
    rol: $Enums.RolComite | null
    calificacion: Decimal | null
    fechaAsignada: Date | null
  }

  export type ComiteMaxAggregateOutputType = {
    usuarioId: number | null
    propuestaId: number | null
    rol: $Enums.RolComite | null
    calificacion: Decimal | null
    fechaAsignada: Date | null
  }

  export type ComiteCountAggregateOutputType = {
    usuarioId: number
    propuestaId: number
    rol: number
    calificacion: number
    fechaAsignada: number
    _all: number
  }


  export type ComiteAvgAggregateInputType = {
    usuarioId?: true
    propuestaId?: true
    calificacion?: true
  }

  export type ComiteSumAggregateInputType = {
    usuarioId?: true
    propuestaId?: true
    calificacion?: true
  }

  export type ComiteMinAggregateInputType = {
    usuarioId?: true
    propuestaId?: true
    rol?: true
    calificacion?: true
    fechaAsignada?: true
  }

  export type ComiteMaxAggregateInputType = {
    usuarioId?: true
    propuestaId?: true
    rol?: true
    calificacion?: true
    fechaAsignada?: true
  }

  export type ComiteCountAggregateInputType = {
    usuarioId?: true
    propuestaId?: true
    rol?: true
    calificacion?: true
    fechaAsignada?: true
    _all?: true
  }

  export type ComiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comite to aggregate.
     */
    where?: ComiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comites to fetch.
     */
    orderBy?: ComiteOrderByWithRelationInput | ComiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comites
    **/
    _count?: true | ComiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComiteMaxAggregateInputType
  }

  export type GetComiteAggregateType<T extends ComiteAggregateArgs> = {
        [P in keyof T & keyof AggregateComite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComite[P]>
      : GetScalarType<T[P], AggregateComite[P]>
  }




  export type ComiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComiteWhereInput
    orderBy?: ComiteOrderByWithAggregationInput | ComiteOrderByWithAggregationInput[]
    by: ComiteScalarFieldEnum[] | ComiteScalarFieldEnum
    having?: ComiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComiteCountAggregateInputType | true
    _avg?: ComiteAvgAggregateInputType
    _sum?: ComiteSumAggregateInputType
    _min?: ComiteMinAggregateInputType
    _max?: ComiteMaxAggregateInputType
  }

  export type ComiteGroupByOutputType = {
    usuarioId: number
    propuestaId: number
    rol: $Enums.RolComite
    calificacion: Decimal | null
    fechaAsignada: Date | null
    _count: ComiteCountAggregateOutputType | null
    _avg: ComiteAvgAggregateOutputType | null
    _sum: ComiteSumAggregateOutputType | null
    _min: ComiteMinAggregateOutputType | null
    _max: ComiteMaxAggregateOutputType | null
  }

  type GetComiteGroupByPayload<T extends ComiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComiteGroupByOutputType[P]>
            : GetScalarType<T[P], ComiteGroupByOutputType[P]>
        }
      >
    >


  export type ComiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    usuarioId?: boolean
    propuestaId?: boolean
    rol?: boolean
    calificacion?: boolean
    fechaAsignada?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    propuesta?: boolean | PropuestaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comite"]>


  export type ComiteSelectScalar = {
    usuarioId?: boolean
    propuestaId?: boolean
    rol?: boolean
    calificacion?: boolean
    fechaAsignada?: boolean
  }

  export type ComiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    propuesta?: boolean | PropuestaDefaultArgs<ExtArgs>
  }

  export type $ComitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comite"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      propuesta: Prisma.$PropuestaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      usuarioId: number
      propuestaId: number
      rol: $Enums.RolComite
      calificacion: Prisma.Decimal | null
      fechaAsignada: Date | null
    }, ExtArgs["result"]["comite"]>
    composites: {}
  }

  type ComiteGetPayload<S extends boolean | null | undefined | ComiteDefaultArgs> = $Result.GetResult<Prisma.$ComitePayload, S>

  type ComiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComiteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComiteCountAggregateInputType | true
    }

  export interface ComiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comite'], meta: { name: 'Comite' } }
    /**
     * Find zero or one Comite that matches the filter.
     * @param {ComiteFindUniqueArgs} args - Arguments to find a Comite
     * @example
     * // Get one Comite
     * const comite = await prisma.comite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComiteFindUniqueArgs>(args: SelectSubset<T, ComiteFindUniqueArgs<ExtArgs>>): Prisma__ComiteClient<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComiteFindUniqueOrThrowArgs} args - Arguments to find a Comite
     * @example
     * // Get one Comite
     * const comite = await prisma.comite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComiteFindUniqueOrThrowArgs>(args: SelectSubset<T, ComiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComiteClient<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComiteFindFirstArgs} args - Arguments to find a Comite
     * @example
     * // Get one Comite
     * const comite = await prisma.comite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComiteFindFirstArgs>(args?: SelectSubset<T, ComiteFindFirstArgs<ExtArgs>>): Prisma__ComiteClient<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComiteFindFirstOrThrowArgs} args - Arguments to find a Comite
     * @example
     * // Get one Comite
     * const comite = await prisma.comite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComiteFindFirstOrThrowArgs>(args?: SelectSubset<T, ComiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComiteClient<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comites
     * const comites = await prisma.comite.findMany()
     * 
     * // Get first 10 Comites
     * const comites = await prisma.comite.findMany({ take: 10 })
     * 
     * // Only select the `usuarioId`
     * const comiteWithUsuarioIdOnly = await prisma.comite.findMany({ select: { usuarioId: true } })
     * 
     */
    findMany<T extends ComiteFindManyArgs>(args?: SelectSubset<T, ComiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comite.
     * @param {ComiteCreateArgs} args - Arguments to create a Comite.
     * @example
     * // Create one Comite
     * const Comite = await prisma.comite.create({
     *   data: {
     *     // ... data to create a Comite
     *   }
     * })
     * 
     */
    create<T extends ComiteCreateArgs>(args: SelectSubset<T, ComiteCreateArgs<ExtArgs>>): Prisma__ComiteClient<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comites.
     * @param {ComiteCreateManyArgs} args - Arguments to create many Comites.
     * @example
     * // Create many Comites
     * const comite = await prisma.comite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComiteCreateManyArgs>(args?: SelectSubset<T, ComiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comite.
     * @param {ComiteDeleteArgs} args - Arguments to delete one Comite.
     * @example
     * // Delete one Comite
     * const Comite = await prisma.comite.delete({
     *   where: {
     *     // ... filter to delete one Comite
     *   }
     * })
     * 
     */
    delete<T extends ComiteDeleteArgs>(args: SelectSubset<T, ComiteDeleteArgs<ExtArgs>>): Prisma__ComiteClient<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comite.
     * @param {ComiteUpdateArgs} args - Arguments to update one Comite.
     * @example
     * // Update one Comite
     * const comite = await prisma.comite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComiteUpdateArgs>(args: SelectSubset<T, ComiteUpdateArgs<ExtArgs>>): Prisma__ComiteClient<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comites.
     * @param {ComiteDeleteManyArgs} args - Arguments to filter Comites to delete.
     * @example
     * // Delete a few Comites
     * const { count } = await prisma.comite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComiteDeleteManyArgs>(args?: SelectSubset<T, ComiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comites
     * const comite = await prisma.comite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComiteUpdateManyArgs>(args: SelectSubset<T, ComiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comite.
     * @param {ComiteUpsertArgs} args - Arguments to update or create a Comite.
     * @example
     * // Update or create a Comite
     * const comite = await prisma.comite.upsert({
     *   create: {
     *     // ... data to create a Comite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comite we want to update
     *   }
     * })
     */
    upsert<T extends ComiteUpsertArgs>(args: SelectSubset<T, ComiteUpsertArgs<ExtArgs>>): Prisma__ComiteClient<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComiteCountArgs} args - Arguments to filter Comites to count.
     * @example
     * // Count the number of Comites
     * const count = await prisma.comite.count({
     *   where: {
     *     // ... the filter for the Comites we want to count
     *   }
     * })
    **/
    count<T extends ComiteCountArgs>(
      args?: Subset<T, ComiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComiteAggregateArgs>(args: Subset<T, ComiteAggregateArgs>): Prisma.PrismaPromise<GetComiteAggregateType<T>>

    /**
     * Group by Comite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComiteGroupByArgs['orderBy'] }
        : { orderBy?: ComiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comite model
   */
  readonly fields: ComiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    propuesta<T extends PropuestaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropuestaDefaultArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comite model
   */ 
  interface ComiteFieldRefs {
    readonly usuarioId: FieldRef<"Comite", 'Int'>
    readonly propuestaId: FieldRef<"Comite", 'Int'>
    readonly rol: FieldRef<"Comite", 'RolComite'>
    readonly calificacion: FieldRef<"Comite", 'Decimal'>
    readonly fechaAsignada: FieldRef<"Comite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comite findUnique
   */
  export type ComiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * Filter, which Comite to fetch.
     */
    where: ComiteWhereUniqueInput
  }

  /**
   * Comite findUniqueOrThrow
   */
  export type ComiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * Filter, which Comite to fetch.
     */
    where: ComiteWhereUniqueInput
  }

  /**
   * Comite findFirst
   */
  export type ComiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * Filter, which Comite to fetch.
     */
    where?: ComiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comites to fetch.
     */
    orderBy?: ComiteOrderByWithRelationInput | ComiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comites.
     */
    cursor?: ComiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comites.
     */
    distinct?: ComiteScalarFieldEnum | ComiteScalarFieldEnum[]
  }

  /**
   * Comite findFirstOrThrow
   */
  export type ComiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * Filter, which Comite to fetch.
     */
    where?: ComiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comites to fetch.
     */
    orderBy?: ComiteOrderByWithRelationInput | ComiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comites.
     */
    cursor?: ComiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comites.
     */
    distinct?: ComiteScalarFieldEnum | ComiteScalarFieldEnum[]
  }

  /**
   * Comite findMany
   */
  export type ComiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * Filter, which Comites to fetch.
     */
    where?: ComiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comites to fetch.
     */
    orderBy?: ComiteOrderByWithRelationInput | ComiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comites.
     */
    cursor?: ComiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comites.
     */
    skip?: number
    distinct?: ComiteScalarFieldEnum | ComiteScalarFieldEnum[]
  }

  /**
   * Comite create
   */
  export type ComiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * The data needed to create a Comite.
     */
    data: XOR<ComiteCreateInput, ComiteUncheckedCreateInput>
  }

  /**
   * Comite createMany
   */
  export type ComiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comites.
     */
    data: ComiteCreateManyInput | ComiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comite update
   */
  export type ComiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * The data needed to update a Comite.
     */
    data: XOR<ComiteUpdateInput, ComiteUncheckedUpdateInput>
    /**
     * Choose, which Comite to update.
     */
    where: ComiteWhereUniqueInput
  }

  /**
   * Comite updateMany
   */
  export type ComiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comites.
     */
    data: XOR<ComiteUpdateManyMutationInput, ComiteUncheckedUpdateManyInput>
    /**
     * Filter which Comites to update
     */
    where?: ComiteWhereInput
  }

  /**
   * Comite upsert
   */
  export type ComiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * The filter to search for the Comite to update in case it exists.
     */
    where: ComiteWhereUniqueInput
    /**
     * In case the Comite found by the `where` argument doesn't exist, create a new Comite with this data.
     */
    create: XOR<ComiteCreateInput, ComiteUncheckedCreateInput>
    /**
     * In case the Comite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComiteUpdateInput, ComiteUncheckedUpdateInput>
  }

  /**
   * Comite delete
   */
  export type ComiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * Filter which Comite to delete.
     */
    where: ComiteWhereUniqueInput
  }

  /**
   * Comite deleteMany
   */
  export type ComiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comites to delete
     */
    where?: ComiteWhereInput
  }

  /**
   * Comite without action
   */
  export type ComiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
  }


  /**
   * Model EstudiantePerfil
   */

  export type AggregateEstudiantePerfil = {
    _count: EstudiantePerfilCountAggregateOutputType | null
    _avg: EstudiantePerfilAvgAggregateOutputType | null
    _sum: EstudiantePerfilSumAggregateOutputType | null
    _min: EstudiantePerfilMinAggregateOutputType | null
    _max: EstudiantePerfilMaxAggregateOutputType | null
  }

  export type EstudiantePerfilAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type EstudiantePerfilSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type EstudiantePerfilMinAggregateOutputType = {
    id: number | null
    sexo: string | null
    estadoEscuela: string | null
    sede: string | null
    escuela: string | null
    codigoMalla: string | null
    malla: string | null
    periodoLectivo: string | null
    ciudad: string | null
    provincia: string | null
    pais: string | null
    usuarioId: number | null
  }

  export type EstudiantePerfilMaxAggregateOutputType = {
    id: number | null
    sexo: string | null
    estadoEscuela: string | null
    sede: string | null
    escuela: string | null
    codigoMalla: string | null
    malla: string | null
    periodoLectivo: string | null
    ciudad: string | null
    provincia: string | null
    pais: string | null
    usuarioId: number | null
  }

  export type EstudiantePerfilCountAggregateOutputType = {
    id: number
    sexo: number
    estadoEscuela: number
    sede: number
    escuela: number
    codigoMalla: number
    malla: number
    periodoLectivo: number
    ciudad: number
    provincia: number
    pais: number
    usuarioId: number
    _all: number
  }


  export type EstudiantePerfilAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type EstudiantePerfilSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type EstudiantePerfilMinAggregateInputType = {
    id?: true
    sexo?: true
    estadoEscuela?: true
    sede?: true
    escuela?: true
    codigoMalla?: true
    malla?: true
    periodoLectivo?: true
    ciudad?: true
    provincia?: true
    pais?: true
    usuarioId?: true
  }

  export type EstudiantePerfilMaxAggregateInputType = {
    id?: true
    sexo?: true
    estadoEscuela?: true
    sede?: true
    escuela?: true
    codigoMalla?: true
    malla?: true
    periodoLectivo?: true
    ciudad?: true
    provincia?: true
    pais?: true
    usuarioId?: true
  }

  export type EstudiantePerfilCountAggregateInputType = {
    id?: true
    sexo?: true
    estadoEscuela?: true
    sede?: true
    escuela?: true
    codigoMalla?: true
    malla?: true
    periodoLectivo?: true
    ciudad?: true
    provincia?: true
    pais?: true
    usuarioId?: true
    _all?: true
  }

  export type EstudiantePerfilAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EstudiantePerfil to aggregate.
     */
    where?: EstudiantePerfilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstudiantePerfils to fetch.
     */
    orderBy?: EstudiantePerfilOrderByWithRelationInput | EstudiantePerfilOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EstudiantePerfilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstudiantePerfils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstudiantePerfils.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EstudiantePerfils
    **/
    _count?: true | EstudiantePerfilCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstudiantePerfilAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstudiantePerfilSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstudiantePerfilMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstudiantePerfilMaxAggregateInputType
  }

  export type GetEstudiantePerfilAggregateType<T extends EstudiantePerfilAggregateArgs> = {
        [P in keyof T & keyof AggregateEstudiantePerfil]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstudiantePerfil[P]>
      : GetScalarType<T[P], AggregateEstudiantePerfil[P]>
  }




  export type EstudiantePerfilGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudiantePerfilWhereInput
    orderBy?: EstudiantePerfilOrderByWithAggregationInput | EstudiantePerfilOrderByWithAggregationInput[]
    by: EstudiantePerfilScalarFieldEnum[] | EstudiantePerfilScalarFieldEnum
    having?: EstudiantePerfilScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstudiantePerfilCountAggregateInputType | true
    _avg?: EstudiantePerfilAvgAggregateInputType
    _sum?: EstudiantePerfilSumAggregateInputType
    _min?: EstudiantePerfilMinAggregateInputType
    _max?: EstudiantePerfilMaxAggregateInputType
  }

  export type EstudiantePerfilGroupByOutputType = {
    id: number
    sexo: string | null
    estadoEscuela: string | null
    sede: string | null
    escuela: string | null
    codigoMalla: string | null
    malla: string | null
    periodoLectivo: string | null
    ciudad: string | null
    provincia: string | null
    pais: string | null
    usuarioId: number
    _count: EstudiantePerfilCountAggregateOutputType | null
    _avg: EstudiantePerfilAvgAggregateOutputType | null
    _sum: EstudiantePerfilSumAggregateOutputType | null
    _min: EstudiantePerfilMinAggregateOutputType | null
    _max: EstudiantePerfilMaxAggregateOutputType | null
  }

  type GetEstudiantePerfilGroupByPayload<T extends EstudiantePerfilGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstudiantePerfilGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstudiantePerfilGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstudiantePerfilGroupByOutputType[P]>
            : GetScalarType<T[P], EstudiantePerfilGroupByOutputType[P]>
        }
      >
    >


  export type EstudiantePerfilSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sexo?: boolean
    estadoEscuela?: boolean
    sede?: boolean
    escuela?: boolean
    codigoMalla?: boolean
    malla?: boolean
    periodoLectivo?: boolean
    ciudad?: boolean
    provincia?: boolean
    pais?: boolean
    usuarioId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estudiantePerfil"]>


  export type EstudiantePerfilSelectScalar = {
    id?: boolean
    sexo?: boolean
    estadoEscuela?: boolean
    sede?: boolean
    escuela?: boolean
    codigoMalla?: boolean
    malla?: boolean
    periodoLectivo?: boolean
    ciudad?: boolean
    provincia?: boolean
    pais?: boolean
    usuarioId?: boolean
  }

  export type EstudiantePerfilInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $EstudiantePerfilPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EstudiantePerfil"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sexo: string | null
      estadoEscuela: string | null
      sede: string | null
      escuela: string | null
      codigoMalla: string | null
      malla: string | null
      periodoLectivo: string | null
      ciudad: string | null
      provincia: string | null
      pais: string | null
      usuarioId: number
    }, ExtArgs["result"]["estudiantePerfil"]>
    composites: {}
  }

  type EstudiantePerfilGetPayload<S extends boolean | null | undefined | EstudiantePerfilDefaultArgs> = $Result.GetResult<Prisma.$EstudiantePerfilPayload, S>

  type EstudiantePerfilCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EstudiantePerfilFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EstudiantePerfilCountAggregateInputType | true
    }

  export interface EstudiantePerfilDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EstudiantePerfil'], meta: { name: 'EstudiantePerfil' } }
    /**
     * Find zero or one EstudiantePerfil that matches the filter.
     * @param {EstudiantePerfilFindUniqueArgs} args - Arguments to find a EstudiantePerfil
     * @example
     * // Get one EstudiantePerfil
     * const estudiantePerfil = await prisma.estudiantePerfil.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EstudiantePerfilFindUniqueArgs>(args: SelectSubset<T, EstudiantePerfilFindUniqueArgs<ExtArgs>>): Prisma__EstudiantePerfilClient<$Result.GetResult<Prisma.$EstudiantePerfilPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EstudiantePerfil that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EstudiantePerfilFindUniqueOrThrowArgs} args - Arguments to find a EstudiantePerfil
     * @example
     * // Get one EstudiantePerfil
     * const estudiantePerfil = await prisma.estudiantePerfil.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EstudiantePerfilFindUniqueOrThrowArgs>(args: SelectSubset<T, EstudiantePerfilFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EstudiantePerfilClient<$Result.GetResult<Prisma.$EstudiantePerfilPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EstudiantePerfil that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantePerfilFindFirstArgs} args - Arguments to find a EstudiantePerfil
     * @example
     * // Get one EstudiantePerfil
     * const estudiantePerfil = await prisma.estudiantePerfil.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EstudiantePerfilFindFirstArgs>(args?: SelectSubset<T, EstudiantePerfilFindFirstArgs<ExtArgs>>): Prisma__EstudiantePerfilClient<$Result.GetResult<Prisma.$EstudiantePerfilPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EstudiantePerfil that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantePerfilFindFirstOrThrowArgs} args - Arguments to find a EstudiantePerfil
     * @example
     * // Get one EstudiantePerfil
     * const estudiantePerfil = await prisma.estudiantePerfil.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EstudiantePerfilFindFirstOrThrowArgs>(args?: SelectSubset<T, EstudiantePerfilFindFirstOrThrowArgs<ExtArgs>>): Prisma__EstudiantePerfilClient<$Result.GetResult<Prisma.$EstudiantePerfilPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EstudiantePerfils that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantePerfilFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EstudiantePerfils
     * const estudiantePerfils = await prisma.estudiantePerfil.findMany()
     * 
     * // Get first 10 EstudiantePerfils
     * const estudiantePerfils = await prisma.estudiantePerfil.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estudiantePerfilWithIdOnly = await prisma.estudiantePerfil.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EstudiantePerfilFindManyArgs>(args?: SelectSubset<T, EstudiantePerfilFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudiantePerfilPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EstudiantePerfil.
     * @param {EstudiantePerfilCreateArgs} args - Arguments to create a EstudiantePerfil.
     * @example
     * // Create one EstudiantePerfil
     * const EstudiantePerfil = await prisma.estudiantePerfil.create({
     *   data: {
     *     // ... data to create a EstudiantePerfil
     *   }
     * })
     * 
     */
    create<T extends EstudiantePerfilCreateArgs>(args: SelectSubset<T, EstudiantePerfilCreateArgs<ExtArgs>>): Prisma__EstudiantePerfilClient<$Result.GetResult<Prisma.$EstudiantePerfilPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EstudiantePerfils.
     * @param {EstudiantePerfilCreateManyArgs} args - Arguments to create many EstudiantePerfils.
     * @example
     * // Create many EstudiantePerfils
     * const estudiantePerfil = await prisma.estudiantePerfil.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EstudiantePerfilCreateManyArgs>(args?: SelectSubset<T, EstudiantePerfilCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EstudiantePerfil.
     * @param {EstudiantePerfilDeleteArgs} args - Arguments to delete one EstudiantePerfil.
     * @example
     * // Delete one EstudiantePerfil
     * const EstudiantePerfil = await prisma.estudiantePerfil.delete({
     *   where: {
     *     // ... filter to delete one EstudiantePerfil
     *   }
     * })
     * 
     */
    delete<T extends EstudiantePerfilDeleteArgs>(args: SelectSubset<T, EstudiantePerfilDeleteArgs<ExtArgs>>): Prisma__EstudiantePerfilClient<$Result.GetResult<Prisma.$EstudiantePerfilPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EstudiantePerfil.
     * @param {EstudiantePerfilUpdateArgs} args - Arguments to update one EstudiantePerfil.
     * @example
     * // Update one EstudiantePerfil
     * const estudiantePerfil = await prisma.estudiantePerfil.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EstudiantePerfilUpdateArgs>(args: SelectSubset<T, EstudiantePerfilUpdateArgs<ExtArgs>>): Prisma__EstudiantePerfilClient<$Result.GetResult<Prisma.$EstudiantePerfilPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EstudiantePerfils.
     * @param {EstudiantePerfilDeleteManyArgs} args - Arguments to filter EstudiantePerfils to delete.
     * @example
     * // Delete a few EstudiantePerfils
     * const { count } = await prisma.estudiantePerfil.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EstudiantePerfilDeleteManyArgs>(args?: SelectSubset<T, EstudiantePerfilDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EstudiantePerfils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantePerfilUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EstudiantePerfils
     * const estudiantePerfil = await prisma.estudiantePerfil.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EstudiantePerfilUpdateManyArgs>(args: SelectSubset<T, EstudiantePerfilUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EstudiantePerfil.
     * @param {EstudiantePerfilUpsertArgs} args - Arguments to update or create a EstudiantePerfil.
     * @example
     * // Update or create a EstudiantePerfil
     * const estudiantePerfil = await prisma.estudiantePerfil.upsert({
     *   create: {
     *     // ... data to create a EstudiantePerfil
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EstudiantePerfil we want to update
     *   }
     * })
     */
    upsert<T extends EstudiantePerfilUpsertArgs>(args: SelectSubset<T, EstudiantePerfilUpsertArgs<ExtArgs>>): Prisma__EstudiantePerfilClient<$Result.GetResult<Prisma.$EstudiantePerfilPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EstudiantePerfils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantePerfilCountArgs} args - Arguments to filter EstudiantePerfils to count.
     * @example
     * // Count the number of EstudiantePerfils
     * const count = await prisma.estudiantePerfil.count({
     *   where: {
     *     // ... the filter for the EstudiantePerfils we want to count
     *   }
     * })
    **/
    count<T extends EstudiantePerfilCountArgs>(
      args?: Subset<T, EstudiantePerfilCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstudiantePerfilCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EstudiantePerfil.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantePerfilAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstudiantePerfilAggregateArgs>(args: Subset<T, EstudiantePerfilAggregateArgs>): Prisma.PrismaPromise<GetEstudiantePerfilAggregateType<T>>

    /**
     * Group by EstudiantePerfil.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantePerfilGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstudiantePerfilGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstudiantePerfilGroupByArgs['orderBy'] }
        : { orderBy?: EstudiantePerfilGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstudiantePerfilGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstudiantePerfilGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EstudiantePerfil model
   */
  readonly fields: EstudiantePerfilFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EstudiantePerfil.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EstudiantePerfilClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EstudiantePerfil model
   */ 
  interface EstudiantePerfilFieldRefs {
    readonly id: FieldRef<"EstudiantePerfil", 'Int'>
    readonly sexo: FieldRef<"EstudiantePerfil", 'String'>
    readonly estadoEscuela: FieldRef<"EstudiantePerfil", 'String'>
    readonly sede: FieldRef<"EstudiantePerfil", 'String'>
    readonly escuela: FieldRef<"EstudiantePerfil", 'String'>
    readonly codigoMalla: FieldRef<"EstudiantePerfil", 'String'>
    readonly malla: FieldRef<"EstudiantePerfil", 'String'>
    readonly periodoLectivo: FieldRef<"EstudiantePerfil", 'String'>
    readonly ciudad: FieldRef<"EstudiantePerfil", 'String'>
    readonly provincia: FieldRef<"EstudiantePerfil", 'String'>
    readonly pais: FieldRef<"EstudiantePerfil", 'String'>
    readonly usuarioId: FieldRef<"EstudiantePerfil", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EstudiantePerfil findUnique
   */
  export type EstudiantePerfilFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePerfil
     */
    select?: EstudiantePerfilSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePerfilInclude<ExtArgs> | null
    /**
     * Filter, which EstudiantePerfil to fetch.
     */
    where: EstudiantePerfilWhereUniqueInput
  }

  /**
   * EstudiantePerfil findUniqueOrThrow
   */
  export type EstudiantePerfilFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePerfil
     */
    select?: EstudiantePerfilSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePerfilInclude<ExtArgs> | null
    /**
     * Filter, which EstudiantePerfil to fetch.
     */
    where: EstudiantePerfilWhereUniqueInput
  }

  /**
   * EstudiantePerfil findFirst
   */
  export type EstudiantePerfilFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePerfil
     */
    select?: EstudiantePerfilSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePerfilInclude<ExtArgs> | null
    /**
     * Filter, which EstudiantePerfil to fetch.
     */
    where?: EstudiantePerfilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstudiantePerfils to fetch.
     */
    orderBy?: EstudiantePerfilOrderByWithRelationInput | EstudiantePerfilOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EstudiantePerfils.
     */
    cursor?: EstudiantePerfilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstudiantePerfils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstudiantePerfils.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EstudiantePerfils.
     */
    distinct?: EstudiantePerfilScalarFieldEnum | EstudiantePerfilScalarFieldEnum[]
  }

  /**
   * EstudiantePerfil findFirstOrThrow
   */
  export type EstudiantePerfilFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePerfil
     */
    select?: EstudiantePerfilSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePerfilInclude<ExtArgs> | null
    /**
     * Filter, which EstudiantePerfil to fetch.
     */
    where?: EstudiantePerfilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstudiantePerfils to fetch.
     */
    orderBy?: EstudiantePerfilOrderByWithRelationInput | EstudiantePerfilOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EstudiantePerfils.
     */
    cursor?: EstudiantePerfilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstudiantePerfils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstudiantePerfils.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EstudiantePerfils.
     */
    distinct?: EstudiantePerfilScalarFieldEnum | EstudiantePerfilScalarFieldEnum[]
  }

  /**
   * EstudiantePerfil findMany
   */
  export type EstudiantePerfilFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePerfil
     */
    select?: EstudiantePerfilSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePerfilInclude<ExtArgs> | null
    /**
     * Filter, which EstudiantePerfils to fetch.
     */
    where?: EstudiantePerfilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstudiantePerfils to fetch.
     */
    orderBy?: EstudiantePerfilOrderByWithRelationInput | EstudiantePerfilOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EstudiantePerfils.
     */
    cursor?: EstudiantePerfilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstudiantePerfils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstudiantePerfils.
     */
    skip?: number
    distinct?: EstudiantePerfilScalarFieldEnum | EstudiantePerfilScalarFieldEnum[]
  }

  /**
   * EstudiantePerfil create
   */
  export type EstudiantePerfilCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePerfil
     */
    select?: EstudiantePerfilSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePerfilInclude<ExtArgs> | null
    /**
     * The data needed to create a EstudiantePerfil.
     */
    data: XOR<EstudiantePerfilCreateInput, EstudiantePerfilUncheckedCreateInput>
  }

  /**
   * EstudiantePerfil createMany
   */
  export type EstudiantePerfilCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EstudiantePerfils.
     */
    data: EstudiantePerfilCreateManyInput | EstudiantePerfilCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EstudiantePerfil update
   */
  export type EstudiantePerfilUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePerfil
     */
    select?: EstudiantePerfilSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePerfilInclude<ExtArgs> | null
    /**
     * The data needed to update a EstudiantePerfil.
     */
    data: XOR<EstudiantePerfilUpdateInput, EstudiantePerfilUncheckedUpdateInput>
    /**
     * Choose, which EstudiantePerfil to update.
     */
    where: EstudiantePerfilWhereUniqueInput
  }

  /**
   * EstudiantePerfil updateMany
   */
  export type EstudiantePerfilUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EstudiantePerfils.
     */
    data: XOR<EstudiantePerfilUpdateManyMutationInput, EstudiantePerfilUncheckedUpdateManyInput>
    /**
     * Filter which EstudiantePerfils to update
     */
    where?: EstudiantePerfilWhereInput
  }

  /**
   * EstudiantePerfil upsert
   */
  export type EstudiantePerfilUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePerfil
     */
    select?: EstudiantePerfilSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePerfilInclude<ExtArgs> | null
    /**
     * The filter to search for the EstudiantePerfil to update in case it exists.
     */
    where: EstudiantePerfilWhereUniqueInput
    /**
     * In case the EstudiantePerfil found by the `where` argument doesn't exist, create a new EstudiantePerfil with this data.
     */
    create: XOR<EstudiantePerfilCreateInput, EstudiantePerfilUncheckedCreateInput>
    /**
     * In case the EstudiantePerfil was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EstudiantePerfilUpdateInput, EstudiantePerfilUncheckedUpdateInput>
  }

  /**
   * EstudiantePerfil delete
   */
  export type EstudiantePerfilDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePerfil
     */
    select?: EstudiantePerfilSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePerfilInclude<ExtArgs> | null
    /**
     * Filter which EstudiantePerfil to delete.
     */
    where: EstudiantePerfilWhereUniqueInput
  }

  /**
   * EstudiantePerfil deleteMany
   */
  export type EstudiantePerfilDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EstudiantePerfils to delete
     */
    where?: EstudiantePerfilWhereInput
  }

  /**
   * EstudiantePerfil without action
   */
  export type EstudiantePerfilDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantePerfil
     */
    select?: EstudiantePerfilSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudiantePerfilInclude<ExtArgs> | null
  }


  /**
   * Model McpAuth
   */

  export type AggregateMcpAuth = {
    _count: McpAuthCountAggregateOutputType | null
    _avg: McpAuthAvgAggregateOutputType | null
    _sum: McpAuthSumAggregateOutputType | null
    _min: McpAuthMinAggregateOutputType | null
    _max: McpAuthMaxAggregateOutputType | null
  }

  export type McpAuthAvgAggregateOutputType = {
    id: number | null
  }

  export type McpAuthSumAggregateOutputType = {
    id: number | null
  }

  export type McpAuthMinAggregateOutputType = {
    id: number | null
    email: string | null
    codigo: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type McpAuthMaxAggregateOutputType = {
    id: number | null
    email: string | null
    codigo: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type McpAuthCountAggregateOutputType = {
    id: number
    email: number
    codigo: number
    token: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type McpAuthAvgAggregateInputType = {
    id?: true
  }

  export type McpAuthSumAggregateInputType = {
    id?: true
  }

  export type McpAuthMinAggregateInputType = {
    id?: true
    email?: true
    codigo?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type McpAuthMaxAggregateInputType = {
    id?: true
    email?: true
    codigo?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type McpAuthCountAggregateInputType = {
    id?: true
    email?: true
    codigo?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type McpAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which McpAuth to aggregate.
     */
    where?: McpAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of McpAuths to fetch.
     */
    orderBy?: McpAuthOrderByWithRelationInput | McpAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: McpAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` McpAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` McpAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned McpAuths
    **/
    _count?: true | McpAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: McpAuthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: McpAuthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: McpAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: McpAuthMaxAggregateInputType
  }

  export type GetMcpAuthAggregateType<T extends McpAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateMcpAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMcpAuth[P]>
      : GetScalarType<T[P], AggregateMcpAuth[P]>
  }




  export type McpAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: McpAuthWhereInput
    orderBy?: McpAuthOrderByWithAggregationInput | McpAuthOrderByWithAggregationInput[]
    by: McpAuthScalarFieldEnum[] | McpAuthScalarFieldEnum
    having?: McpAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: McpAuthCountAggregateInputType | true
    _avg?: McpAuthAvgAggregateInputType
    _sum?: McpAuthSumAggregateInputType
    _min?: McpAuthMinAggregateInputType
    _max?: McpAuthMaxAggregateInputType
  }

  export type McpAuthGroupByOutputType = {
    id: number
    email: string
    codigo: string
    token: string | null
    expiresAt: Date
    createdAt: Date
    _count: McpAuthCountAggregateOutputType | null
    _avg: McpAuthAvgAggregateOutputType | null
    _sum: McpAuthSumAggregateOutputType | null
    _min: McpAuthMinAggregateOutputType | null
    _max: McpAuthMaxAggregateOutputType | null
  }

  type GetMcpAuthGroupByPayload<T extends McpAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<McpAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof McpAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], McpAuthGroupByOutputType[P]>
            : GetScalarType<T[P], McpAuthGroupByOutputType[P]>
        }
      >
    >


  export type McpAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    codigo?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["mcpAuth"]>


  export type McpAuthSelectScalar = {
    id?: boolean
    email?: boolean
    codigo?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }


  export type $McpAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "McpAuth"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      codigo: string
      token: string | null
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["mcpAuth"]>
    composites: {}
  }

  type McpAuthGetPayload<S extends boolean | null | undefined | McpAuthDefaultArgs> = $Result.GetResult<Prisma.$McpAuthPayload, S>

  type McpAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<McpAuthFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: McpAuthCountAggregateInputType | true
    }

  export interface McpAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['McpAuth'], meta: { name: 'McpAuth' } }
    /**
     * Find zero or one McpAuth that matches the filter.
     * @param {McpAuthFindUniqueArgs} args - Arguments to find a McpAuth
     * @example
     * // Get one McpAuth
     * const mcpAuth = await prisma.mcpAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends McpAuthFindUniqueArgs>(args: SelectSubset<T, McpAuthFindUniqueArgs<ExtArgs>>): Prisma__McpAuthClient<$Result.GetResult<Prisma.$McpAuthPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one McpAuth that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {McpAuthFindUniqueOrThrowArgs} args - Arguments to find a McpAuth
     * @example
     * // Get one McpAuth
     * const mcpAuth = await prisma.mcpAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends McpAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, McpAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__McpAuthClient<$Result.GetResult<Prisma.$McpAuthPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first McpAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McpAuthFindFirstArgs} args - Arguments to find a McpAuth
     * @example
     * // Get one McpAuth
     * const mcpAuth = await prisma.mcpAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends McpAuthFindFirstArgs>(args?: SelectSubset<T, McpAuthFindFirstArgs<ExtArgs>>): Prisma__McpAuthClient<$Result.GetResult<Prisma.$McpAuthPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first McpAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McpAuthFindFirstOrThrowArgs} args - Arguments to find a McpAuth
     * @example
     * // Get one McpAuth
     * const mcpAuth = await prisma.mcpAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends McpAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, McpAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__McpAuthClient<$Result.GetResult<Prisma.$McpAuthPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more McpAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McpAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all McpAuths
     * const mcpAuths = await prisma.mcpAuth.findMany()
     * 
     * // Get first 10 McpAuths
     * const mcpAuths = await prisma.mcpAuth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mcpAuthWithIdOnly = await prisma.mcpAuth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends McpAuthFindManyArgs>(args?: SelectSubset<T, McpAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$McpAuthPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a McpAuth.
     * @param {McpAuthCreateArgs} args - Arguments to create a McpAuth.
     * @example
     * // Create one McpAuth
     * const McpAuth = await prisma.mcpAuth.create({
     *   data: {
     *     // ... data to create a McpAuth
     *   }
     * })
     * 
     */
    create<T extends McpAuthCreateArgs>(args: SelectSubset<T, McpAuthCreateArgs<ExtArgs>>): Prisma__McpAuthClient<$Result.GetResult<Prisma.$McpAuthPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many McpAuths.
     * @param {McpAuthCreateManyArgs} args - Arguments to create many McpAuths.
     * @example
     * // Create many McpAuths
     * const mcpAuth = await prisma.mcpAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends McpAuthCreateManyArgs>(args?: SelectSubset<T, McpAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a McpAuth.
     * @param {McpAuthDeleteArgs} args - Arguments to delete one McpAuth.
     * @example
     * // Delete one McpAuth
     * const McpAuth = await prisma.mcpAuth.delete({
     *   where: {
     *     // ... filter to delete one McpAuth
     *   }
     * })
     * 
     */
    delete<T extends McpAuthDeleteArgs>(args: SelectSubset<T, McpAuthDeleteArgs<ExtArgs>>): Prisma__McpAuthClient<$Result.GetResult<Prisma.$McpAuthPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one McpAuth.
     * @param {McpAuthUpdateArgs} args - Arguments to update one McpAuth.
     * @example
     * // Update one McpAuth
     * const mcpAuth = await prisma.mcpAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends McpAuthUpdateArgs>(args: SelectSubset<T, McpAuthUpdateArgs<ExtArgs>>): Prisma__McpAuthClient<$Result.GetResult<Prisma.$McpAuthPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more McpAuths.
     * @param {McpAuthDeleteManyArgs} args - Arguments to filter McpAuths to delete.
     * @example
     * // Delete a few McpAuths
     * const { count } = await prisma.mcpAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends McpAuthDeleteManyArgs>(args?: SelectSubset<T, McpAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more McpAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McpAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many McpAuths
     * const mcpAuth = await prisma.mcpAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends McpAuthUpdateManyArgs>(args: SelectSubset<T, McpAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one McpAuth.
     * @param {McpAuthUpsertArgs} args - Arguments to update or create a McpAuth.
     * @example
     * // Update or create a McpAuth
     * const mcpAuth = await prisma.mcpAuth.upsert({
     *   create: {
     *     // ... data to create a McpAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the McpAuth we want to update
     *   }
     * })
     */
    upsert<T extends McpAuthUpsertArgs>(args: SelectSubset<T, McpAuthUpsertArgs<ExtArgs>>): Prisma__McpAuthClient<$Result.GetResult<Prisma.$McpAuthPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of McpAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McpAuthCountArgs} args - Arguments to filter McpAuths to count.
     * @example
     * // Count the number of McpAuths
     * const count = await prisma.mcpAuth.count({
     *   where: {
     *     // ... the filter for the McpAuths we want to count
     *   }
     * })
    **/
    count<T extends McpAuthCountArgs>(
      args?: Subset<T, McpAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], McpAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a McpAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McpAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends McpAuthAggregateArgs>(args: Subset<T, McpAuthAggregateArgs>): Prisma.PrismaPromise<GetMcpAuthAggregateType<T>>

    /**
     * Group by McpAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McpAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends McpAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: McpAuthGroupByArgs['orderBy'] }
        : { orderBy?: McpAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, McpAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMcpAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the McpAuth model
   */
  readonly fields: McpAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for McpAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__McpAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the McpAuth model
   */ 
  interface McpAuthFieldRefs {
    readonly id: FieldRef<"McpAuth", 'Int'>
    readonly email: FieldRef<"McpAuth", 'String'>
    readonly codigo: FieldRef<"McpAuth", 'String'>
    readonly token: FieldRef<"McpAuth", 'String'>
    readonly expiresAt: FieldRef<"McpAuth", 'DateTime'>
    readonly createdAt: FieldRef<"McpAuth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * McpAuth findUnique
   */
  export type McpAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McpAuth
     */
    select?: McpAuthSelect<ExtArgs> | null
    /**
     * Filter, which McpAuth to fetch.
     */
    where: McpAuthWhereUniqueInput
  }

  /**
   * McpAuth findUniqueOrThrow
   */
  export type McpAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McpAuth
     */
    select?: McpAuthSelect<ExtArgs> | null
    /**
     * Filter, which McpAuth to fetch.
     */
    where: McpAuthWhereUniqueInput
  }

  /**
   * McpAuth findFirst
   */
  export type McpAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McpAuth
     */
    select?: McpAuthSelect<ExtArgs> | null
    /**
     * Filter, which McpAuth to fetch.
     */
    where?: McpAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of McpAuths to fetch.
     */
    orderBy?: McpAuthOrderByWithRelationInput | McpAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for McpAuths.
     */
    cursor?: McpAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` McpAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` McpAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of McpAuths.
     */
    distinct?: McpAuthScalarFieldEnum | McpAuthScalarFieldEnum[]
  }

  /**
   * McpAuth findFirstOrThrow
   */
  export type McpAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McpAuth
     */
    select?: McpAuthSelect<ExtArgs> | null
    /**
     * Filter, which McpAuth to fetch.
     */
    where?: McpAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of McpAuths to fetch.
     */
    orderBy?: McpAuthOrderByWithRelationInput | McpAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for McpAuths.
     */
    cursor?: McpAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` McpAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` McpAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of McpAuths.
     */
    distinct?: McpAuthScalarFieldEnum | McpAuthScalarFieldEnum[]
  }

  /**
   * McpAuth findMany
   */
  export type McpAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McpAuth
     */
    select?: McpAuthSelect<ExtArgs> | null
    /**
     * Filter, which McpAuths to fetch.
     */
    where?: McpAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of McpAuths to fetch.
     */
    orderBy?: McpAuthOrderByWithRelationInput | McpAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing McpAuths.
     */
    cursor?: McpAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` McpAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` McpAuths.
     */
    skip?: number
    distinct?: McpAuthScalarFieldEnum | McpAuthScalarFieldEnum[]
  }

  /**
   * McpAuth create
   */
  export type McpAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McpAuth
     */
    select?: McpAuthSelect<ExtArgs> | null
    /**
     * The data needed to create a McpAuth.
     */
    data: XOR<McpAuthCreateInput, McpAuthUncheckedCreateInput>
  }

  /**
   * McpAuth createMany
   */
  export type McpAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many McpAuths.
     */
    data: McpAuthCreateManyInput | McpAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * McpAuth update
   */
  export type McpAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McpAuth
     */
    select?: McpAuthSelect<ExtArgs> | null
    /**
     * The data needed to update a McpAuth.
     */
    data: XOR<McpAuthUpdateInput, McpAuthUncheckedUpdateInput>
    /**
     * Choose, which McpAuth to update.
     */
    where: McpAuthWhereUniqueInput
  }

  /**
   * McpAuth updateMany
   */
  export type McpAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update McpAuths.
     */
    data: XOR<McpAuthUpdateManyMutationInput, McpAuthUncheckedUpdateManyInput>
    /**
     * Filter which McpAuths to update
     */
    where?: McpAuthWhereInput
  }

  /**
   * McpAuth upsert
   */
  export type McpAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McpAuth
     */
    select?: McpAuthSelect<ExtArgs> | null
    /**
     * The filter to search for the McpAuth to update in case it exists.
     */
    where: McpAuthWhereUniqueInput
    /**
     * In case the McpAuth found by the `where` argument doesn't exist, create a new McpAuth with this data.
     */
    create: XOR<McpAuthCreateInput, McpAuthUncheckedCreateInput>
    /**
     * In case the McpAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<McpAuthUpdateInput, McpAuthUncheckedUpdateInput>
  }

  /**
   * McpAuth delete
   */
  export type McpAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McpAuth
     */
    select?: McpAuthSelect<ExtArgs> | null
    /**
     * Filter which McpAuth to delete.
     */
    where: McpAuthWhereUniqueInput
  }

  /**
   * McpAuth deleteMany
   */
  export type McpAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which McpAuths to delete
     */
    where?: McpAuthWhereInput
  }

  /**
   * McpAuth without action
   */
  export type McpAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McpAuth
     */
    select?: McpAuthSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    cedula: 'cedula',
    nombres: 'nombres',
    apellidos: 'apellidos',
    correoInstitucional: 'correoInstitucional',
    rol: 'rol',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const AuthScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    usuarioId: 'usuarioId'
  };

  export type AuthScalarFieldEnum = (typeof AuthScalarFieldEnum)[keyof typeof AuthScalarFieldEnum]


  export const AreaConocimientoScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    nombre: 'nombre',
    descripcion: 'descripcion'
  };

  export type AreaConocimientoScalarFieldEnum = (typeof AreaConocimientoScalarFieldEnum)[keyof typeof AreaConocimientoScalarFieldEnum]


  export const PropuestaScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    objetivos: 'objetivos',
    problematica: 'problematica',
    areaConocimientoId: 'areaConocimientoId',
    alcance: 'alcance',
    archivoUrl: 'archivoUrl',
    fechaPublicacion: 'fechaPublicacion',
    estado: 'estado',
    fkEstudiante: 'fkEstudiante',
    fechaDefensa: 'fechaDefensa',
    resultadoDefensa: 'resultadoDefensa'
  };

  export type PropuestaScalarFieldEnum = (typeof PropuestaScalarFieldEnum)[keyof typeof PropuestaScalarFieldEnum]


  export const TrabajoTitulacionScalarFieldEnum: {
    propuestasId: 'propuestasId',
    fkTutorId: 'fkTutorId'
  };

  export type TrabajoTitulacionScalarFieldEnum = (typeof TrabajoTitulacionScalarFieldEnum)[keyof typeof TrabajoTitulacionScalarFieldEnum]


  export const ActividadScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    propuestaId: 'propuestaId',
    tipo: 'tipo'
  };

  export type ActividadScalarFieldEnum = (typeof ActividadScalarFieldEnum)[keyof typeof ActividadScalarFieldEnum]


  export const EvidenciaScalarFieldEnum: {
    id: 'id',
    semana: 'semana',
    contenido: 'contenido',
    archivoUrl: 'archivoUrl',
    fechaEntrega: 'fechaEntrega',
    estado: 'estado',
    calificacion: 'calificacion',
    actividadId: 'actividadId'
  };

  export type EvidenciaScalarFieldEnum = (typeof EvidenciaScalarFieldEnum)[keyof typeof EvidenciaScalarFieldEnum]


  export const ComentarioScalarFieldEnum: {
    id: 'id',
    evidenciaId: 'evidenciaId',
    usuarioId: 'usuarioId',
    descripcion: 'descripcion'
  };

  export type ComentarioScalarFieldEnum = (typeof ComentarioScalarFieldEnum)[keyof typeof ComentarioScalarFieldEnum]


  export const CatalogoPrerequisitoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    orden: 'orden',
    activo: 'activo'
  };

  export type CatalogoPrerequisitoScalarFieldEnum = (typeof CatalogoPrerequisitoScalarFieldEnum)[keyof typeof CatalogoPrerequisitoScalarFieldEnum]


  export const EstudiantePrerequisitoScalarFieldEnum: {
    id: 'id',
    prerequisitoId: 'prerequisitoId',
    cumplido: 'cumplido',
    archivoUrl: 'archivoUrl',
    fechaCumplimiento: 'fechaCumplimiento',
    fkEstudiante: 'fkEstudiante'
  };

  export type EstudiantePrerequisitoScalarFieldEnum = (typeof EstudiantePrerequisitoScalarFieldEnum)[keyof typeof EstudiantePrerequisitoScalarFieldEnum]


  export const NotificacionScalarFieldEnum: {
    id: 'id',
    mensaje: 'mensaje',
    leido: 'leido',
    fechaCreacion: 'fechaCreacion',
    usuarioId: 'usuarioId'
  };

  export type NotificacionScalarFieldEnum = (typeof NotificacionScalarFieldEnum)[keyof typeof NotificacionScalarFieldEnum]


  export const EntregableFinalScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    urlArchivo: 'urlArchivo',
    fechaSubida: 'fechaSubida',
    propuestasId: 'propuestasId'
  };

  export type EntregableFinalScalarFieldEnum = (typeof EntregableFinalScalarFieldEnum)[keyof typeof EntregableFinalScalarFieldEnum]


  export const ComiteScalarFieldEnum: {
    usuarioId: 'usuarioId',
    propuestaId: 'propuestaId',
    rol: 'rol',
    calificacion: 'calificacion',
    fechaAsignada: 'fechaAsignada'
  };

  export type ComiteScalarFieldEnum = (typeof ComiteScalarFieldEnum)[keyof typeof ComiteScalarFieldEnum]


  export const EstudiantePerfilScalarFieldEnum: {
    id: 'id',
    sexo: 'sexo',
    estadoEscuela: 'estadoEscuela',
    sede: 'sede',
    escuela: 'escuela',
    codigoMalla: 'codigoMalla',
    malla: 'malla',
    periodoLectivo: 'periodoLectivo',
    ciudad: 'ciudad',
    provincia: 'provincia',
    pais: 'pais',
    usuarioId: 'usuarioId'
  };

  export type EstudiantePerfilScalarFieldEnum = (typeof EstudiantePerfilScalarFieldEnum)[keyof typeof EstudiantePerfilScalarFieldEnum]


  export const McpAuthScalarFieldEnum: {
    id: 'id',
    email: 'email',
    codigo: 'codigo',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type McpAuthScalarFieldEnum = (typeof McpAuthScalarFieldEnum)[keyof typeof McpAuthScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Rol'
   */
  export type EnumRolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Rol'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'EstadoPropuesta'
   */
  export type EnumEstadoPropuestaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoPropuesta'>
    


  /**
   * Reference to a field of type 'ResultadoDefensa'
   */
  export type EnumResultadoDefensaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResultadoDefensa'>
    


  /**
   * Reference to a field of type 'TipoActividad'
   */
  export type EnumTipoActividadFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoActividad'>
    


  /**
   * Reference to a field of type 'EstadoEvidencia'
   */
  export type EnumEstadoEvidenciaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoEvidencia'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'TipoEntregable'
   */
  export type EnumTipoEntregableFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoEntregable'>
    


  /**
   * Reference to a field of type 'RolComite'
   */
  export type EnumRolComiteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RolComite'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    cedula?: StringFilter<"Usuario"> | string
    nombres?: StringFilter<"Usuario"> | string
    apellidos?: StringFilter<"Usuario"> | string
    correoInstitucional?: StringFilter<"Usuario"> | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    auth?: XOR<AuthNullableRelationFilter, AuthWhereInput> | null
    propuestas?: PropuestaListRelationFilter
    comentarios?: ComentarioListRelationFilter
    notificaciones?: NotificacionListRelationFilter
    comites?: ComiteListRelationFilter
    prerequisitos?: EstudiantePrerequisitoListRelationFilter
    estudiantePerfil?: XOR<EstudiantePerfilNullableRelationFilter, EstudiantePerfilWhereInput> | null
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    correoInstitucional?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    auth?: AuthOrderByWithRelationInput
    propuestas?: PropuestaOrderByRelationAggregateInput
    comentarios?: ComentarioOrderByRelationAggregateInput
    notificaciones?: NotificacionOrderByRelationAggregateInput
    comites?: ComiteOrderByRelationAggregateInput
    prerequisitos?: EstudiantePrerequisitoOrderByRelationAggregateInput
    estudiantePerfil?: EstudiantePerfilOrderByWithRelationInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cedula?: string
    correoInstitucional?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombres?: StringFilter<"Usuario"> | string
    apellidos?: StringFilter<"Usuario"> | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    auth?: XOR<AuthNullableRelationFilter, AuthWhereInput> | null
    propuestas?: PropuestaListRelationFilter
    comentarios?: ComentarioListRelationFilter
    notificaciones?: NotificacionListRelationFilter
    comites?: ComiteListRelationFilter
    prerequisitos?: EstudiantePrerequisitoListRelationFilter
    estudiantePerfil?: XOR<EstudiantePerfilNullableRelationFilter, EstudiantePerfilWhereInput> | null
  }, "id" | "cedula" | "correoInstitucional">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    correoInstitucional?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    cedula?: StringWithAggregatesFilter<"Usuario"> | string
    nombres?: StringWithAggregatesFilter<"Usuario"> | string
    apellidos?: StringWithAggregatesFilter<"Usuario"> | string
    correoInstitucional?: StringWithAggregatesFilter<"Usuario"> | string
    rol?: EnumRolWithAggregatesFilter<"Usuario"> | $Enums.Rol
    createdAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
  }

  export type AuthWhereInput = {
    AND?: AuthWhereInput | AuthWhereInput[]
    OR?: AuthWhereInput[]
    NOT?: AuthWhereInput | AuthWhereInput[]
    id?: IntFilter<"Auth"> | number
    username?: StringFilter<"Auth"> | string
    password?: StringFilter<"Auth"> | string
    usuarioId?: IntFilter<"Auth"> | number
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type AuthOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    usuarioId?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type AuthWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    usuarioId?: number
    AND?: AuthWhereInput | AuthWhereInput[]
    OR?: AuthWhereInput[]
    NOT?: AuthWhereInput | AuthWhereInput[]
    password?: StringFilter<"Auth"> | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id" | "username" | "usuarioId">

  export type AuthOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    usuarioId?: SortOrder
    _count?: AuthCountOrderByAggregateInput
    _avg?: AuthAvgOrderByAggregateInput
    _max?: AuthMaxOrderByAggregateInput
    _min?: AuthMinOrderByAggregateInput
    _sum?: AuthSumOrderByAggregateInput
  }

  export type AuthScalarWhereWithAggregatesInput = {
    AND?: AuthScalarWhereWithAggregatesInput | AuthScalarWhereWithAggregatesInput[]
    OR?: AuthScalarWhereWithAggregatesInput[]
    NOT?: AuthScalarWhereWithAggregatesInput | AuthScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Auth"> | number
    username?: StringWithAggregatesFilter<"Auth"> | string
    password?: StringWithAggregatesFilter<"Auth"> | string
    usuarioId?: IntWithAggregatesFilter<"Auth"> | number
  }

  export type AreaConocimientoWhereInput = {
    AND?: AreaConocimientoWhereInput | AreaConocimientoWhereInput[]
    OR?: AreaConocimientoWhereInput[]
    NOT?: AreaConocimientoWhereInput | AreaConocimientoWhereInput[]
    id?: IntFilter<"AreaConocimiento"> | number
    codigo?: StringFilter<"AreaConocimiento"> | string
    nombre?: StringFilter<"AreaConocimiento"> | string
    descripcion?: StringNullableFilter<"AreaConocimiento"> | string | null
    propuestas?: PropuestaListRelationFilter
  }

  export type AreaConocimientoOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    propuestas?: PropuestaOrderByRelationAggregateInput
  }

  export type AreaConocimientoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    codigo?: string
    AND?: AreaConocimientoWhereInput | AreaConocimientoWhereInput[]
    OR?: AreaConocimientoWhereInput[]
    NOT?: AreaConocimientoWhereInput | AreaConocimientoWhereInput[]
    nombre?: StringFilter<"AreaConocimiento"> | string
    descripcion?: StringNullableFilter<"AreaConocimiento"> | string | null
    propuestas?: PropuestaListRelationFilter
  }, "id" | "codigo">

  export type AreaConocimientoOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    _count?: AreaConocimientoCountOrderByAggregateInput
    _avg?: AreaConocimientoAvgOrderByAggregateInput
    _max?: AreaConocimientoMaxOrderByAggregateInput
    _min?: AreaConocimientoMinOrderByAggregateInput
    _sum?: AreaConocimientoSumOrderByAggregateInput
  }

  export type AreaConocimientoScalarWhereWithAggregatesInput = {
    AND?: AreaConocimientoScalarWhereWithAggregatesInput | AreaConocimientoScalarWhereWithAggregatesInput[]
    OR?: AreaConocimientoScalarWhereWithAggregatesInput[]
    NOT?: AreaConocimientoScalarWhereWithAggregatesInput | AreaConocimientoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AreaConocimiento"> | number
    codigo?: StringWithAggregatesFilter<"AreaConocimiento"> | string
    nombre?: StringWithAggregatesFilter<"AreaConocimiento"> | string
    descripcion?: StringNullableWithAggregatesFilter<"AreaConocimiento"> | string | null
  }

  export type PropuestaWhereInput = {
    AND?: PropuestaWhereInput | PropuestaWhereInput[]
    OR?: PropuestaWhereInput[]
    NOT?: PropuestaWhereInput | PropuestaWhereInput[]
    id?: IntFilter<"Propuesta"> | number
    titulo?: StringFilter<"Propuesta"> | string
    objetivos?: StringFilter<"Propuesta"> | string
    problematica?: StringNullableFilter<"Propuesta"> | string | null
    areaConocimientoId?: IntFilter<"Propuesta"> | number
    alcance?: StringNullableFilter<"Propuesta"> | string | null
    archivoUrl?: StringNullableFilter<"Propuesta"> | string | null
    fechaPublicacion?: DateTimeFilter<"Propuesta"> | Date | string
    estado?: EnumEstadoPropuestaFilter<"Propuesta"> | $Enums.EstadoPropuesta
    fkEstudiante?: IntFilter<"Propuesta"> | number
    fechaDefensa?: DateTimeNullableFilter<"Propuesta"> | Date | string | null
    resultadoDefensa?: EnumResultadoDefensaNullableFilter<"Propuesta"> | $Enums.ResultadoDefensa | null
    areaConocimiento?: XOR<AreaConocimientoRelationFilter, AreaConocimientoWhereInput>
    estudiante?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    trabajosTitulacion?: TrabajoTitulacionListRelationFilter
    actividades?: ActividadListRelationFilter
    comites?: ComiteListRelationFilter
    entregablesFinales?: EntregableFinalListRelationFilter
  }

  export type PropuestaOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    objetivos?: SortOrder
    problematica?: SortOrderInput | SortOrder
    areaConocimientoId?: SortOrder
    alcance?: SortOrderInput | SortOrder
    archivoUrl?: SortOrderInput | SortOrder
    fechaPublicacion?: SortOrder
    estado?: SortOrder
    fkEstudiante?: SortOrder
    fechaDefensa?: SortOrderInput | SortOrder
    resultadoDefensa?: SortOrderInput | SortOrder
    areaConocimiento?: AreaConocimientoOrderByWithRelationInput
    estudiante?: UsuarioOrderByWithRelationInput
    trabajosTitulacion?: TrabajoTitulacionOrderByRelationAggregateInput
    actividades?: ActividadOrderByRelationAggregateInput
    comites?: ComiteOrderByRelationAggregateInput
    entregablesFinales?: EntregableFinalOrderByRelationAggregateInput
  }

  export type PropuestaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PropuestaWhereInput | PropuestaWhereInput[]
    OR?: PropuestaWhereInput[]
    NOT?: PropuestaWhereInput | PropuestaWhereInput[]
    titulo?: StringFilter<"Propuesta"> | string
    objetivos?: StringFilter<"Propuesta"> | string
    problematica?: StringNullableFilter<"Propuesta"> | string | null
    areaConocimientoId?: IntFilter<"Propuesta"> | number
    alcance?: StringNullableFilter<"Propuesta"> | string | null
    archivoUrl?: StringNullableFilter<"Propuesta"> | string | null
    fechaPublicacion?: DateTimeFilter<"Propuesta"> | Date | string
    estado?: EnumEstadoPropuestaFilter<"Propuesta"> | $Enums.EstadoPropuesta
    fkEstudiante?: IntFilter<"Propuesta"> | number
    fechaDefensa?: DateTimeNullableFilter<"Propuesta"> | Date | string | null
    resultadoDefensa?: EnumResultadoDefensaNullableFilter<"Propuesta"> | $Enums.ResultadoDefensa | null
    areaConocimiento?: XOR<AreaConocimientoRelationFilter, AreaConocimientoWhereInput>
    estudiante?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    trabajosTitulacion?: TrabajoTitulacionListRelationFilter
    actividades?: ActividadListRelationFilter
    comites?: ComiteListRelationFilter
    entregablesFinales?: EntregableFinalListRelationFilter
  }, "id">

  export type PropuestaOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    objetivos?: SortOrder
    problematica?: SortOrderInput | SortOrder
    areaConocimientoId?: SortOrder
    alcance?: SortOrderInput | SortOrder
    archivoUrl?: SortOrderInput | SortOrder
    fechaPublicacion?: SortOrder
    estado?: SortOrder
    fkEstudiante?: SortOrder
    fechaDefensa?: SortOrderInput | SortOrder
    resultadoDefensa?: SortOrderInput | SortOrder
    _count?: PropuestaCountOrderByAggregateInput
    _avg?: PropuestaAvgOrderByAggregateInput
    _max?: PropuestaMaxOrderByAggregateInput
    _min?: PropuestaMinOrderByAggregateInput
    _sum?: PropuestaSumOrderByAggregateInput
  }

  export type PropuestaScalarWhereWithAggregatesInput = {
    AND?: PropuestaScalarWhereWithAggregatesInput | PropuestaScalarWhereWithAggregatesInput[]
    OR?: PropuestaScalarWhereWithAggregatesInput[]
    NOT?: PropuestaScalarWhereWithAggregatesInput | PropuestaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Propuesta"> | number
    titulo?: StringWithAggregatesFilter<"Propuesta"> | string
    objetivos?: StringWithAggregatesFilter<"Propuesta"> | string
    problematica?: StringNullableWithAggregatesFilter<"Propuesta"> | string | null
    areaConocimientoId?: IntWithAggregatesFilter<"Propuesta"> | number
    alcance?: StringNullableWithAggregatesFilter<"Propuesta"> | string | null
    archivoUrl?: StringNullableWithAggregatesFilter<"Propuesta"> | string | null
    fechaPublicacion?: DateTimeWithAggregatesFilter<"Propuesta"> | Date | string
    estado?: EnumEstadoPropuestaWithAggregatesFilter<"Propuesta"> | $Enums.EstadoPropuesta
    fkEstudiante?: IntWithAggregatesFilter<"Propuesta"> | number
    fechaDefensa?: DateTimeNullableWithAggregatesFilter<"Propuesta"> | Date | string | null
    resultadoDefensa?: EnumResultadoDefensaNullableWithAggregatesFilter<"Propuesta"> | $Enums.ResultadoDefensa | null
  }

  export type TrabajoTitulacionWhereInput = {
    AND?: TrabajoTitulacionWhereInput | TrabajoTitulacionWhereInput[]
    OR?: TrabajoTitulacionWhereInput[]
    NOT?: TrabajoTitulacionWhereInput | TrabajoTitulacionWhereInput[]
    propuestasId?: IntFilter<"TrabajoTitulacion"> | number
    fkTutorId?: IntFilter<"TrabajoTitulacion"> | number
    propuesta?: XOR<PropuestaRelationFilter, PropuestaWhereInput>
  }

  export type TrabajoTitulacionOrderByWithRelationInput = {
    propuestasId?: SortOrder
    fkTutorId?: SortOrder
    propuesta?: PropuestaOrderByWithRelationInput
  }

  export type TrabajoTitulacionWhereUniqueInput = Prisma.AtLeast<{
    propuestasId_fkTutorId?: TrabajoTitulacionPropuestasIdFkTutorIdCompoundUniqueInput
    AND?: TrabajoTitulacionWhereInput | TrabajoTitulacionWhereInput[]
    OR?: TrabajoTitulacionWhereInput[]
    NOT?: TrabajoTitulacionWhereInput | TrabajoTitulacionWhereInput[]
    propuestasId?: IntFilter<"TrabajoTitulacion"> | number
    fkTutorId?: IntFilter<"TrabajoTitulacion"> | number
    propuesta?: XOR<PropuestaRelationFilter, PropuestaWhereInput>
  }, "propuestasId_fkTutorId">

  export type TrabajoTitulacionOrderByWithAggregationInput = {
    propuestasId?: SortOrder
    fkTutorId?: SortOrder
    _count?: TrabajoTitulacionCountOrderByAggregateInput
    _avg?: TrabajoTitulacionAvgOrderByAggregateInput
    _max?: TrabajoTitulacionMaxOrderByAggregateInput
    _min?: TrabajoTitulacionMinOrderByAggregateInput
    _sum?: TrabajoTitulacionSumOrderByAggregateInput
  }

  export type TrabajoTitulacionScalarWhereWithAggregatesInput = {
    AND?: TrabajoTitulacionScalarWhereWithAggregatesInput | TrabajoTitulacionScalarWhereWithAggregatesInput[]
    OR?: TrabajoTitulacionScalarWhereWithAggregatesInput[]
    NOT?: TrabajoTitulacionScalarWhereWithAggregatesInput | TrabajoTitulacionScalarWhereWithAggregatesInput[]
    propuestasId?: IntWithAggregatesFilter<"TrabajoTitulacion"> | number
    fkTutorId?: IntWithAggregatesFilter<"TrabajoTitulacion"> | number
  }

  export type ActividadWhereInput = {
    AND?: ActividadWhereInput | ActividadWhereInput[]
    OR?: ActividadWhereInput[]
    NOT?: ActividadWhereInput | ActividadWhereInput[]
    id?: IntFilter<"Actividad"> | number
    nombre?: StringFilter<"Actividad"> | string
    descripcion?: StringNullableFilter<"Actividad"> | string | null
    propuestaId?: IntFilter<"Actividad"> | number
    tipo?: EnumTipoActividadFilter<"Actividad"> | $Enums.TipoActividad
    propuesta?: XOR<PropuestaRelationFilter, PropuestaWhereInput>
    evidencias?: EvidenciaListRelationFilter
  }

  export type ActividadOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    propuestaId?: SortOrder
    tipo?: SortOrder
    propuesta?: PropuestaOrderByWithRelationInput
    evidencias?: EvidenciaOrderByRelationAggregateInput
  }

  export type ActividadWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ActividadWhereInput | ActividadWhereInput[]
    OR?: ActividadWhereInput[]
    NOT?: ActividadWhereInput | ActividadWhereInput[]
    nombre?: StringFilter<"Actividad"> | string
    descripcion?: StringNullableFilter<"Actividad"> | string | null
    propuestaId?: IntFilter<"Actividad"> | number
    tipo?: EnumTipoActividadFilter<"Actividad"> | $Enums.TipoActividad
    propuesta?: XOR<PropuestaRelationFilter, PropuestaWhereInput>
    evidencias?: EvidenciaListRelationFilter
  }, "id">

  export type ActividadOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    propuestaId?: SortOrder
    tipo?: SortOrder
    _count?: ActividadCountOrderByAggregateInput
    _avg?: ActividadAvgOrderByAggregateInput
    _max?: ActividadMaxOrderByAggregateInput
    _min?: ActividadMinOrderByAggregateInput
    _sum?: ActividadSumOrderByAggregateInput
  }

  export type ActividadScalarWhereWithAggregatesInput = {
    AND?: ActividadScalarWhereWithAggregatesInput | ActividadScalarWhereWithAggregatesInput[]
    OR?: ActividadScalarWhereWithAggregatesInput[]
    NOT?: ActividadScalarWhereWithAggregatesInput | ActividadScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Actividad"> | number
    nombre?: StringWithAggregatesFilter<"Actividad"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Actividad"> | string | null
    propuestaId?: IntWithAggregatesFilter<"Actividad"> | number
    tipo?: EnumTipoActividadWithAggregatesFilter<"Actividad"> | $Enums.TipoActividad
  }

  export type EvidenciaWhereInput = {
    AND?: EvidenciaWhereInput | EvidenciaWhereInput[]
    OR?: EvidenciaWhereInput[]
    NOT?: EvidenciaWhereInput | EvidenciaWhereInput[]
    id?: IntFilter<"Evidencia"> | number
    semana?: IntFilter<"Evidencia"> | number
    contenido?: StringFilter<"Evidencia"> | string
    archivoUrl?: StringNullableFilter<"Evidencia"> | string | null
    fechaEntrega?: DateTimeFilter<"Evidencia"> | Date | string
    estado?: EnumEstadoEvidenciaFilter<"Evidencia"> | $Enums.EstadoEvidencia
    calificacion?: DecimalNullableFilter<"Evidencia"> | Decimal | DecimalJsLike | number | string | null
    actividadId?: IntFilter<"Evidencia"> | number
    actividad?: XOR<ActividadRelationFilter, ActividadWhereInput>
    comentarios?: ComentarioListRelationFilter
  }

  export type EvidenciaOrderByWithRelationInput = {
    id?: SortOrder
    semana?: SortOrder
    contenido?: SortOrder
    archivoUrl?: SortOrderInput | SortOrder
    fechaEntrega?: SortOrder
    estado?: SortOrder
    calificacion?: SortOrderInput | SortOrder
    actividadId?: SortOrder
    actividad?: ActividadOrderByWithRelationInput
    comentarios?: ComentarioOrderByRelationAggregateInput
  }

  export type EvidenciaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EvidenciaWhereInput | EvidenciaWhereInput[]
    OR?: EvidenciaWhereInput[]
    NOT?: EvidenciaWhereInput | EvidenciaWhereInput[]
    semana?: IntFilter<"Evidencia"> | number
    contenido?: StringFilter<"Evidencia"> | string
    archivoUrl?: StringNullableFilter<"Evidencia"> | string | null
    fechaEntrega?: DateTimeFilter<"Evidencia"> | Date | string
    estado?: EnumEstadoEvidenciaFilter<"Evidencia"> | $Enums.EstadoEvidencia
    calificacion?: DecimalNullableFilter<"Evidencia"> | Decimal | DecimalJsLike | number | string | null
    actividadId?: IntFilter<"Evidencia"> | number
    actividad?: XOR<ActividadRelationFilter, ActividadWhereInput>
    comentarios?: ComentarioListRelationFilter
  }, "id">

  export type EvidenciaOrderByWithAggregationInput = {
    id?: SortOrder
    semana?: SortOrder
    contenido?: SortOrder
    archivoUrl?: SortOrderInput | SortOrder
    fechaEntrega?: SortOrder
    estado?: SortOrder
    calificacion?: SortOrderInput | SortOrder
    actividadId?: SortOrder
    _count?: EvidenciaCountOrderByAggregateInput
    _avg?: EvidenciaAvgOrderByAggregateInput
    _max?: EvidenciaMaxOrderByAggregateInput
    _min?: EvidenciaMinOrderByAggregateInput
    _sum?: EvidenciaSumOrderByAggregateInput
  }

  export type EvidenciaScalarWhereWithAggregatesInput = {
    AND?: EvidenciaScalarWhereWithAggregatesInput | EvidenciaScalarWhereWithAggregatesInput[]
    OR?: EvidenciaScalarWhereWithAggregatesInput[]
    NOT?: EvidenciaScalarWhereWithAggregatesInput | EvidenciaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Evidencia"> | number
    semana?: IntWithAggregatesFilter<"Evidencia"> | number
    contenido?: StringWithAggregatesFilter<"Evidencia"> | string
    archivoUrl?: StringNullableWithAggregatesFilter<"Evidencia"> | string | null
    fechaEntrega?: DateTimeWithAggregatesFilter<"Evidencia"> | Date | string
    estado?: EnumEstadoEvidenciaWithAggregatesFilter<"Evidencia"> | $Enums.EstadoEvidencia
    calificacion?: DecimalNullableWithAggregatesFilter<"Evidencia"> | Decimal | DecimalJsLike | number | string | null
    actividadId?: IntWithAggregatesFilter<"Evidencia"> | number
  }

  export type ComentarioWhereInput = {
    AND?: ComentarioWhereInput | ComentarioWhereInput[]
    OR?: ComentarioWhereInput[]
    NOT?: ComentarioWhereInput | ComentarioWhereInput[]
    id?: IntFilter<"Comentario"> | number
    evidenciaId?: IntFilter<"Comentario"> | number
    usuarioId?: IntFilter<"Comentario"> | number
    descripcion?: StringNullableFilter<"Comentario"> | string | null
    evidencia?: XOR<EvidenciaRelationFilter, EvidenciaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type ComentarioOrderByWithRelationInput = {
    id?: SortOrder
    evidenciaId?: SortOrder
    usuarioId?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    evidencia?: EvidenciaOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type ComentarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComentarioWhereInput | ComentarioWhereInput[]
    OR?: ComentarioWhereInput[]
    NOT?: ComentarioWhereInput | ComentarioWhereInput[]
    evidenciaId?: IntFilter<"Comentario"> | number
    usuarioId?: IntFilter<"Comentario"> | number
    descripcion?: StringNullableFilter<"Comentario"> | string | null
    evidencia?: XOR<EvidenciaRelationFilter, EvidenciaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id">

  export type ComentarioOrderByWithAggregationInput = {
    id?: SortOrder
    evidenciaId?: SortOrder
    usuarioId?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    _count?: ComentarioCountOrderByAggregateInput
    _avg?: ComentarioAvgOrderByAggregateInput
    _max?: ComentarioMaxOrderByAggregateInput
    _min?: ComentarioMinOrderByAggregateInput
    _sum?: ComentarioSumOrderByAggregateInput
  }

  export type ComentarioScalarWhereWithAggregatesInput = {
    AND?: ComentarioScalarWhereWithAggregatesInput | ComentarioScalarWhereWithAggregatesInput[]
    OR?: ComentarioScalarWhereWithAggregatesInput[]
    NOT?: ComentarioScalarWhereWithAggregatesInput | ComentarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comentario"> | number
    evidenciaId?: IntWithAggregatesFilter<"Comentario"> | number
    usuarioId?: IntWithAggregatesFilter<"Comentario"> | number
    descripcion?: StringNullableWithAggregatesFilter<"Comentario"> | string | null
  }

  export type CatalogoPrerequisitoWhereInput = {
    AND?: CatalogoPrerequisitoWhereInput | CatalogoPrerequisitoWhereInput[]
    OR?: CatalogoPrerequisitoWhereInput[]
    NOT?: CatalogoPrerequisitoWhereInput | CatalogoPrerequisitoWhereInput[]
    id?: IntFilter<"CatalogoPrerequisito"> | number
    nombre?: StringFilter<"CatalogoPrerequisito"> | string
    descripcion?: StringNullableFilter<"CatalogoPrerequisito"> | string | null
    orden?: IntFilter<"CatalogoPrerequisito"> | number
    activo?: BoolFilter<"CatalogoPrerequisito"> | boolean
    estudiantePrerequisitos?: EstudiantePrerequisitoListRelationFilter
  }

  export type CatalogoPrerequisitoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    orden?: SortOrder
    activo?: SortOrder
    estudiantePrerequisitos?: EstudiantePrerequisitoOrderByRelationAggregateInput
  }

  export type CatalogoPrerequisitoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CatalogoPrerequisitoWhereInput | CatalogoPrerequisitoWhereInput[]
    OR?: CatalogoPrerequisitoWhereInput[]
    NOT?: CatalogoPrerequisitoWhereInput | CatalogoPrerequisitoWhereInput[]
    nombre?: StringFilter<"CatalogoPrerequisito"> | string
    descripcion?: StringNullableFilter<"CatalogoPrerequisito"> | string | null
    orden?: IntFilter<"CatalogoPrerequisito"> | number
    activo?: BoolFilter<"CatalogoPrerequisito"> | boolean
    estudiantePrerequisitos?: EstudiantePrerequisitoListRelationFilter
  }, "id">

  export type CatalogoPrerequisitoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    orden?: SortOrder
    activo?: SortOrder
    _count?: CatalogoPrerequisitoCountOrderByAggregateInput
    _avg?: CatalogoPrerequisitoAvgOrderByAggregateInput
    _max?: CatalogoPrerequisitoMaxOrderByAggregateInput
    _min?: CatalogoPrerequisitoMinOrderByAggregateInput
    _sum?: CatalogoPrerequisitoSumOrderByAggregateInput
  }

  export type CatalogoPrerequisitoScalarWhereWithAggregatesInput = {
    AND?: CatalogoPrerequisitoScalarWhereWithAggregatesInput | CatalogoPrerequisitoScalarWhereWithAggregatesInput[]
    OR?: CatalogoPrerequisitoScalarWhereWithAggregatesInput[]
    NOT?: CatalogoPrerequisitoScalarWhereWithAggregatesInput | CatalogoPrerequisitoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CatalogoPrerequisito"> | number
    nombre?: StringWithAggregatesFilter<"CatalogoPrerequisito"> | string
    descripcion?: StringNullableWithAggregatesFilter<"CatalogoPrerequisito"> | string | null
    orden?: IntWithAggregatesFilter<"CatalogoPrerequisito"> | number
    activo?: BoolWithAggregatesFilter<"CatalogoPrerequisito"> | boolean
  }

  export type EstudiantePrerequisitoWhereInput = {
    AND?: EstudiantePrerequisitoWhereInput | EstudiantePrerequisitoWhereInput[]
    OR?: EstudiantePrerequisitoWhereInput[]
    NOT?: EstudiantePrerequisitoWhereInput | EstudiantePrerequisitoWhereInput[]
    id?: IntFilter<"EstudiantePrerequisito"> | number
    prerequisitoId?: IntFilter<"EstudiantePrerequisito"> | number
    cumplido?: BoolFilter<"EstudiantePrerequisito"> | boolean
    archivoUrl?: StringNullableFilter<"EstudiantePrerequisito"> | string | null
    fechaCumplimiento?: DateTimeNullableFilter<"EstudiantePrerequisito"> | Date | string | null
    fkEstudiante?: IntFilter<"EstudiantePrerequisito"> | number
    prerequisito?: XOR<CatalogoPrerequisitoRelationFilter, CatalogoPrerequisitoWhereInput>
    estudiante?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type EstudiantePrerequisitoOrderByWithRelationInput = {
    id?: SortOrder
    prerequisitoId?: SortOrder
    cumplido?: SortOrder
    archivoUrl?: SortOrderInput | SortOrder
    fechaCumplimiento?: SortOrderInput | SortOrder
    fkEstudiante?: SortOrder
    prerequisito?: CatalogoPrerequisitoOrderByWithRelationInput
    estudiante?: UsuarioOrderByWithRelationInput
  }

  export type EstudiantePrerequisitoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    fkEstudiante_prerequisitoId?: EstudiantePrerequisitoFkEstudiantePrerequisitoIdCompoundUniqueInput
    AND?: EstudiantePrerequisitoWhereInput | EstudiantePrerequisitoWhereInput[]
    OR?: EstudiantePrerequisitoWhereInput[]
    NOT?: EstudiantePrerequisitoWhereInput | EstudiantePrerequisitoWhereInput[]
    prerequisitoId?: IntFilter<"EstudiantePrerequisito"> | number
    cumplido?: BoolFilter<"EstudiantePrerequisito"> | boolean
    archivoUrl?: StringNullableFilter<"EstudiantePrerequisito"> | string | null
    fechaCumplimiento?: DateTimeNullableFilter<"EstudiantePrerequisito"> | Date | string | null
    fkEstudiante?: IntFilter<"EstudiantePrerequisito"> | number
    prerequisito?: XOR<CatalogoPrerequisitoRelationFilter, CatalogoPrerequisitoWhereInput>
    estudiante?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id" | "fkEstudiante_prerequisitoId">

  export type EstudiantePrerequisitoOrderByWithAggregationInput = {
    id?: SortOrder
    prerequisitoId?: SortOrder
    cumplido?: SortOrder
    archivoUrl?: SortOrderInput | SortOrder
    fechaCumplimiento?: SortOrderInput | SortOrder
    fkEstudiante?: SortOrder
    _count?: EstudiantePrerequisitoCountOrderByAggregateInput
    _avg?: EstudiantePrerequisitoAvgOrderByAggregateInput
    _max?: EstudiantePrerequisitoMaxOrderByAggregateInput
    _min?: EstudiantePrerequisitoMinOrderByAggregateInput
    _sum?: EstudiantePrerequisitoSumOrderByAggregateInput
  }

  export type EstudiantePrerequisitoScalarWhereWithAggregatesInput = {
    AND?: EstudiantePrerequisitoScalarWhereWithAggregatesInput | EstudiantePrerequisitoScalarWhereWithAggregatesInput[]
    OR?: EstudiantePrerequisitoScalarWhereWithAggregatesInput[]
    NOT?: EstudiantePrerequisitoScalarWhereWithAggregatesInput | EstudiantePrerequisitoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EstudiantePrerequisito"> | number
    prerequisitoId?: IntWithAggregatesFilter<"EstudiantePrerequisito"> | number
    cumplido?: BoolWithAggregatesFilter<"EstudiantePrerequisito"> | boolean
    archivoUrl?: StringNullableWithAggregatesFilter<"EstudiantePrerequisito"> | string | null
    fechaCumplimiento?: DateTimeNullableWithAggregatesFilter<"EstudiantePrerequisito"> | Date | string | null
    fkEstudiante?: IntWithAggregatesFilter<"EstudiantePrerequisito"> | number
  }

  export type NotificacionWhereInput = {
    AND?: NotificacionWhereInput | NotificacionWhereInput[]
    OR?: NotificacionWhereInput[]
    NOT?: NotificacionWhereInput | NotificacionWhereInput[]
    id?: IntFilter<"Notificacion"> | number
    mensaje?: StringFilter<"Notificacion"> | string
    leido?: BoolFilter<"Notificacion"> | boolean
    fechaCreacion?: DateTimeFilter<"Notificacion"> | Date | string
    usuarioId?: IntFilter<"Notificacion"> | number
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type NotificacionOrderByWithRelationInput = {
    id?: SortOrder
    mensaje?: SortOrder
    leido?: SortOrder
    fechaCreacion?: SortOrder
    usuarioId?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type NotificacionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificacionWhereInput | NotificacionWhereInput[]
    OR?: NotificacionWhereInput[]
    NOT?: NotificacionWhereInput | NotificacionWhereInput[]
    mensaje?: StringFilter<"Notificacion"> | string
    leido?: BoolFilter<"Notificacion"> | boolean
    fechaCreacion?: DateTimeFilter<"Notificacion"> | Date | string
    usuarioId?: IntFilter<"Notificacion"> | number
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id">

  export type NotificacionOrderByWithAggregationInput = {
    id?: SortOrder
    mensaje?: SortOrder
    leido?: SortOrder
    fechaCreacion?: SortOrder
    usuarioId?: SortOrder
    _count?: NotificacionCountOrderByAggregateInput
    _avg?: NotificacionAvgOrderByAggregateInput
    _max?: NotificacionMaxOrderByAggregateInput
    _min?: NotificacionMinOrderByAggregateInput
    _sum?: NotificacionSumOrderByAggregateInput
  }

  export type NotificacionScalarWhereWithAggregatesInput = {
    AND?: NotificacionScalarWhereWithAggregatesInput | NotificacionScalarWhereWithAggregatesInput[]
    OR?: NotificacionScalarWhereWithAggregatesInput[]
    NOT?: NotificacionScalarWhereWithAggregatesInput | NotificacionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notificacion"> | number
    mensaje?: StringWithAggregatesFilter<"Notificacion"> | string
    leido?: BoolWithAggregatesFilter<"Notificacion"> | boolean
    fechaCreacion?: DateTimeWithAggregatesFilter<"Notificacion"> | Date | string
    usuarioId?: IntWithAggregatesFilter<"Notificacion"> | number
  }

  export type EntregableFinalWhereInput = {
    AND?: EntregableFinalWhereInput | EntregableFinalWhereInput[]
    OR?: EntregableFinalWhereInput[]
    NOT?: EntregableFinalWhereInput | EntregableFinalWhereInput[]
    id?: IntFilter<"EntregableFinal"> | number
    tipo?: EnumTipoEntregableFilter<"EntregableFinal"> | $Enums.TipoEntregable
    urlArchivo?: StringFilter<"EntregableFinal"> | string
    fechaSubida?: DateTimeFilter<"EntregableFinal"> | Date | string
    propuestasId?: IntFilter<"EntregableFinal"> | number
    propuesta?: XOR<PropuestaRelationFilter, PropuestaWhereInput>
  }

  export type EntregableFinalOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    urlArchivo?: SortOrder
    fechaSubida?: SortOrder
    propuestasId?: SortOrder
    propuesta?: PropuestaOrderByWithRelationInput
  }

  export type EntregableFinalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EntregableFinalWhereInput | EntregableFinalWhereInput[]
    OR?: EntregableFinalWhereInput[]
    NOT?: EntregableFinalWhereInput | EntregableFinalWhereInput[]
    tipo?: EnumTipoEntregableFilter<"EntregableFinal"> | $Enums.TipoEntregable
    urlArchivo?: StringFilter<"EntregableFinal"> | string
    fechaSubida?: DateTimeFilter<"EntregableFinal"> | Date | string
    propuestasId?: IntFilter<"EntregableFinal"> | number
    propuesta?: XOR<PropuestaRelationFilter, PropuestaWhereInput>
  }, "id">

  export type EntregableFinalOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    urlArchivo?: SortOrder
    fechaSubida?: SortOrder
    propuestasId?: SortOrder
    _count?: EntregableFinalCountOrderByAggregateInput
    _avg?: EntregableFinalAvgOrderByAggregateInput
    _max?: EntregableFinalMaxOrderByAggregateInput
    _min?: EntregableFinalMinOrderByAggregateInput
    _sum?: EntregableFinalSumOrderByAggregateInput
  }

  export type EntregableFinalScalarWhereWithAggregatesInput = {
    AND?: EntregableFinalScalarWhereWithAggregatesInput | EntregableFinalScalarWhereWithAggregatesInput[]
    OR?: EntregableFinalScalarWhereWithAggregatesInput[]
    NOT?: EntregableFinalScalarWhereWithAggregatesInput | EntregableFinalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EntregableFinal"> | number
    tipo?: EnumTipoEntregableWithAggregatesFilter<"EntregableFinal"> | $Enums.TipoEntregable
    urlArchivo?: StringWithAggregatesFilter<"EntregableFinal"> | string
    fechaSubida?: DateTimeWithAggregatesFilter<"EntregableFinal"> | Date | string
    propuestasId?: IntWithAggregatesFilter<"EntregableFinal"> | number
  }

  export type ComiteWhereInput = {
    AND?: ComiteWhereInput | ComiteWhereInput[]
    OR?: ComiteWhereInput[]
    NOT?: ComiteWhereInput | ComiteWhereInput[]
    usuarioId?: IntFilter<"Comite"> | number
    propuestaId?: IntFilter<"Comite"> | number
    rol?: EnumRolComiteFilter<"Comite"> | $Enums.RolComite
    calificacion?: DecimalNullableFilter<"Comite"> | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: DateTimeNullableFilter<"Comite"> | Date | string | null
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    propuesta?: XOR<PropuestaRelationFilter, PropuestaWhereInput>
  }

  export type ComiteOrderByWithRelationInput = {
    usuarioId?: SortOrder
    propuestaId?: SortOrder
    rol?: SortOrder
    calificacion?: SortOrderInput | SortOrder
    fechaAsignada?: SortOrderInput | SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    propuesta?: PropuestaOrderByWithRelationInput
  }

  export type ComiteWhereUniqueInput = Prisma.AtLeast<{
    usuarioId_propuestaId?: ComiteUsuarioIdPropuestaIdCompoundUniqueInput
    AND?: ComiteWhereInput | ComiteWhereInput[]
    OR?: ComiteWhereInput[]
    NOT?: ComiteWhereInput | ComiteWhereInput[]
    usuarioId?: IntFilter<"Comite"> | number
    propuestaId?: IntFilter<"Comite"> | number
    rol?: EnumRolComiteFilter<"Comite"> | $Enums.RolComite
    calificacion?: DecimalNullableFilter<"Comite"> | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: DateTimeNullableFilter<"Comite"> | Date | string | null
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    propuesta?: XOR<PropuestaRelationFilter, PropuestaWhereInput>
  }, "usuarioId_propuestaId">

  export type ComiteOrderByWithAggregationInput = {
    usuarioId?: SortOrder
    propuestaId?: SortOrder
    rol?: SortOrder
    calificacion?: SortOrderInput | SortOrder
    fechaAsignada?: SortOrderInput | SortOrder
    _count?: ComiteCountOrderByAggregateInput
    _avg?: ComiteAvgOrderByAggregateInput
    _max?: ComiteMaxOrderByAggregateInput
    _min?: ComiteMinOrderByAggregateInput
    _sum?: ComiteSumOrderByAggregateInput
  }

  export type ComiteScalarWhereWithAggregatesInput = {
    AND?: ComiteScalarWhereWithAggregatesInput | ComiteScalarWhereWithAggregatesInput[]
    OR?: ComiteScalarWhereWithAggregatesInput[]
    NOT?: ComiteScalarWhereWithAggregatesInput | ComiteScalarWhereWithAggregatesInput[]
    usuarioId?: IntWithAggregatesFilter<"Comite"> | number
    propuestaId?: IntWithAggregatesFilter<"Comite"> | number
    rol?: EnumRolComiteWithAggregatesFilter<"Comite"> | $Enums.RolComite
    calificacion?: DecimalNullableWithAggregatesFilter<"Comite"> | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: DateTimeNullableWithAggregatesFilter<"Comite"> | Date | string | null
  }

  export type EstudiantePerfilWhereInput = {
    AND?: EstudiantePerfilWhereInput | EstudiantePerfilWhereInput[]
    OR?: EstudiantePerfilWhereInput[]
    NOT?: EstudiantePerfilWhereInput | EstudiantePerfilWhereInput[]
    id?: IntFilter<"EstudiantePerfil"> | number
    sexo?: StringNullableFilter<"EstudiantePerfil"> | string | null
    estadoEscuela?: StringNullableFilter<"EstudiantePerfil"> | string | null
    sede?: StringNullableFilter<"EstudiantePerfil"> | string | null
    escuela?: StringNullableFilter<"EstudiantePerfil"> | string | null
    codigoMalla?: StringNullableFilter<"EstudiantePerfil"> | string | null
    malla?: StringNullableFilter<"EstudiantePerfil"> | string | null
    periodoLectivo?: StringNullableFilter<"EstudiantePerfil"> | string | null
    ciudad?: StringNullableFilter<"EstudiantePerfil"> | string | null
    provincia?: StringNullableFilter<"EstudiantePerfil"> | string | null
    pais?: StringNullableFilter<"EstudiantePerfil"> | string | null
    usuarioId?: IntFilter<"EstudiantePerfil"> | number
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type EstudiantePerfilOrderByWithRelationInput = {
    id?: SortOrder
    sexo?: SortOrderInput | SortOrder
    estadoEscuela?: SortOrderInput | SortOrder
    sede?: SortOrderInput | SortOrder
    escuela?: SortOrderInput | SortOrder
    codigoMalla?: SortOrderInput | SortOrder
    malla?: SortOrderInput | SortOrder
    periodoLectivo?: SortOrderInput | SortOrder
    ciudad?: SortOrderInput | SortOrder
    provincia?: SortOrderInput | SortOrder
    pais?: SortOrderInput | SortOrder
    usuarioId?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type EstudiantePerfilWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    usuarioId?: number
    AND?: EstudiantePerfilWhereInput | EstudiantePerfilWhereInput[]
    OR?: EstudiantePerfilWhereInput[]
    NOT?: EstudiantePerfilWhereInput | EstudiantePerfilWhereInput[]
    sexo?: StringNullableFilter<"EstudiantePerfil"> | string | null
    estadoEscuela?: StringNullableFilter<"EstudiantePerfil"> | string | null
    sede?: StringNullableFilter<"EstudiantePerfil"> | string | null
    escuela?: StringNullableFilter<"EstudiantePerfil"> | string | null
    codigoMalla?: StringNullableFilter<"EstudiantePerfil"> | string | null
    malla?: StringNullableFilter<"EstudiantePerfil"> | string | null
    periodoLectivo?: StringNullableFilter<"EstudiantePerfil"> | string | null
    ciudad?: StringNullableFilter<"EstudiantePerfil"> | string | null
    provincia?: StringNullableFilter<"EstudiantePerfil"> | string | null
    pais?: StringNullableFilter<"EstudiantePerfil"> | string | null
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id" | "usuarioId">

  export type EstudiantePerfilOrderByWithAggregationInput = {
    id?: SortOrder
    sexo?: SortOrderInput | SortOrder
    estadoEscuela?: SortOrderInput | SortOrder
    sede?: SortOrderInput | SortOrder
    escuela?: SortOrderInput | SortOrder
    codigoMalla?: SortOrderInput | SortOrder
    malla?: SortOrderInput | SortOrder
    periodoLectivo?: SortOrderInput | SortOrder
    ciudad?: SortOrderInput | SortOrder
    provincia?: SortOrderInput | SortOrder
    pais?: SortOrderInput | SortOrder
    usuarioId?: SortOrder
    _count?: EstudiantePerfilCountOrderByAggregateInput
    _avg?: EstudiantePerfilAvgOrderByAggregateInput
    _max?: EstudiantePerfilMaxOrderByAggregateInput
    _min?: EstudiantePerfilMinOrderByAggregateInput
    _sum?: EstudiantePerfilSumOrderByAggregateInput
  }

  export type EstudiantePerfilScalarWhereWithAggregatesInput = {
    AND?: EstudiantePerfilScalarWhereWithAggregatesInput | EstudiantePerfilScalarWhereWithAggregatesInput[]
    OR?: EstudiantePerfilScalarWhereWithAggregatesInput[]
    NOT?: EstudiantePerfilScalarWhereWithAggregatesInput | EstudiantePerfilScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EstudiantePerfil"> | number
    sexo?: StringNullableWithAggregatesFilter<"EstudiantePerfil"> | string | null
    estadoEscuela?: StringNullableWithAggregatesFilter<"EstudiantePerfil"> | string | null
    sede?: StringNullableWithAggregatesFilter<"EstudiantePerfil"> | string | null
    escuela?: StringNullableWithAggregatesFilter<"EstudiantePerfil"> | string | null
    codigoMalla?: StringNullableWithAggregatesFilter<"EstudiantePerfil"> | string | null
    malla?: StringNullableWithAggregatesFilter<"EstudiantePerfil"> | string | null
    periodoLectivo?: StringNullableWithAggregatesFilter<"EstudiantePerfil"> | string | null
    ciudad?: StringNullableWithAggregatesFilter<"EstudiantePerfil"> | string | null
    provincia?: StringNullableWithAggregatesFilter<"EstudiantePerfil"> | string | null
    pais?: StringNullableWithAggregatesFilter<"EstudiantePerfil"> | string | null
    usuarioId?: IntWithAggregatesFilter<"EstudiantePerfil"> | number
  }

  export type McpAuthWhereInput = {
    AND?: McpAuthWhereInput | McpAuthWhereInput[]
    OR?: McpAuthWhereInput[]
    NOT?: McpAuthWhereInput | McpAuthWhereInput[]
    id?: IntFilter<"McpAuth"> | number
    email?: StringFilter<"McpAuth"> | string
    codigo?: StringFilter<"McpAuth"> | string
    token?: StringNullableFilter<"McpAuth"> | string | null
    expiresAt?: DateTimeFilter<"McpAuth"> | Date | string
    createdAt?: DateTimeFilter<"McpAuth"> | Date | string
  }

  export type McpAuthOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    codigo?: SortOrder
    token?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type McpAuthWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: McpAuthWhereInput | McpAuthWhereInput[]
    OR?: McpAuthWhereInput[]
    NOT?: McpAuthWhereInput | McpAuthWhereInput[]
    email?: StringFilter<"McpAuth"> | string
    codigo?: StringFilter<"McpAuth"> | string
    token?: StringNullableFilter<"McpAuth"> | string | null
    expiresAt?: DateTimeFilter<"McpAuth"> | Date | string
    createdAt?: DateTimeFilter<"McpAuth"> | Date | string
  }, "id">

  export type McpAuthOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    codigo?: SortOrder
    token?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: McpAuthCountOrderByAggregateInput
    _avg?: McpAuthAvgOrderByAggregateInput
    _max?: McpAuthMaxOrderByAggregateInput
    _min?: McpAuthMinOrderByAggregateInput
    _sum?: McpAuthSumOrderByAggregateInput
  }

  export type McpAuthScalarWhereWithAggregatesInput = {
    AND?: McpAuthScalarWhereWithAggregatesInput | McpAuthScalarWhereWithAggregatesInput[]
    OR?: McpAuthScalarWhereWithAggregatesInput[]
    NOT?: McpAuthScalarWhereWithAggregatesInput | McpAuthScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"McpAuth"> | number
    email?: StringWithAggregatesFilter<"McpAuth"> | string
    codigo?: StringWithAggregatesFilter<"McpAuth"> | string
    token?: StringNullableWithAggregatesFilter<"McpAuth"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"McpAuth"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"McpAuth"> | Date | string
  }

  export type UsuarioCreateInput = {
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    auth?: AuthCreateNestedOneWithoutUsuarioInput
    propuestas?: PropuestaCreateNestedManyWithoutEstudianteInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput
    comites?: ComiteCreateNestedManyWithoutUsuarioInput
    prerequisitos?: EstudiantePrerequisitoCreateNestedManyWithoutEstudianteInput
    estudiantePerfil?: EstudiantePerfilCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    auth?: AuthUncheckedCreateNestedOneWithoutUsuarioInput
    propuestas?: PropuestaUncheckedCreateNestedManyWithoutEstudianteInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    comites?: ComiteUncheckedCreateNestedManyWithoutUsuarioInput
    prerequisitos?: EstudiantePrerequisitoUncheckedCreateNestedManyWithoutEstudianteInput
    estudiantePerfil?: EstudiantePerfilUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUpdateOneWithoutUsuarioNestedInput
    propuestas?: PropuestaUpdateManyWithoutEstudianteNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput
    comites?: ComiteUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: EstudiantePrerequisitoUpdateManyWithoutEstudianteNestedInput
    estudiantePerfil?: EstudiantePerfilUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUncheckedUpdateOneWithoutUsuarioNestedInput
    propuestas?: PropuestaUncheckedUpdateManyWithoutEstudianteNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    comites?: ComiteUncheckedUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: EstudiantePrerequisitoUncheckedUpdateManyWithoutEstudianteNestedInput
    estudiantePerfil?: EstudiantePerfilUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthCreateInput = {
    username: string
    password: string
    usuario: UsuarioCreateNestedOneWithoutAuthInput
  }

  export type AuthUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    usuarioId: number
  }

  export type AuthUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUpdateOneRequiredWithoutAuthNestedInput
  }

  export type AuthUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type AuthCreateManyInput = {
    id?: number
    username: string
    password: string
    usuarioId: number
  }

  export type AuthUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type AuthUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type AreaConocimientoCreateInput = {
    codigo: string
    nombre: string
    descripcion?: string | null
    propuestas?: PropuestaCreateNestedManyWithoutAreaConocimientoInput
  }

  export type AreaConocimientoUncheckedCreateInput = {
    id?: number
    codigo: string
    nombre: string
    descripcion?: string | null
    propuestas?: PropuestaUncheckedCreateNestedManyWithoutAreaConocimientoInput
  }

  export type AreaConocimientoUpdateInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    propuestas?: PropuestaUpdateManyWithoutAreaConocimientoNestedInput
  }

  export type AreaConocimientoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    propuestas?: PropuestaUncheckedUpdateManyWithoutAreaConocimientoNestedInput
  }

  export type AreaConocimientoCreateManyInput = {
    id?: number
    codigo: string
    nombre: string
    descripcion?: string | null
  }

  export type AreaConocimientoUpdateManyMutationInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AreaConocimientoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropuestaCreateInput = {
    titulo: string
    objetivos: string
    problematica?: string | null
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
    areaConocimiento: AreaConocimientoCreateNestedOneWithoutPropuestasInput
    estudiante: UsuarioCreateNestedOneWithoutPropuestasInput
    trabajosTitulacion?: TrabajoTitulacionCreateNestedManyWithoutPropuestaInput
    actividades?: ActividadCreateNestedManyWithoutPropuestaInput
    comites?: ComiteCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaUncheckedCreateInput = {
    id?: number
    titulo: string
    objetivos: string
    problematica?: string | null
    areaConocimientoId: number
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fkEstudiante: number
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
    trabajosTitulacion?: TrabajoTitulacionUncheckedCreateNestedManyWithoutPropuestaInput
    actividades?: ActividadUncheckedCreateNestedManyWithoutPropuestaInput
    comites?: ComiteUncheckedCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalUncheckedCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
    areaConocimiento?: AreaConocimientoUpdateOneRequiredWithoutPropuestasNestedInput
    estudiante?: UsuarioUpdateOneRequiredWithoutPropuestasNestedInput
    trabajosTitulacion?: TrabajoTitulacionUpdateManyWithoutPropuestaNestedInput
    actividades?: ActividadUpdateManyWithoutPropuestaNestedInput
    comites?: ComiteUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaConocimientoId?: IntFieldUpdateOperationsInput | number
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fkEstudiante?: IntFieldUpdateOperationsInput | number
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
    trabajosTitulacion?: TrabajoTitulacionUncheckedUpdateManyWithoutPropuestaNestedInput
    actividades?: ActividadUncheckedUpdateManyWithoutPropuestaNestedInput
    comites?: ComiteUncheckedUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUncheckedUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaCreateManyInput = {
    id?: number
    titulo: string
    objetivos: string
    problematica?: string | null
    areaConocimientoId: number
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fkEstudiante: number
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
  }

  export type PropuestaUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
  }

  export type PropuestaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaConocimientoId?: IntFieldUpdateOperationsInput | number
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fkEstudiante?: IntFieldUpdateOperationsInput | number
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
  }

  export type TrabajoTitulacionCreateInput = {
    fkTutorId: number
    propuesta: PropuestaCreateNestedOneWithoutTrabajosTitulacionInput
  }

  export type TrabajoTitulacionUncheckedCreateInput = {
    propuestasId: number
    fkTutorId: number
  }

  export type TrabajoTitulacionUpdateInput = {
    fkTutorId?: IntFieldUpdateOperationsInput | number
    propuesta?: PropuestaUpdateOneRequiredWithoutTrabajosTitulacionNestedInput
  }

  export type TrabajoTitulacionUncheckedUpdateInput = {
    propuestasId?: IntFieldUpdateOperationsInput | number
    fkTutorId?: IntFieldUpdateOperationsInput | number
  }

  export type TrabajoTitulacionCreateManyInput = {
    propuestasId: number
    fkTutorId: number
  }

  export type TrabajoTitulacionUpdateManyMutationInput = {
    fkTutorId?: IntFieldUpdateOperationsInput | number
  }

  export type TrabajoTitulacionUncheckedUpdateManyInput = {
    propuestasId?: IntFieldUpdateOperationsInput | number
    fkTutorId?: IntFieldUpdateOperationsInput | number
  }

  export type ActividadCreateInput = {
    nombre: string
    descripcion?: string | null
    tipo?: $Enums.TipoActividad
    propuesta: PropuestaCreateNestedOneWithoutActividadesInput
    evidencias?: EvidenciaCreateNestedManyWithoutActividadInput
  }

  export type ActividadUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    propuestaId: number
    tipo?: $Enums.TipoActividad
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutActividadInput
  }

  export type ActividadUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoActividadFieldUpdateOperationsInput | $Enums.TipoActividad
    propuesta?: PropuestaUpdateOneRequiredWithoutActividadesNestedInput
    evidencias?: EvidenciaUpdateManyWithoutActividadNestedInput
  }

  export type ActividadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    propuestaId?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoActividadFieldUpdateOperationsInput | $Enums.TipoActividad
    evidencias?: EvidenciaUncheckedUpdateManyWithoutActividadNestedInput
  }

  export type ActividadCreateManyInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    propuestaId: number
    tipo?: $Enums.TipoActividad
  }

  export type ActividadUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoActividadFieldUpdateOperationsInput | $Enums.TipoActividad
  }

  export type ActividadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    propuestaId?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoActividadFieldUpdateOperationsInput | $Enums.TipoActividad
  }

  export type EvidenciaCreateInput = {
    semana: number
    contenido: string
    archivoUrl?: string | null
    fechaEntrega?: Date | string
    estado?: $Enums.EstadoEvidencia
    calificacion?: Decimal | DecimalJsLike | number | string | null
    actividad: ActividadCreateNestedOneWithoutEvidenciasInput
    comentarios?: ComentarioCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaUncheckedCreateInput = {
    id?: number
    semana: number
    contenido: string
    archivoUrl?: string | null
    fechaEntrega?: Date | string
    estado?: $Enums.EstadoEvidencia
    calificacion?: Decimal | DecimalJsLike | number | string | null
    actividadId: number
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaUpdateInput = {
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actividad?: ActividadUpdateOneRequiredWithoutEvidenciasNestedInput
    comentarios?: ComentarioUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actividadId?: IntFieldUpdateOperationsInput | number
    comentarios?: ComentarioUncheckedUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaCreateManyInput = {
    id?: number
    semana: number
    contenido: string
    archivoUrl?: string | null
    fechaEntrega?: Date | string
    estado?: $Enums.EstadoEvidencia
    calificacion?: Decimal | DecimalJsLike | number | string | null
    actividadId: number
  }

  export type EvidenciaUpdateManyMutationInput = {
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EvidenciaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actividadId?: IntFieldUpdateOperationsInput | number
  }

  export type ComentarioCreateInput = {
    descripcion?: string | null
    evidencia: EvidenciaCreateNestedOneWithoutComentariosInput
    usuario: UsuarioCreateNestedOneWithoutComentariosInput
  }

  export type ComentarioUncheckedCreateInput = {
    id?: number
    evidenciaId: number
    usuarioId: number
    descripcion?: string | null
  }

  export type ComentarioUpdateInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    evidencia?: EvidenciaUpdateOneRequiredWithoutComentariosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type ComentarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    evidenciaId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ComentarioCreateManyInput = {
    id?: number
    evidenciaId: number
    usuarioId: number
    descripcion?: string | null
  }

  export type ComentarioUpdateManyMutationInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ComentarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    evidenciaId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatalogoPrerequisitoCreateInput = {
    nombre: string
    descripcion?: string | null
    orden?: number
    activo?: boolean
    estudiantePrerequisitos?: EstudiantePrerequisitoCreateNestedManyWithoutPrerequisitoInput
  }

  export type CatalogoPrerequisitoUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    orden?: number
    activo?: boolean
    estudiantePrerequisitos?: EstudiantePrerequisitoUncheckedCreateNestedManyWithoutPrerequisitoInput
  }

  export type CatalogoPrerequisitoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    estudiantePrerequisitos?: EstudiantePrerequisitoUpdateManyWithoutPrerequisitoNestedInput
  }

  export type CatalogoPrerequisitoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    estudiantePrerequisitos?: EstudiantePrerequisitoUncheckedUpdateManyWithoutPrerequisitoNestedInput
  }

  export type CatalogoPrerequisitoCreateManyInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    orden?: number
    activo?: boolean
  }

  export type CatalogoPrerequisitoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatalogoPrerequisitoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EstudiantePrerequisitoCreateInput = {
    cumplido?: boolean
    archivoUrl?: string | null
    fechaCumplimiento?: Date | string | null
    prerequisito: CatalogoPrerequisitoCreateNestedOneWithoutEstudiantePrerequisitosInput
    estudiante: UsuarioCreateNestedOneWithoutPrerequisitosInput
  }

  export type EstudiantePrerequisitoUncheckedCreateInput = {
    id?: number
    prerequisitoId: number
    cumplido?: boolean
    archivoUrl?: string | null
    fechaCumplimiento?: Date | string | null
    fkEstudiante: number
  }

  export type EstudiantePrerequisitoUpdateInput = {
    cumplido?: BoolFieldUpdateOperationsInput | boolean
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCumplimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prerequisito?: CatalogoPrerequisitoUpdateOneRequiredWithoutEstudiantePrerequisitosNestedInput
    estudiante?: UsuarioUpdateOneRequiredWithoutPrerequisitosNestedInput
  }

  export type EstudiantePrerequisitoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    prerequisitoId?: IntFieldUpdateOperationsInput | number
    cumplido?: BoolFieldUpdateOperationsInput | boolean
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCumplimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fkEstudiante?: IntFieldUpdateOperationsInput | number
  }

  export type EstudiantePrerequisitoCreateManyInput = {
    id?: number
    prerequisitoId: number
    cumplido?: boolean
    archivoUrl?: string | null
    fechaCumplimiento?: Date | string | null
    fkEstudiante: number
  }

  export type EstudiantePrerequisitoUpdateManyMutationInput = {
    cumplido?: BoolFieldUpdateOperationsInput | boolean
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCumplimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EstudiantePrerequisitoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    prerequisitoId?: IntFieldUpdateOperationsInput | number
    cumplido?: BoolFieldUpdateOperationsInput | boolean
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCumplimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fkEstudiante?: IntFieldUpdateOperationsInput | number
  }

  export type NotificacionCreateInput = {
    mensaje: string
    leido?: boolean
    fechaCreacion?: Date | string
    usuario: UsuarioCreateNestedOneWithoutNotificacionesInput
  }

  export type NotificacionUncheckedCreateInput = {
    id?: number
    mensaje: string
    leido?: boolean
    fechaCreacion?: Date | string
    usuarioId: number
  }

  export type NotificacionUpdateInput = {
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutNotificacionesNestedInput
  }

  export type NotificacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificacionCreateManyInput = {
    id?: number
    mensaje: string
    leido?: boolean
    fechaCreacion?: Date | string
    usuarioId: number
  }

  export type NotificacionUpdateManyMutationInput = {
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type EntregableFinalCreateInput = {
    tipo: $Enums.TipoEntregable
    urlArchivo: string
    fechaSubida?: Date | string
    propuesta: PropuestaCreateNestedOneWithoutEntregablesFinalesInput
  }

  export type EntregableFinalUncheckedCreateInput = {
    id?: number
    tipo: $Enums.TipoEntregable
    urlArchivo: string
    fechaSubida?: Date | string
    propuestasId: number
  }

  export type EntregableFinalUpdateInput = {
    tipo?: EnumTipoEntregableFieldUpdateOperationsInput | $Enums.TipoEntregable
    urlArchivo?: StringFieldUpdateOperationsInput | string
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
    propuesta?: PropuestaUpdateOneRequiredWithoutEntregablesFinalesNestedInput
  }

  export type EntregableFinalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoEntregableFieldUpdateOperationsInput | $Enums.TipoEntregable
    urlArchivo?: StringFieldUpdateOperationsInput | string
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestasId?: IntFieldUpdateOperationsInput | number
  }

  export type EntregableFinalCreateManyInput = {
    id?: number
    tipo: $Enums.TipoEntregable
    urlArchivo: string
    fechaSubida?: Date | string
    propuestasId: number
  }

  export type EntregableFinalUpdateManyMutationInput = {
    tipo?: EnumTipoEntregableFieldUpdateOperationsInput | $Enums.TipoEntregable
    urlArchivo?: StringFieldUpdateOperationsInput | string
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntregableFinalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoEntregableFieldUpdateOperationsInput | $Enums.TipoEntregable
    urlArchivo?: StringFieldUpdateOperationsInput | string
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestasId?: IntFieldUpdateOperationsInput | number
  }

  export type ComiteCreateInput = {
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
    usuario: UsuarioCreateNestedOneWithoutComitesInput
    propuesta: PropuestaCreateNestedOneWithoutComitesInput
  }

  export type ComiteUncheckedCreateInput = {
    usuarioId: number
    propuestaId: number
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
  }

  export type ComiteUpdateInput = {
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario?: UsuarioUpdateOneRequiredWithoutComitesNestedInput
    propuesta?: PropuestaUpdateOneRequiredWithoutComitesNestedInput
  }

  export type ComiteUncheckedUpdateInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number
    propuestaId?: IntFieldUpdateOperationsInput | number
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ComiteCreateManyInput = {
    usuarioId: number
    propuestaId: number
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
  }

  export type ComiteUpdateManyMutationInput = {
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ComiteUncheckedUpdateManyInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number
    propuestaId?: IntFieldUpdateOperationsInput | number
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EstudiantePerfilCreateInput = {
    sexo?: string | null
    estadoEscuela?: string | null
    sede?: string | null
    escuela?: string | null
    codigoMalla?: string | null
    malla?: string | null
    periodoLectivo?: string | null
    ciudad?: string | null
    provincia?: string | null
    pais?: string | null
    usuario: UsuarioCreateNestedOneWithoutEstudiantePerfilInput
  }

  export type EstudiantePerfilUncheckedCreateInput = {
    id?: number
    sexo?: string | null
    estadoEscuela?: string | null
    sede?: string | null
    escuela?: string | null
    codigoMalla?: string | null
    malla?: string | null
    periodoLectivo?: string | null
    ciudad?: string | null
    provincia?: string | null
    pais?: string | null
    usuarioId: number
  }

  export type EstudiantePerfilUpdateInput = {
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    estadoEscuela?: NullableStringFieldUpdateOperationsInput | string | null
    sede?: NullableStringFieldUpdateOperationsInput | string | null
    escuela?: NullableStringFieldUpdateOperationsInput | string | null
    codigoMalla?: NullableStringFieldUpdateOperationsInput | string | null
    malla?: NullableStringFieldUpdateOperationsInput | string | null
    periodoLectivo?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    provincia?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: UsuarioUpdateOneRequiredWithoutEstudiantePerfilNestedInput
  }

  export type EstudiantePerfilUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    estadoEscuela?: NullableStringFieldUpdateOperationsInput | string | null
    sede?: NullableStringFieldUpdateOperationsInput | string | null
    escuela?: NullableStringFieldUpdateOperationsInput | string | null
    codigoMalla?: NullableStringFieldUpdateOperationsInput | string | null
    malla?: NullableStringFieldUpdateOperationsInput | string | null
    periodoLectivo?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    provincia?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type EstudiantePerfilCreateManyInput = {
    id?: number
    sexo?: string | null
    estadoEscuela?: string | null
    sede?: string | null
    escuela?: string | null
    codigoMalla?: string | null
    malla?: string | null
    periodoLectivo?: string | null
    ciudad?: string | null
    provincia?: string | null
    pais?: string | null
    usuarioId: number
  }

  export type EstudiantePerfilUpdateManyMutationInput = {
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    estadoEscuela?: NullableStringFieldUpdateOperationsInput | string | null
    sede?: NullableStringFieldUpdateOperationsInput | string | null
    escuela?: NullableStringFieldUpdateOperationsInput | string | null
    codigoMalla?: NullableStringFieldUpdateOperationsInput | string | null
    malla?: NullableStringFieldUpdateOperationsInput | string | null
    periodoLectivo?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    provincia?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EstudiantePerfilUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    estadoEscuela?: NullableStringFieldUpdateOperationsInput | string | null
    sede?: NullableStringFieldUpdateOperationsInput | string | null
    escuela?: NullableStringFieldUpdateOperationsInput | string | null
    codigoMalla?: NullableStringFieldUpdateOperationsInput | string | null
    malla?: NullableStringFieldUpdateOperationsInput | string | null
    periodoLectivo?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    provincia?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type McpAuthCreateInput = {
    email: string
    codigo: string
    token?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type McpAuthUncheckedCreateInput = {
    id?: number
    email: string
    codigo: string
    token?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type McpAuthUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McpAuthUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McpAuthCreateManyInput = {
    id?: number
    email: string
    codigo: string
    token?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type McpAuthUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McpAuthUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AuthNullableRelationFilter = {
    is?: AuthWhereInput | null
    isNot?: AuthWhereInput | null
  }

  export type PropuestaListRelationFilter = {
    every?: PropuestaWhereInput
    some?: PropuestaWhereInput
    none?: PropuestaWhereInput
  }

  export type ComentarioListRelationFilter = {
    every?: ComentarioWhereInput
    some?: ComentarioWhereInput
    none?: ComentarioWhereInput
  }

  export type NotificacionListRelationFilter = {
    every?: NotificacionWhereInput
    some?: NotificacionWhereInput
    none?: NotificacionWhereInput
  }

  export type ComiteListRelationFilter = {
    every?: ComiteWhereInput
    some?: ComiteWhereInput
    none?: ComiteWhereInput
  }

  export type EstudiantePrerequisitoListRelationFilter = {
    every?: EstudiantePrerequisitoWhereInput
    some?: EstudiantePrerequisitoWhereInput
    none?: EstudiantePrerequisitoWhereInput
  }

  export type EstudiantePerfilNullableRelationFilter = {
    is?: EstudiantePerfilWhereInput | null
    isNot?: EstudiantePerfilWhereInput | null
  }

  export type PropuestaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComentarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EstudiantePrerequisitoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    correoInstitucional?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    correoInstitucional?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    correoInstitucional?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type AuthCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    usuarioId?: SortOrder
  }

  export type AuthAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type AuthMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    usuarioId?: SortOrder
  }

  export type AuthMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    usuarioId?: SortOrder
  }

  export type AuthSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AreaConocimientoCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type AreaConocimientoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AreaConocimientoMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type AreaConocimientoMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type AreaConocimientoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumEstadoPropuestaFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPropuesta | EnumEstadoPropuestaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPropuesta[]
    notIn?: $Enums.EstadoPropuesta[]
    not?: NestedEnumEstadoPropuestaFilter<$PrismaModel> | $Enums.EstadoPropuesta
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumResultadoDefensaNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultadoDefensa | EnumResultadoDefensaFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResultadoDefensa[] | null
    notIn?: $Enums.ResultadoDefensa[] | null
    not?: NestedEnumResultadoDefensaNullableFilter<$PrismaModel> | $Enums.ResultadoDefensa | null
  }

  export type AreaConocimientoRelationFilter = {
    is?: AreaConocimientoWhereInput
    isNot?: AreaConocimientoWhereInput
  }

  export type TrabajoTitulacionListRelationFilter = {
    every?: TrabajoTitulacionWhereInput
    some?: TrabajoTitulacionWhereInput
    none?: TrabajoTitulacionWhereInput
  }

  export type ActividadListRelationFilter = {
    every?: ActividadWhereInput
    some?: ActividadWhereInput
    none?: ActividadWhereInput
  }

  export type EntregableFinalListRelationFilter = {
    every?: EntregableFinalWhereInput
    some?: EntregableFinalWhereInput
    none?: EntregableFinalWhereInput
  }

  export type TrabajoTitulacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActividadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntregableFinalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropuestaCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    objetivos?: SortOrder
    problematica?: SortOrder
    areaConocimientoId?: SortOrder
    alcance?: SortOrder
    archivoUrl?: SortOrder
    fechaPublicacion?: SortOrder
    estado?: SortOrder
    fkEstudiante?: SortOrder
    fechaDefensa?: SortOrder
    resultadoDefensa?: SortOrder
  }

  export type PropuestaAvgOrderByAggregateInput = {
    id?: SortOrder
    areaConocimientoId?: SortOrder
    fkEstudiante?: SortOrder
  }

  export type PropuestaMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    objetivos?: SortOrder
    problematica?: SortOrder
    areaConocimientoId?: SortOrder
    alcance?: SortOrder
    archivoUrl?: SortOrder
    fechaPublicacion?: SortOrder
    estado?: SortOrder
    fkEstudiante?: SortOrder
    fechaDefensa?: SortOrder
    resultadoDefensa?: SortOrder
  }

  export type PropuestaMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    objetivos?: SortOrder
    problematica?: SortOrder
    areaConocimientoId?: SortOrder
    alcance?: SortOrder
    archivoUrl?: SortOrder
    fechaPublicacion?: SortOrder
    estado?: SortOrder
    fkEstudiante?: SortOrder
    fechaDefensa?: SortOrder
    resultadoDefensa?: SortOrder
  }

  export type PropuestaSumOrderByAggregateInput = {
    id?: SortOrder
    areaConocimientoId?: SortOrder
    fkEstudiante?: SortOrder
  }

  export type EnumEstadoPropuestaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPropuesta | EnumEstadoPropuestaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPropuesta[]
    notIn?: $Enums.EstadoPropuesta[]
    not?: NestedEnumEstadoPropuestaWithAggregatesFilter<$PrismaModel> | $Enums.EstadoPropuesta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoPropuestaFilter<$PrismaModel>
    _max?: NestedEnumEstadoPropuestaFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumResultadoDefensaNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultadoDefensa | EnumResultadoDefensaFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResultadoDefensa[] | null
    notIn?: $Enums.ResultadoDefensa[] | null
    not?: NestedEnumResultadoDefensaNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResultadoDefensa | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResultadoDefensaNullableFilter<$PrismaModel>
    _max?: NestedEnumResultadoDefensaNullableFilter<$PrismaModel>
  }

  export type PropuestaRelationFilter = {
    is?: PropuestaWhereInput
    isNot?: PropuestaWhereInput
  }

  export type TrabajoTitulacionPropuestasIdFkTutorIdCompoundUniqueInput = {
    propuestasId: number
    fkTutorId: number
  }

  export type TrabajoTitulacionCountOrderByAggregateInput = {
    propuestasId?: SortOrder
    fkTutorId?: SortOrder
  }

  export type TrabajoTitulacionAvgOrderByAggregateInput = {
    propuestasId?: SortOrder
    fkTutorId?: SortOrder
  }

  export type TrabajoTitulacionMaxOrderByAggregateInput = {
    propuestasId?: SortOrder
    fkTutorId?: SortOrder
  }

  export type TrabajoTitulacionMinOrderByAggregateInput = {
    propuestasId?: SortOrder
    fkTutorId?: SortOrder
  }

  export type TrabajoTitulacionSumOrderByAggregateInput = {
    propuestasId?: SortOrder
    fkTutorId?: SortOrder
  }

  export type EnumTipoActividadFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoActividad | EnumTipoActividadFieldRefInput<$PrismaModel>
    in?: $Enums.TipoActividad[]
    notIn?: $Enums.TipoActividad[]
    not?: NestedEnumTipoActividadFilter<$PrismaModel> | $Enums.TipoActividad
  }

  export type EvidenciaListRelationFilter = {
    every?: EvidenciaWhereInput
    some?: EvidenciaWhereInput
    none?: EvidenciaWhereInput
  }

  export type EvidenciaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActividadCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    propuestaId?: SortOrder
    tipo?: SortOrder
  }

  export type ActividadAvgOrderByAggregateInput = {
    id?: SortOrder
    propuestaId?: SortOrder
  }

  export type ActividadMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    propuestaId?: SortOrder
    tipo?: SortOrder
  }

  export type ActividadMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    propuestaId?: SortOrder
    tipo?: SortOrder
  }

  export type ActividadSumOrderByAggregateInput = {
    id?: SortOrder
    propuestaId?: SortOrder
  }

  export type EnumTipoActividadWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoActividad | EnumTipoActividadFieldRefInput<$PrismaModel>
    in?: $Enums.TipoActividad[]
    notIn?: $Enums.TipoActividad[]
    not?: NestedEnumTipoActividadWithAggregatesFilter<$PrismaModel> | $Enums.TipoActividad
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoActividadFilter<$PrismaModel>
    _max?: NestedEnumTipoActividadFilter<$PrismaModel>
  }

  export type EnumEstadoEvidenciaFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoEvidencia | EnumEstadoEvidenciaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoEvidencia[]
    notIn?: $Enums.EstadoEvidencia[]
    not?: NestedEnumEstadoEvidenciaFilter<$PrismaModel> | $Enums.EstadoEvidencia
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ActividadRelationFilter = {
    is?: ActividadWhereInput
    isNot?: ActividadWhereInput
  }

  export type EvidenciaCountOrderByAggregateInput = {
    id?: SortOrder
    semana?: SortOrder
    contenido?: SortOrder
    archivoUrl?: SortOrder
    fechaEntrega?: SortOrder
    estado?: SortOrder
    calificacion?: SortOrder
    actividadId?: SortOrder
  }

  export type EvidenciaAvgOrderByAggregateInput = {
    id?: SortOrder
    semana?: SortOrder
    calificacion?: SortOrder
    actividadId?: SortOrder
  }

  export type EvidenciaMaxOrderByAggregateInput = {
    id?: SortOrder
    semana?: SortOrder
    contenido?: SortOrder
    archivoUrl?: SortOrder
    fechaEntrega?: SortOrder
    estado?: SortOrder
    calificacion?: SortOrder
    actividadId?: SortOrder
  }

  export type EvidenciaMinOrderByAggregateInput = {
    id?: SortOrder
    semana?: SortOrder
    contenido?: SortOrder
    archivoUrl?: SortOrder
    fechaEntrega?: SortOrder
    estado?: SortOrder
    calificacion?: SortOrder
    actividadId?: SortOrder
  }

  export type EvidenciaSumOrderByAggregateInput = {
    id?: SortOrder
    semana?: SortOrder
    calificacion?: SortOrder
    actividadId?: SortOrder
  }

  export type EnumEstadoEvidenciaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoEvidencia | EnumEstadoEvidenciaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoEvidencia[]
    notIn?: $Enums.EstadoEvidencia[]
    not?: NestedEnumEstadoEvidenciaWithAggregatesFilter<$PrismaModel> | $Enums.EstadoEvidencia
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoEvidenciaFilter<$PrismaModel>
    _max?: NestedEnumEstadoEvidenciaFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EvidenciaRelationFilter = {
    is?: EvidenciaWhereInput
    isNot?: EvidenciaWhereInput
  }

  export type ComentarioCountOrderByAggregateInput = {
    id?: SortOrder
    evidenciaId?: SortOrder
    usuarioId?: SortOrder
    descripcion?: SortOrder
  }

  export type ComentarioAvgOrderByAggregateInput = {
    id?: SortOrder
    evidenciaId?: SortOrder
    usuarioId?: SortOrder
  }

  export type ComentarioMaxOrderByAggregateInput = {
    id?: SortOrder
    evidenciaId?: SortOrder
    usuarioId?: SortOrder
    descripcion?: SortOrder
  }

  export type ComentarioMinOrderByAggregateInput = {
    id?: SortOrder
    evidenciaId?: SortOrder
    usuarioId?: SortOrder
    descripcion?: SortOrder
  }

  export type ComentarioSumOrderByAggregateInput = {
    id?: SortOrder
    evidenciaId?: SortOrder
    usuarioId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CatalogoPrerequisitoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    activo?: SortOrder
  }

  export type CatalogoPrerequisitoAvgOrderByAggregateInput = {
    id?: SortOrder
    orden?: SortOrder
  }

  export type CatalogoPrerequisitoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    activo?: SortOrder
  }

  export type CatalogoPrerequisitoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    activo?: SortOrder
  }

  export type CatalogoPrerequisitoSumOrderByAggregateInput = {
    id?: SortOrder
    orden?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CatalogoPrerequisitoRelationFilter = {
    is?: CatalogoPrerequisitoWhereInput
    isNot?: CatalogoPrerequisitoWhereInput
  }

  export type EstudiantePrerequisitoFkEstudiantePrerequisitoIdCompoundUniqueInput = {
    fkEstudiante: number
    prerequisitoId: number
  }

  export type EstudiantePrerequisitoCountOrderByAggregateInput = {
    id?: SortOrder
    prerequisitoId?: SortOrder
    cumplido?: SortOrder
    archivoUrl?: SortOrder
    fechaCumplimiento?: SortOrder
    fkEstudiante?: SortOrder
  }

  export type EstudiantePrerequisitoAvgOrderByAggregateInput = {
    id?: SortOrder
    prerequisitoId?: SortOrder
    fkEstudiante?: SortOrder
  }

  export type EstudiantePrerequisitoMaxOrderByAggregateInput = {
    id?: SortOrder
    prerequisitoId?: SortOrder
    cumplido?: SortOrder
    archivoUrl?: SortOrder
    fechaCumplimiento?: SortOrder
    fkEstudiante?: SortOrder
  }

  export type EstudiantePrerequisitoMinOrderByAggregateInput = {
    id?: SortOrder
    prerequisitoId?: SortOrder
    cumplido?: SortOrder
    archivoUrl?: SortOrder
    fechaCumplimiento?: SortOrder
    fkEstudiante?: SortOrder
  }

  export type EstudiantePrerequisitoSumOrderByAggregateInput = {
    id?: SortOrder
    prerequisitoId?: SortOrder
    fkEstudiante?: SortOrder
  }

  export type NotificacionCountOrderByAggregateInput = {
    id?: SortOrder
    mensaje?: SortOrder
    leido?: SortOrder
    fechaCreacion?: SortOrder
    usuarioId?: SortOrder
  }

  export type NotificacionAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type NotificacionMaxOrderByAggregateInput = {
    id?: SortOrder
    mensaje?: SortOrder
    leido?: SortOrder
    fechaCreacion?: SortOrder
    usuarioId?: SortOrder
  }

  export type NotificacionMinOrderByAggregateInput = {
    id?: SortOrder
    mensaje?: SortOrder
    leido?: SortOrder
    fechaCreacion?: SortOrder
    usuarioId?: SortOrder
  }

  export type NotificacionSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type EnumTipoEntregableFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEntregable | EnumTipoEntregableFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEntregable[]
    notIn?: $Enums.TipoEntregable[]
    not?: NestedEnumTipoEntregableFilter<$PrismaModel> | $Enums.TipoEntregable
  }

  export type EntregableFinalCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    urlArchivo?: SortOrder
    fechaSubida?: SortOrder
    propuestasId?: SortOrder
  }

  export type EntregableFinalAvgOrderByAggregateInput = {
    id?: SortOrder
    propuestasId?: SortOrder
  }

  export type EntregableFinalMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    urlArchivo?: SortOrder
    fechaSubida?: SortOrder
    propuestasId?: SortOrder
  }

  export type EntregableFinalMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    urlArchivo?: SortOrder
    fechaSubida?: SortOrder
    propuestasId?: SortOrder
  }

  export type EntregableFinalSumOrderByAggregateInput = {
    id?: SortOrder
    propuestasId?: SortOrder
  }

  export type EnumTipoEntregableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEntregable | EnumTipoEntregableFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEntregable[]
    notIn?: $Enums.TipoEntregable[]
    not?: NestedEnumTipoEntregableWithAggregatesFilter<$PrismaModel> | $Enums.TipoEntregable
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoEntregableFilter<$PrismaModel>
    _max?: NestedEnumTipoEntregableFilter<$PrismaModel>
  }

  export type EnumRolComiteFilter<$PrismaModel = never> = {
    equals?: $Enums.RolComite | EnumRolComiteFieldRefInput<$PrismaModel>
    in?: $Enums.RolComite[]
    notIn?: $Enums.RolComite[]
    not?: NestedEnumRolComiteFilter<$PrismaModel> | $Enums.RolComite
  }

  export type ComiteUsuarioIdPropuestaIdCompoundUniqueInput = {
    usuarioId: number
    propuestaId: number
  }

  export type ComiteCountOrderByAggregateInput = {
    usuarioId?: SortOrder
    propuestaId?: SortOrder
    rol?: SortOrder
    calificacion?: SortOrder
    fechaAsignada?: SortOrder
  }

  export type ComiteAvgOrderByAggregateInput = {
    usuarioId?: SortOrder
    propuestaId?: SortOrder
    calificacion?: SortOrder
  }

  export type ComiteMaxOrderByAggregateInput = {
    usuarioId?: SortOrder
    propuestaId?: SortOrder
    rol?: SortOrder
    calificacion?: SortOrder
    fechaAsignada?: SortOrder
  }

  export type ComiteMinOrderByAggregateInput = {
    usuarioId?: SortOrder
    propuestaId?: SortOrder
    rol?: SortOrder
    calificacion?: SortOrder
    fechaAsignada?: SortOrder
  }

  export type ComiteSumOrderByAggregateInput = {
    usuarioId?: SortOrder
    propuestaId?: SortOrder
    calificacion?: SortOrder
  }

  export type EnumRolComiteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RolComite | EnumRolComiteFieldRefInput<$PrismaModel>
    in?: $Enums.RolComite[]
    notIn?: $Enums.RolComite[]
    not?: NestedEnumRolComiteWithAggregatesFilter<$PrismaModel> | $Enums.RolComite
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolComiteFilter<$PrismaModel>
    _max?: NestedEnumRolComiteFilter<$PrismaModel>
  }

  export type EstudiantePerfilCountOrderByAggregateInput = {
    id?: SortOrder
    sexo?: SortOrder
    estadoEscuela?: SortOrder
    sede?: SortOrder
    escuela?: SortOrder
    codigoMalla?: SortOrder
    malla?: SortOrder
    periodoLectivo?: SortOrder
    ciudad?: SortOrder
    provincia?: SortOrder
    pais?: SortOrder
    usuarioId?: SortOrder
  }

  export type EstudiantePerfilAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type EstudiantePerfilMaxOrderByAggregateInput = {
    id?: SortOrder
    sexo?: SortOrder
    estadoEscuela?: SortOrder
    sede?: SortOrder
    escuela?: SortOrder
    codigoMalla?: SortOrder
    malla?: SortOrder
    periodoLectivo?: SortOrder
    ciudad?: SortOrder
    provincia?: SortOrder
    pais?: SortOrder
    usuarioId?: SortOrder
  }

  export type EstudiantePerfilMinOrderByAggregateInput = {
    id?: SortOrder
    sexo?: SortOrder
    estadoEscuela?: SortOrder
    sede?: SortOrder
    escuela?: SortOrder
    codigoMalla?: SortOrder
    malla?: SortOrder
    periodoLectivo?: SortOrder
    ciudad?: SortOrder
    provincia?: SortOrder
    pais?: SortOrder
    usuarioId?: SortOrder
  }

  export type EstudiantePerfilSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type McpAuthCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    codigo?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type McpAuthAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type McpAuthMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    codigo?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type McpAuthMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    codigo?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type McpAuthSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AuthCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<AuthCreateWithoutUsuarioInput, AuthUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: AuthCreateOrConnectWithoutUsuarioInput
    connect?: AuthWhereUniqueInput
  }

  export type PropuestaCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<PropuestaCreateWithoutEstudianteInput, PropuestaUncheckedCreateWithoutEstudianteInput> | PropuestaCreateWithoutEstudianteInput[] | PropuestaUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: PropuestaCreateOrConnectWithoutEstudianteInput | PropuestaCreateOrConnectWithoutEstudianteInput[]
    createMany?: PropuestaCreateManyEstudianteInputEnvelope
    connect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
  }

  export type ComentarioCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput> | ComentarioCreateWithoutUsuarioInput[] | ComentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutUsuarioInput | ComentarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
  }

  export type NotificacionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput> | NotificacionCreateWithoutUsuarioInput[] | NotificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutUsuarioInput | NotificacionCreateOrConnectWithoutUsuarioInput[]
    createMany?: NotificacionCreateManyUsuarioInputEnvelope
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
  }

  export type ComiteCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ComiteCreateWithoutUsuarioInput, ComiteUncheckedCreateWithoutUsuarioInput> | ComiteCreateWithoutUsuarioInput[] | ComiteUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComiteCreateOrConnectWithoutUsuarioInput | ComiteCreateOrConnectWithoutUsuarioInput[]
    createMany?: ComiteCreateManyUsuarioInputEnvelope
    connect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
  }

  export type EstudiantePrerequisitoCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<EstudiantePrerequisitoCreateWithoutEstudianteInput, EstudiantePrerequisitoUncheckedCreateWithoutEstudianteInput> | EstudiantePrerequisitoCreateWithoutEstudianteInput[] | EstudiantePrerequisitoUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: EstudiantePrerequisitoCreateOrConnectWithoutEstudianteInput | EstudiantePrerequisitoCreateOrConnectWithoutEstudianteInput[]
    createMany?: EstudiantePrerequisitoCreateManyEstudianteInputEnvelope
    connect?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
  }

  export type EstudiantePerfilCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<EstudiantePerfilCreateWithoutUsuarioInput, EstudiantePerfilUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EstudiantePerfilCreateOrConnectWithoutUsuarioInput
    connect?: EstudiantePerfilWhereUniqueInput
  }

  export type AuthUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<AuthCreateWithoutUsuarioInput, AuthUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: AuthCreateOrConnectWithoutUsuarioInput
    connect?: AuthWhereUniqueInput
  }

  export type PropuestaUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<PropuestaCreateWithoutEstudianteInput, PropuestaUncheckedCreateWithoutEstudianteInput> | PropuestaCreateWithoutEstudianteInput[] | PropuestaUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: PropuestaCreateOrConnectWithoutEstudianteInput | PropuestaCreateOrConnectWithoutEstudianteInput[]
    createMany?: PropuestaCreateManyEstudianteInputEnvelope
    connect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
  }

  export type ComentarioUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput> | ComentarioCreateWithoutUsuarioInput[] | ComentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutUsuarioInput | ComentarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
  }

  export type NotificacionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput> | NotificacionCreateWithoutUsuarioInput[] | NotificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutUsuarioInput | NotificacionCreateOrConnectWithoutUsuarioInput[]
    createMany?: NotificacionCreateManyUsuarioInputEnvelope
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
  }

  export type ComiteUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ComiteCreateWithoutUsuarioInput, ComiteUncheckedCreateWithoutUsuarioInput> | ComiteCreateWithoutUsuarioInput[] | ComiteUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComiteCreateOrConnectWithoutUsuarioInput | ComiteCreateOrConnectWithoutUsuarioInput[]
    createMany?: ComiteCreateManyUsuarioInputEnvelope
    connect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
  }

  export type EstudiantePrerequisitoUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<EstudiantePrerequisitoCreateWithoutEstudianteInput, EstudiantePrerequisitoUncheckedCreateWithoutEstudianteInput> | EstudiantePrerequisitoCreateWithoutEstudianteInput[] | EstudiantePrerequisitoUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: EstudiantePrerequisitoCreateOrConnectWithoutEstudianteInput | EstudiantePrerequisitoCreateOrConnectWithoutEstudianteInput[]
    createMany?: EstudiantePrerequisitoCreateManyEstudianteInputEnvelope
    connect?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
  }

  export type EstudiantePerfilUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<EstudiantePerfilCreateWithoutUsuarioInput, EstudiantePerfilUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EstudiantePerfilCreateOrConnectWithoutUsuarioInput
    connect?: EstudiantePerfilWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRolFieldUpdateOperationsInput = {
    set?: $Enums.Rol
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AuthUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<AuthCreateWithoutUsuarioInput, AuthUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: AuthCreateOrConnectWithoutUsuarioInput
    upsert?: AuthUpsertWithoutUsuarioInput
    disconnect?: AuthWhereInput | boolean
    delete?: AuthWhereInput | boolean
    connect?: AuthWhereUniqueInput
    update?: XOR<XOR<AuthUpdateToOneWithWhereWithoutUsuarioInput, AuthUpdateWithoutUsuarioInput>, AuthUncheckedUpdateWithoutUsuarioInput>
  }

  export type PropuestaUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<PropuestaCreateWithoutEstudianteInput, PropuestaUncheckedCreateWithoutEstudianteInput> | PropuestaCreateWithoutEstudianteInput[] | PropuestaUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: PropuestaCreateOrConnectWithoutEstudianteInput | PropuestaCreateOrConnectWithoutEstudianteInput[]
    upsert?: PropuestaUpsertWithWhereUniqueWithoutEstudianteInput | PropuestaUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: PropuestaCreateManyEstudianteInputEnvelope
    set?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    disconnect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    delete?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    connect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    update?: PropuestaUpdateWithWhereUniqueWithoutEstudianteInput | PropuestaUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: PropuestaUpdateManyWithWhereWithoutEstudianteInput | PropuestaUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: PropuestaScalarWhereInput | PropuestaScalarWhereInput[]
  }

  export type ComentarioUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput> | ComentarioCreateWithoutUsuarioInput[] | ComentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutUsuarioInput | ComentarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: ComentarioUpsertWithWhereUniqueWithoutUsuarioInput | ComentarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    set?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    disconnect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    delete?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    update?: ComentarioUpdateWithWhereUniqueWithoutUsuarioInput | ComentarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ComentarioUpdateManyWithWhereWithoutUsuarioInput | ComentarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
  }

  export type NotificacionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput> | NotificacionCreateWithoutUsuarioInput[] | NotificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutUsuarioInput | NotificacionCreateOrConnectWithoutUsuarioInput[]
    upsert?: NotificacionUpsertWithWhereUniqueWithoutUsuarioInput | NotificacionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: NotificacionCreateManyUsuarioInputEnvelope
    set?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    disconnect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    delete?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    update?: NotificacionUpdateWithWhereUniqueWithoutUsuarioInput | NotificacionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: NotificacionUpdateManyWithWhereWithoutUsuarioInput | NotificacionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
  }

  export type ComiteUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ComiteCreateWithoutUsuarioInput, ComiteUncheckedCreateWithoutUsuarioInput> | ComiteCreateWithoutUsuarioInput[] | ComiteUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComiteCreateOrConnectWithoutUsuarioInput | ComiteCreateOrConnectWithoutUsuarioInput[]
    upsert?: ComiteUpsertWithWhereUniqueWithoutUsuarioInput | ComiteUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ComiteCreateManyUsuarioInputEnvelope
    set?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    disconnect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    delete?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    connect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    update?: ComiteUpdateWithWhereUniqueWithoutUsuarioInput | ComiteUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ComiteUpdateManyWithWhereWithoutUsuarioInput | ComiteUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ComiteScalarWhereInput | ComiteScalarWhereInput[]
  }

  export type EstudiantePrerequisitoUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<EstudiantePrerequisitoCreateWithoutEstudianteInput, EstudiantePrerequisitoUncheckedCreateWithoutEstudianteInput> | EstudiantePrerequisitoCreateWithoutEstudianteInput[] | EstudiantePrerequisitoUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: EstudiantePrerequisitoCreateOrConnectWithoutEstudianteInput | EstudiantePrerequisitoCreateOrConnectWithoutEstudianteInput[]
    upsert?: EstudiantePrerequisitoUpsertWithWhereUniqueWithoutEstudianteInput | EstudiantePrerequisitoUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: EstudiantePrerequisitoCreateManyEstudianteInputEnvelope
    set?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
    disconnect?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
    delete?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
    connect?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
    update?: EstudiantePrerequisitoUpdateWithWhereUniqueWithoutEstudianteInput | EstudiantePrerequisitoUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: EstudiantePrerequisitoUpdateManyWithWhereWithoutEstudianteInput | EstudiantePrerequisitoUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: EstudiantePrerequisitoScalarWhereInput | EstudiantePrerequisitoScalarWhereInput[]
  }

  export type EstudiantePerfilUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<EstudiantePerfilCreateWithoutUsuarioInput, EstudiantePerfilUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EstudiantePerfilCreateOrConnectWithoutUsuarioInput
    upsert?: EstudiantePerfilUpsertWithoutUsuarioInput
    disconnect?: EstudiantePerfilWhereInput | boolean
    delete?: EstudiantePerfilWhereInput | boolean
    connect?: EstudiantePerfilWhereUniqueInput
    update?: XOR<XOR<EstudiantePerfilUpdateToOneWithWhereWithoutUsuarioInput, EstudiantePerfilUpdateWithoutUsuarioInput>, EstudiantePerfilUncheckedUpdateWithoutUsuarioInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AuthUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<AuthCreateWithoutUsuarioInput, AuthUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: AuthCreateOrConnectWithoutUsuarioInput
    upsert?: AuthUpsertWithoutUsuarioInput
    disconnect?: AuthWhereInput | boolean
    delete?: AuthWhereInput | boolean
    connect?: AuthWhereUniqueInput
    update?: XOR<XOR<AuthUpdateToOneWithWhereWithoutUsuarioInput, AuthUpdateWithoutUsuarioInput>, AuthUncheckedUpdateWithoutUsuarioInput>
  }

  export type PropuestaUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<PropuestaCreateWithoutEstudianteInput, PropuestaUncheckedCreateWithoutEstudianteInput> | PropuestaCreateWithoutEstudianteInput[] | PropuestaUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: PropuestaCreateOrConnectWithoutEstudianteInput | PropuestaCreateOrConnectWithoutEstudianteInput[]
    upsert?: PropuestaUpsertWithWhereUniqueWithoutEstudianteInput | PropuestaUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: PropuestaCreateManyEstudianteInputEnvelope
    set?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    disconnect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    delete?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    connect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    update?: PropuestaUpdateWithWhereUniqueWithoutEstudianteInput | PropuestaUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: PropuestaUpdateManyWithWhereWithoutEstudianteInput | PropuestaUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: PropuestaScalarWhereInput | PropuestaScalarWhereInput[]
  }

  export type ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput> | ComentarioCreateWithoutUsuarioInput[] | ComentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutUsuarioInput | ComentarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: ComentarioUpsertWithWhereUniqueWithoutUsuarioInput | ComentarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    set?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    disconnect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    delete?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    update?: ComentarioUpdateWithWhereUniqueWithoutUsuarioInput | ComentarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ComentarioUpdateManyWithWhereWithoutUsuarioInput | ComentarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
  }

  export type NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput> | NotificacionCreateWithoutUsuarioInput[] | NotificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutUsuarioInput | NotificacionCreateOrConnectWithoutUsuarioInput[]
    upsert?: NotificacionUpsertWithWhereUniqueWithoutUsuarioInput | NotificacionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: NotificacionCreateManyUsuarioInputEnvelope
    set?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    disconnect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    delete?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    update?: NotificacionUpdateWithWhereUniqueWithoutUsuarioInput | NotificacionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: NotificacionUpdateManyWithWhereWithoutUsuarioInput | NotificacionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
  }

  export type ComiteUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ComiteCreateWithoutUsuarioInput, ComiteUncheckedCreateWithoutUsuarioInput> | ComiteCreateWithoutUsuarioInput[] | ComiteUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComiteCreateOrConnectWithoutUsuarioInput | ComiteCreateOrConnectWithoutUsuarioInput[]
    upsert?: ComiteUpsertWithWhereUniqueWithoutUsuarioInput | ComiteUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ComiteCreateManyUsuarioInputEnvelope
    set?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    disconnect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    delete?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    connect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    update?: ComiteUpdateWithWhereUniqueWithoutUsuarioInput | ComiteUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ComiteUpdateManyWithWhereWithoutUsuarioInput | ComiteUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ComiteScalarWhereInput | ComiteScalarWhereInput[]
  }

  export type EstudiantePrerequisitoUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<EstudiantePrerequisitoCreateWithoutEstudianteInput, EstudiantePrerequisitoUncheckedCreateWithoutEstudianteInput> | EstudiantePrerequisitoCreateWithoutEstudianteInput[] | EstudiantePrerequisitoUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: EstudiantePrerequisitoCreateOrConnectWithoutEstudianteInput | EstudiantePrerequisitoCreateOrConnectWithoutEstudianteInput[]
    upsert?: EstudiantePrerequisitoUpsertWithWhereUniqueWithoutEstudianteInput | EstudiantePrerequisitoUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: EstudiantePrerequisitoCreateManyEstudianteInputEnvelope
    set?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
    disconnect?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
    delete?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
    connect?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
    update?: EstudiantePrerequisitoUpdateWithWhereUniqueWithoutEstudianteInput | EstudiantePrerequisitoUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: EstudiantePrerequisitoUpdateManyWithWhereWithoutEstudianteInput | EstudiantePrerequisitoUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: EstudiantePrerequisitoScalarWhereInput | EstudiantePrerequisitoScalarWhereInput[]
  }

  export type EstudiantePerfilUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<EstudiantePerfilCreateWithoutUsuarioInput, EstudiantePerfilUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EstudiantePerfilCreateOrConnectWithoutUsuarioInput
    upsert?: EstudiantePerfilUpsertWithoutUsuarioInput
    disconnect?: EstudiantePerfilWhereInput | boolean
    delete?: EstudiantePerfilWhereInput | boolean
    connect?: EstudiantePerfilWhereUniqueInput
    update?: XOR<XOR<EstudiantePerfilUpdateToOneWithWhereWithoutUsuarioInput, EstudiantePerfilUpdateWithoutUsuarioInput>, EstudiantePerfilUncheckedUpdateWithoutUsuarioInput>
  }

  export type UsuarioCreateNestedOneWithoutAuthInput = {
    create?: XOR<UsuarioCreateWithoutAuthInput, UsuarioUncheckedCreateWithoutAuthInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAuthInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutAuthNestedInput = {
    create?: XOR<UsuarioCreateWithoutAuthInput, UsuarioUncheckedCreateWithoutAuthInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAuthInput
    upsert?: UsuarioUpsertWithoutAuthInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutAuthInput, UsuarioUpdateWithoutAuthInput>, UsuarioUncheckedUpdateWithoutAuthInput>
  }

  export type PropuestaCreateNestedManyWithoutAreaConocimientoInput = {
    create?: XOR<PropuestaCreateWithoutAreaConocimientoInput, PropuestaUncheckedCreateWithoutAreaConocimientoInput> | PropuestaCreateWithoutAreaConocimientoInput[] | PropuestaUncheckedCreateWithoutAreaConocimientoInput[]
    connectOrCreate?: PropuestaCreateOrConnectWithoutAreaConocimientoInput | PropuestaCreateOrConnectWithoutAreaConocimientoInput[]
    createMany?: PropuestaCreateManyAreaConocimientoInputEnvelope
    connect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
  }

  export type PropuestaUncheckedCreateNestedManyWithoutAreaConocimientoInput = {
    create?: XOR<PropuestaCreateWithoutAreaConocimientoInput, PropuestaUncheckedCreateWithoutAreaConocimientoInput> | PropuestaCreateWithoutAreaConocimientoInput[] | PropuestaUncheckedCreateWithoutAreaConocimientoInput[]
    connectOrCreate?: PropuestaCreateOrConnectWithoutAreaConocimientoInput | PropuestaCreateOrConnectWithoutAreaConocimientoInput[]
    createMany?: PropuestaCreateManyAreaConocimientoInputEnvelope
    connect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type PropuestaUpdateManyWithoutAreaConocimientoNestedInput = {
    create?: XOR<PropuestaCreateWithoutAreaConocimientoInput, PropuestaUncheckedCreateWithoutAreaConocimientoInput> | PropuestaCreateWithoutAreaConocimientoInput[] | PropuestaUncheckedCreateWithoutAreaConocimientoInput[]
    connectOrCreate?: PropuestaCreateOrConnectWithoutAreaConocimientoInput | PropuestaCreateOrConnectWithoutAreaConocimientoInput[]
    upsert?: PropuestaUpsertWithWhereUniqueWithoutAreaConocimientoInput | PropuestaUpsertWithWhereUniqueWithoutAreaConocimientoInput[]
    createMany?: PropuestaCreateManyAreaConocimientoInputEnvelope
    set?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    disconnect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    delete?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    connect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    update?: PropuestaUpdateWithWhereUniqueWithoutAreaConocimientoInput | PropuestaUpdateWithWhereUniqueWithoutAreaConocimientoInput[]
    updateMany?: PropuestaUpdateManyWithWhereWithoutAreaConocimientoInput | PropuestaUpdateManyWithWhereWithoutAreaConocimientoInput[]
    deleteMany?: PropuestaScalarWhereInput | PropuestaScalarWhereInput[]
  }

  export type PropuestaUncheckedUpdateManyWithoutAreaConocimientoNestedInput = {
    create?: XOR<PropuestaCreateWithoutAreaConocimientoInput, PropuestaUncheckedCreateWithoutAreaConocimientoInput> | PropuestaCreateWithoutAreaConocimientoInput[] | PropuestaUncheckedCreateWithoutAreaConocimientoInput[]
    connectOrCreate?: PropuestaCreateOrConnectWithoutAreaConocimientoInput | PropuestaCreateOrConnectWithoutAreaConocimientoInput[]
    upsert?: PropuestaUpsertWithWhereUniqueWithoutAreaConocimientoInput | PropuestaUpsertWithWhereUniqueWithoutAreaConocimientoInput[]
    createMany?: PropuestaCreateManyAreaConocimientoInputEnvelope
    set?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    disconnect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    delete?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    connect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    update?: PropuestaUpdateWithWhereUniqueWithoutAreaConocimientoInput | PropuestaUpdateWithWhereUniqueWithoutAreaConocimientoInput[]
    updateMany?: PropuestaUpdateManyWithWhereWithoutAreaConocimientoInput | PropuestaUpdateManyWithWhereWithoutAreaConocimientoInput[]
    deleteMany?: PropuestaScalarWhereInput | PropuestaScalarWhereInput[]
  }

  export type AreaConocimientoCreateNestedOneWithoutPropuestasInput = {
    create?: XOR<AreaConocimientoCreateWithoutPropuestasInput, AreaConocimientoUncheckedCreateWithoutPropuestasInput>
    connectOrCreate?: AreaConocimientoCreateOrConnectWithoutPropuestasInput
    connect?: AreaConocimientoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutPropuestasInput = {
    create?: XOR<UsuarioCreateWithoutPropuestasInput, UsuarioUncheckedCreateWithoutPropuestasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPropuestasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type TrabajoTitulacionCreateNestedManyWithoutPropuestaInput = {
    create?: XOR<TrabajoTitulacionCreateWithoutPropuestaInput, TrabajoTitulacionUncheckedCreateWithoutPropuestaInput> | TrabajoTitulacionCreateWithoutPropuestaInput[] | TrabajoTitulacionUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: TrabajoTitulacionCreateOrConnectWithoutPropuestaInput | TrabajoTitulacionCreateOrConnectWithoutPropuestaInput[]
    createMany?: TrabajoTitulacionCreateManyPropuestaInputEnvelope
    connect?: TrabajoTitulacionWhereUniqueInput | TrabajoTitulacionWhereUniqueInput[]
  }

  export type ActividadCreateNestedManyWithoutPropuestaInput = {
    create?: XOR<ActividadCreateWithoutPropuestaInput, ActividadUncheckedCreateWithoutPropuestaInput> | ActividadCreateWithoutPropuestaInput[] | ActividadUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: ActividadCreateOrConnectWithoutPropuestaInput | ActividadCreateOrConnectWithoutPropuestaInput[]
    createMany?: ActividadCreateManyPropuestaInputEnvelope
    connect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
  }

  export type ComiteCreateNestedManyWithoutPropuestaInput = {
    create?: XOR<ComiteCreateWithoutPropuestaInput, ComiteUncheckedCreateWithoutPropuestaInput> | ComiteCreateWithoutPropuestaInput[] | ComiteUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: ComiteCreateOrConnectWithoutPropuestaInput | ComiteCreateOrConnectWithoutPropuestaInput[]
    createMany?: ComiteCreateManyPropuestaInputEnvelope
    connect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
  }

  export type EntregableFinalCreateNestedManyWithoutPropuestaInput = {
    create?: XOR<EntregableFinalCreateWithoutPropuestaInput, EntregableFinalUncheckedCreateWithoutPropuestaInput> | EntregableFinalCreateWithoutPropuestaInput[] | EntregableFinalUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: EntregableFinalCreateOrConnectWithoutPropuestaInput | EntregableFinalCreateOrConnectWithoutPropuestaInput[]
    createMany?: EntregableFinalCreateManyPropuestaInputEnvelope
    connect?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
  }

  export type TrabajoTitulacionUncheckedCreateNestedManyWithoutPropuestaInput = {
    create?: XOR<TrabajoTitulacionCreateWithoutPropuestaInput, TrabajoTitulacionUncheckedCreateWithoutPropuestaInput> | TrabajoTitulacionCreateWithoutPropuestaInput[] | TrabajoTitulacionUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: TrabajoTitulacionCreateOrConnectWithoutPropuestaInput | TrabajoTitulacionCreateOrConnectWithoutPropuestaInput[]
    createMany?: TrabajoTitulacionCreateManyPropuestaInputEnvelope
    connect?: TrabajoTitulacionWhereUniqueInput | TrabajoTitulacionWhereUniqueInput[]
  }

  export type ActividadUncheckedCreateNestedManyWithoutPropuestaInput = {
    create?: XOR<ActividadCreateWithoutPropuestaInput, ActividadUncheckedCreateWithoutPropuestaInput> | ActividadCreateWithoutPropuestaInput[] | ActividadUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: ActividadCreateOrConnectWithoutPropuestaInput | ActividadCreateOrConnectWithoutPropuestaInput[]
    createMany?: ActividadCreateManyPropuestaInputEnvelope
    connect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
  }

  export type ComiteUncheckedCreateNestedManyWithoutPropuestaInput = {
    create?: XOR<ComiteCreateWithoutPropuestaInput, ComiteUncheckedCreateWithoutPropuestaInput> | ComiteCreateWithoutPropuestaInput[] | ComiteUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: ComiteCreateOrConnectWithoutPropuestaInput | ComiteCreateOrConnectWithoutPropuestaInput[]
    createMany?: ComiteCreateManyPropuestaInputEnvelope
    connect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
  }

  export type EntregableFinalUncheckedCreateNestedManyWithoutPropuestaInput = {
    create?: XOR<EntregableFinalCreateWithoutPropuestaInput, EntregableFinalUncheckedCreateWithoutPropuestaInput> | EntregableFinalCreateWithoutPropuestaInput[] | EntregableFinalUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: EntregableFinalCreateOrConnectWithoutPropuestaInput | EntregableFinalCreateOrConnectWithoutPropuestaInput[]
    createMany?: EntregableFinalCreateManyPropuestaInputEnvelope
    connect?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
  }

  export type EnumEstadoPropuestaFieldUpdateOperationsInput = {
    set?: $Enums.EstadoPropuesta
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumResultadoDefensaFieldUpdateOperationsInput = {
    set?: $Enums.ResultadoDefensa | null
  }

  export type AreaConocimientoUpdateOneRequiredWithoutPropuestasNestedInput = {
    create?: XOR<AreaConocimientoCreateWithoutPropuestasInput, AreaConocimientoUncheckedCreateWithoutPropuestasInput>
    connectOrCreate?: AreaConocimientoCreateOrConnectWithoutPropuestasInput
    upsert?: AreaConocimientoUpsertWithoutPropuestasInput
    connect?: AreaConocimientoWhereUniqueInput
    update?: XOR<XOR<AreaConocimientoUpdateToOneWithWhereWithoutPropuestasInput, AreaConocimientoUpdateWithoutPropuestasInput>, AreaConocimientoUncheckedUpdateWithoutPropuestasInput>
  }

  export type UsuarioUpdateOneRequiredWithoutPropuestasNestedInput = {
    create?: XOR<UsuarioCreateWithoutPropuestasInput, UsuarioUncheckedCreateWithoutPropuestasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPropuestasInput
    upsert?: UsuarioUpsertWithoutPropuestasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPropuestasInput, UsuarioUpdateWithoutPropuestasInput>, UsuarioUncheckedUpdateWithoutPropuestasInput>
  }

  export type TrabajoTitulacionUpdateManyWithoutPropuestaNestedInput = {
    create?: XOR<TrabajoTitulacionCreateWithoutPropuestaInput, TrabajoTitulacionUncheckedCreateWithoutPropuestaInput> | TrabajoTitulacionCreateWithoutPropuestaInput[] | TrabajoTitulacionUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: TrabajoTitulacionCreateOrConnectWithoutPropuestaInput | TrabajoTitulacionCreateOrConnectWithoutPropuestaInput[]
    upsert?: TrabajoTitulacionUpsertWithWhereUniqueWithoutPropuestaInput | TrabajoTitulacionUpsertWithWhereUniqueWithoutPropuestaInput[]
    createMany?: TrabajoTitulacionCreateManyPropuestaInputEnvelope
    set?: TrabajoTitulacionWhereUniqueInput | TrabajoTitulacionWhereUniqueInput[]
    disconnect?: TrabajoTitulacionWhereUniqueInput | TrabajoTitulacionWhereUniqueInput[]
    delete?: TrabajoTitulacionWhereUniqueInput | TrabajoTitulacionWhereUniqueInput[]
    connect?: TrabajoTitulacionWhereUniqueInput | TrabajoTitulacionWhereUniqueInput[]
    update?: TrabajoTitulacionUpdateWithWhereUniqueWithoutPropuestaInput | TrabajoTitulacionUpdateWithWhereUniqueWithoutPropuestaInput[]
    updateMany?: TrabajoTitulacionUpdateManyWithWhereWithoutPropuestaInput | TrabajoTitulacionUpdateManyWithWhereWithoutPropuestaInput[]
    deleteMany?: TrabajoTitulacionScalarWhereInput | TrabajoTitulacionScalarWhereInput[]
  }

  export type ActividadUpdateManyWithoutPropuestaNestedInput = {
    create?: XOR<ActividadCreateWithoutPropuestaInput, ActividadUncheckedCreateWithoutPropuestaInput> | ActividadCreateWithoutPropuestaInput[] | ActividadUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: ActividadCreateOrConnectWithoutPropuestaInput | ActividadCreateOrConnectWithoutPropuestaInput[]
    upsert?: ActividadUpsertWithWhereUniqueWithoutPropuestaInput | ActividadUpsertWithWhereUniqueWithoutPropuestaInput[]
    createMany?: ActividadCreateManyPropuestaInputEnvelope
    set?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    disconnect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    delete?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    connect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    update?: ActividadUpdateWithWhereUniqueWithoutPropuestaInput | ActividadUpdateWithWhereUniqueWithoutPropuestaInput[]
    updateMany?: ActividadUpdateManyWithWhereWithoutPropuestaInput | ActividadUpdateManyWithWhereWithoutPropuestaInput[]
    deleteMany?: ActividadScalarWhereInput | ActividadScalarWhereInput[]
  }

  export type ComiteUpdateManyWithoutPropuestaNestedInput = {
    create?: XOR<ComiteCreateWithoutPropuestaInput, ComiteUncheckedCreateWithoutPropuestaInput> | ComiteCreateWithoutPropuestaInput[] | ComiteUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: ComiteCreateOrConnectWithoutPropuestaInput | ComiteCreateOrConnectWithoutPropuestaInput[]
    upsert?: ComiteUpsertWithWhereUniqueWithoutPropuestaInput | ComiteUpsertWithWhereUniqueWithoutPropuestaInput[]
    createMany?: ComiteCreateManyPropuestaInputEnvelope
    set?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    disconnect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    delete?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    connect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    update?: ComiteUpdateWithWhereUniqueWithoutPropuestaInput | ComiteUpdateWithWhereUniqueWithoutPropuestaInput[]
    updateMany?: ComiteUpdateManyWithWhereWithoutPropuestaInput | ComiteUpdateManyWithWhereWithoutPropuestaInput[]
    deleteMany?: ComiteScalarWhereInput | ComiteScalarWhereInput[]
  }

  export type EntregableFinalUpdateManyWithoutPropuestaNestedInput = {
    create?: XOR<EntregableFinalCreateWithoutPropuestaInput, EntregableFinalUncheckedCreateWithoutPropuestaInput> | EntregableFinalCreateWithoutPropuestaInput[] | EntregableFinalUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: EntregableFinalCreateOrConnectWithoutPropuestaInput | EntregableFinalCreateOrConnectWithoutPropuestaInput[]
    upsert?: EntregableFinalUpsertWithWhereUniqueWithoutPropuestaInput | EntregableFinalUpsertWithWhereUniqueWithoutPropuestaInput[]
    createMany?: EntregableFinalCreateManyPropuestaInputEnvelope
    set?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
    disconnect?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
    delete?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
    connect?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
    update?: EntregableFinalUpdateWithWhereUniqueWithoutPropuestaInput | EntregableFinalUpdateWithWhereUniqueWithoutPropuestaInput[]
    updateMany?: EntregableFinalUpdateManyWithWhereWithoutPropuestaInput | EntregableFinalUpdateManyWithWhereWithoutPropuestaInput[]
    deleteMany?: EntregableFinalScalarWhereInput | EntregableFinalScalarWhereInput[]
  }

  export type TrabajoTitulacionUncheckedUpdateManyWithoutPropuestaNestedInput = {
    create?: XOR<TrabajoTitulacionCreateWithoutPropuestaInput, TrabajoTitulacionUncheckedCreateWithoutPropuestaInput> | TrabajoTitulacionCreateWithoutPropuestaInput[] | TrabajoTitulacionUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: TrabajoTitulacionCreateOrConnectWithoutPropuestaInput | TrabajoTitulacionCreateOrConnectWithoutPropuestaInput[]
    upsert?: TrabajoTitulacionUpsertWithWhereUniqueWithoutPropuestaInput | TrabajoTitulacionUpsertWithWhereUniqueWithoutPropuestaInput[]
    createMany?: TrabajoTitulacionCreateManyPropuestaInputEnvelope
    set?: TrabajoTitulacionWhereUniqueInput | TrabajoTitulacionWhereUniqueInput[]
    disconnect?: TrabajoTitulacionWhereUniqueInput | TrabajoTitulacionWhereUniqueInput[]
    delete?: TrabajoTitulacionWhereUniqueInput | TrabajoTitulacionWhereUniqueInput[]
    connect?: TrabajoTitulacionWhereUniqueInput | TrabajoTitulacionWhereUniqueInput[]
    update?: TrabajoTitulacionUpdateWithWhereUniqueWithoutPropuestaInput | TrabajoTitulacionUpdateWithWhereUniqueWithoutPropuestaInput[]
    updateMany?: TrabajoTitulacionUpdateManyWithWhereWithoutPropuestaInput | TrabajoTitulacionUpdateManyWithWhereWithoutPropuestaInput[]
    deleteMany?: TrabajoTitulacionScalarWhereInput | TrabajoTitulacionScalarWhereInput[]
  }

  export type ActividadUncheckedUpdateManyWithoutPropuestaNestedInput = {
    create?: XOR<ActividadCreateWithoutPropuestaInput, ActividadUncheckedCreateWithoutPropuestaInput> | ActividadCreateWithoutPropuestaInput[] | ActividadUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: ActividadCreateOrConnectWithoutPropuestaInput | ActividadCreateOrConnectWithoutPropuestaInput[]
    upsert?: ActividadUpsertWithWhereUniqueWithoutPropuestaInput | ActividadUpsertWithWhereUniqueWithoutPropuestaInput[]
    createMany?: ActividadCreateManyPropuestaInputEnvelope
    set?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    disconnect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    delete?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    connect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    update?: ActividadUpdateWithWhereUniqueWithoutPropuestaInput | ActividadUpdateWithWhereUniqueWithoutPropuestaInput[]
    updateMany?: ActividadUpdateManyWithWhereWithoutPropuestaInput | ActividadUpdateManyWithWhereWithoutPropuestaInput[]
    deleteMany?: ActividadScalarWhereInput | ActividadScalarWhereInput[]
  }

  export type ComiteUncheckedUpdateManyWithoutPropuestaNestedInput = {
    create?: XOR<ComiteCreateWithoutPropuestaInput, ComiteUncheckedCreateWithoutPropuestaInput> | ComiteCreateWithoutPropuestaInput[] | ComiteUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: ComiteCreateOrConnectWithoutPropuestaInput | ComiteCreateOrConnectWithoutPropuestaInput[]
    upsert?: ComiteUpsertWithWhereUniqueWithoutPropuestaInput | ComiteUpsertWithWhereUniqueWithoutPropuestaInput[]
    createMany?: ComiteCreateManyPropuestaInputEnvelope
    set?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    disconnect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    delete?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    connect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    update?: ComiteUpdateWithWhereUniqueWithoutPropuestaInput | ComiteUpdateWithWhereUniqueWithoutPropuestaInput[]
    updateMany?: ComiteUpdateManyWithWhereWithoutPropuestaInput | ComiteUpdateManyWithWhereWithoutPropuestaInput[]
    deleteMany?: ComiteScalarWhereInput | ComiteScalarWhereInput[]
  }

  export type EntregableFinalUncheckedUpdateManyWithoutPropuestaNestedInput = {
    create?: XOR<EntregableFinalCreateWithoutPropuestaInput, EntregableFinalUncheckedCreateWithoutPropuestaInput> | EntregableFinalCreateWithoutPropuestaInput[] | EntregableFinalUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: EntregableFinalCreateOrConnectWithoutPropuestaInput | EntregableFinalCreateOrConnectWithoutPropuestaInput[]
    upsert?: EntregableFinalUpsertWithWhereUniqueWithoutPropuestaInput | EntregableFinalUpsertWithWhereUniqueWithoutPropuestaInput[]
    createMany?: EntregableFinalCreateManyPropuestaInputEnvelope
    set?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
    disconnect?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
    delete?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
    connect?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
    update?: EntregableFinalUpdateWithWhereUniqueWithoutPropuestaInput | EntregableFinalUpdateWithWhereUniqueWithoutPropuestaInput[]
    updateMany?: EntregableFinalUpdateManyWithWhereWithoutPropuestaInput | EntregableFinalUpdateManyWithWhereWithoutPropuestaInput[]
    deleteMany?: EntregableFinalScalarWhereInput | EntregableFinalScalarWhereInput[]
  }

  export type PropuestaCreateNestedOneWithoutTrabajosTitulacionInput = {
    create?: XOR<PropuestaCreateWithoutTrabajosTitulacionInput, PropuestaUncheckedCreateWithoutTrabajosTitulacionInput>
    connectOrCreate?: PropuestaCreateOrConnectWithoutTrabajosTitulacionInput
    connect?: PropuestaWhereUniqueInput
  }

  export type PropuestaUpdateOneRequiredWithoutTrabajosTitulacionNestedInput = {
    create?: XOR<PropuestaCreateWithoutTrabajosTitulacionInput, PropuestaUncheckedCreateWithoutTrabajosTitulacionInput>
    connectOrCreate?: PropuestaCreateOrConnectWithoutTrabajosTitulacionInput
    upsert?: PropuestaUpsertWithoutTrabajosTitulacionInput
    connect?: PropuestaWhereUniqueInput
    update?: XOR<XOR<PropuestaUpdateToOneWithWhereWithoutTrabajosTitulacionInput, PropuestaUpdateWithoutTrabajosTitulacionInput>, PropuestaUncheckedUpdateWithoutTrabajosTitulacionInput>
  }

  export type PropuestaCreateNestedOneWithoutActividadesInput = {
    create?: XOR<PropuestaCreateWithoutActividadesInput, PropuestaUncheckedCreateWithoutActividadesInput>
    connectOrCreate?: PropuestaCreateOrConnectWithoutActividadesInput
    connect?: PropuestaWhereUniqueInput
  }

  export type EvidenciaCreateNestedManyWithoutActividadInput = {
    create?: XOR<EvidenciaCreateWithoutActividadInput, EvidenciaUncheckedCreateWithoutActividadInput> | EvidenciaCreateWithoutActividadInput[] | EvidenciaUncheckedCreateWithoutActividadInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutActividadInput | EvidenciaCreateOrConnectWithoutActividadInput[]
    createMany?: EvidenciaCreateManyActividadInputEnvelope
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
  }

  export type EvidenciaUncheckedCreateNestedManyWithoutActividadInput = {
    create?: XOR<EvidenciaCreateWithoutActividadInput, EvidenciaUncheckedCreateWithoutActividadInput> | EvidenciaCreateWithoutActividadInput[] | EvidenciaUncheckedCreateWithoutActividadInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutActividadInput | EvidenciaCreateOrConnectWithoutActividadInput[]
    createMany?: EvidenciaCreateManyActividadInputEnvelope
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
  }

  export type EnumTipoActividadFieldUpdateOperationsInput = {
    set?: $Enums.TipoActividad
  }

  export type PropuestaUpdateOneRequiredWithoutActividadesNestedInput = {
    create?: XOR<PropuestaCreateWithoutActividadesInput, PropuestaUncheckedCreateWithoutActividadesInput>
    connectOrCreate?: PropuestaCreateOrConnectWithoutActividadesInput
    upsert?: PropuestaUpsertWithoutActividadesInput
    connect?: PropuestaWhereUniqueInput
    update?: XOR<XOR<PropuestaUpdateToOneWithWhereWithoutActividadesInput, PropuestaUpdateWithoutActividadesInput>, PropuestaUncheckedUpdateWithoutActividadesInput>
  }

  export type EvidenciaUpdateManyWithoutActividadNestedInput = {
    create?: XOR<EvidenciaCreateWithoutActividadInput, EvidenciaUncheckedCreateWithoutActividadInput> | EvidenciaCreateWithoutActividadInput[] | EvidenciaUncheckedCreateWithoutActividadInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutActividadInput | EvidenciaCreateOrConnectWithoutActividadInput[]
    upsert?: EvidenciaUpsertWithWhereUniqueWithoutActividadInput | EvidenciaUpsertWithWhereUniqueWithoutActividadInput[]
    createMany?: EvidenciaCreateManyActividadInputEnvelope
    set?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    disconnect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    delete?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    update?: EvidenciaUpdateWithWhereUniqueWithoutActividadInput | EvidenciaUpdateWithWhereUniqueWithoutActividadInput[]
    updateMany?: EvidenciaUpdateManyWithWhereWithoutActividadInput | EvidenciaUpdateManyWithWhereWithoutActividadInput[]
    deleteMany?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
  }

  export type EvidenciaUncheckedUpdateManyWithoutActividadNestedInput = {
    create?: XOR<EvidenciaCreateWithoutActividadInput, EvidenciaUncheckedCreateWithoutActividadInput> | EvidenciaCreateWithoutActividadInput[] | EvidenciaUncheckedCreateWithoutActividadInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutActividadInput | EvidenciaCreateOrConnectWithoutActividadInput[]
    upsert?: EvidenciaUpsertWithWhereUniqueWithoutActividadInput | EvidenciaUpsertWithWhereUniqueWithoutActividadInput[]
    createMany?: EvidenciaCreateManyActividadInputEnvelope
    set?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    disconnect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    delete?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    update?: EvidenciaUpdateWithWhereUniqueWithoutActividadInput | EvidenciaUpdateWithWhereUniqueWithoutActividadInput[]
    updateMany?: EvidenciaUpdateManyWithWhereWithoutActividadInput | EvidenciaUpdateManyWithWhereWithoutActividadInput[]
    deleteMany?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
  }

  export type ActividadCreateNestedOneWithoutEvidenciasInput = {
    create?: XOR<ActividadCreateWithoutEvidenciasInput, ActividadUncheckedCreateWithoutEvidenciasInput>
    connectOrCreate?: ActividadCreateOrConnectWithoutEvidenciasInput
    connect?: ActividadWhereUniqueInput
  }

  export type ComentarioCreateNestedManyWithoutEvidenciaInput = {
    create?: XOR<ComentarioCreateWithoutEvidenciaInput, ComentarioUncheckedCreateWithoutEvidenciaInput> | ComentarioCreateWithoutEvidenciaInput[] | ComentarioUncheckedCreateWithoutEvidenciaInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutEvidenciaInput | ComentarioCreateOrConnectWithoutEvidenciaInput[]
    createMany?: ComentarioCreateManyEvidenciaInputEnvelope
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
  }

  export type ComentarioUncheckedCreateNestedManyWithoutEvidenciaInput = {
    create?: XOR<ComentarioCreateWithoutEvidenciaInput, ComentarioUncheckedCreateWithoutEvidenciaInput> | ComentarioCreateWithoutEvidenciaInput[] | ComentarioUncheckedCreateWithoutEvidenciaInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutEvidenciaInput | ComentarioCreateOrConnectWithoutEvidenciaInput[]
    createMany?: ComentarioCreateManyEvidenciaInputEnvelope
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
  }

  export type EnumEstadoEvidenciaFieldUpdateOperationsInput = {
    set?: $Enums.EstadoEvidencia
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ActividadUpdateOneRequiredWithoutEvidenciasNestedInput = {
    create?: XOR<ActividadCreateWithoutEvidenciasInput, ActividadUncheckedCreateWithoutEvidenciasInput>
    connectOrCreate?: ActividadCreateOrConnectWithoutEvidenciasInput
    upsert?: ActividadUpsertWithoutEvidenciasInput
    connect?: ActividadWhereUniqueInput
    update?: XOR<XOR<ActividadUpdateToOneWithWhereWithoutEvidenciasInput, ActividadUpdateWithoutEvidenciasInput>, ActividadUncheckedUpdateWithoutEvidenciasInput>
  }

  export type ComentarioUpdateManyWithoutEvidenciaNestedInput = {
    create?: XOR<ComentarioCreateWithoutEvidenciaInput, ComentarioUncheckedCreateWithoutEvidenciaInput> | ComentarioCreateWithoutEvidenciaInput[] | ComentarioUncheckedCreateWithoutEvidenciaInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutEvidenciaInput | ComentarioCreateOrConnectWithoutEvidenciaInput[]
    upsert?: ComentarioUpsertWithWhereUniqueWithoutEvidenciaInput | ComentarioUpsertWithWhereUniqueWithoutEvidenciaInput[]
    createMany?: ComentarioCreateManyEvidenciaInputEnvelope
    set?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    disconnect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    delete?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    update?: ComentarioUpdateWithWhereUniqueWithoutEvidenciaInput | ComentarioUpdateWithWhereUniqueWithoutEvidenciaInput[]
    updateMany?: ComentarioUpdateManyWithWhereWithoutEvidenciaInput | ComentarioUpdateManyWithWhereWithoutEvidenciaInput[]
    deleteMany?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
  }

  export type ComentarioUncheckedUpdateManyWithoutEvidenciaNestedInput = {
    create?: XOR<ComentarioCreateWithoutEvidenciaInput, ComentarioUncheckedCreateWithoutEvidenciaInput> | ComentarioCreateWithoutEvidenciaInput[] | ComentarioUncheckedCreateWithoutEvidenciaInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutEvidenciaInput | ComentarioCreateOrConnectWithoutEvidenciaInput[]
    upsert?: ComentarioUpsertWithWhereUniqueWithoutEvidenciaInput | ComentarioUpsertWithWhereUniqueWithoutEvidenciaInput[]
    createMany?: ComentarioCreateManyEvidenciaInputEnvelope
    set?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    disconnect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    delete?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    update?: ComentarioUpdateWithWhereUniqueWithoutEvidenciaInput | ComentarioUpdateWithWhereUniqueWithoutEvidenciaInput[]
    updateMany?: ComentarioUpdateManyWithWhereWithoutEvidenciaInput | ComentarioUpdateManyWithWhereWithoutEvidenciaInput[]
    deleteMany?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
  }

  export type EvidenciaCreateNestedOneWithoutComentariosInput = {
    create?: XOR<EvidenciaCreateWithoutComentariosInput, EvidenciaUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: EvidenciaCreateOrConnectWithoutComentariosInput
    connect?: EvidenciaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutComentariosInput = {
    create?: XOR<UsuarioCreateWithoutComentariosInput, UsuarioUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComentariosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EvidenciaUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<EvidenciaCreateWithoutComentariosInput, EvidenciaUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: EvidenciaCreateOrConnectWithoutComentariosInput
    upsert?: EvidenciaUpsertWithoutComentariosInput
    connect?: EvidenciaWhereUniqueInput
    update?: XOR<XOR<EvidenciaUpdateToOneWithWhereWithoutComentariosInput, EvidenciaUpdateWithoutComentariosInput>, EvidenciaUncheckedUpdateWithoutComentariosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<UsuarioCreateWithoutComentariosInput, UsuarioUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComentariosInput
    upsert?: UsuarioUpsertWithoutComentariosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutComentariosInput, UsuarioUpdateWithoutComentariosInput>, UsuarioUncheckedUpdateWithoutComentariosInput>
  }

  export type EstudiantePrerequisitoCreateNestedManyWithoutPrerequisitoInput = {
    create?: XOR<EstudiantePrerequisitoCreateWithoutPrerequisitoInput, EstudiantePrerequisitoUncheckedCreateWithoutPrerequisitoInput> | EstudiantePrerequisitoCreateWithoutPrerequisitoInput[] | EstudiantePrerequisitoUncheckedCreateWithoutPrerequisitoInput[]
    connectOrCreate?: EstudiantePrerequisitoCreateOrConnectWithoutPrerequisitoInput | EstudiantePrerequisitoCreateOrConnectWithoutPrerequisitoInput[]
    createMany?: EstudiantePrerequisitoCreateManyPrerequisitoInputEnvelope
    connect?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
  }

  export type EstudiantePrerequisitoUncheckedCreateNestedManyWithoutPrerequisitoInput = {
    create?: XOR<EstudiantePrerequisitoCreateWithoutPrerequisitoInput, EstudiantePrerequisitoUncheckedCreateWithoutPrerequisitoInput> | EstudiantePrerequisitoCreateWithoutPrerequisitoInput[] | EstudiantePrerequisitoUncheckedCreateWithoutPrerequisitoInput[]
    connectOrCreate?: EstudiantePrerequisitoCreateOrConnectWithoutPrerequisitoInput | EstudiantePrerequisitoCreateOrConnectWithoutPrerequisitoInput[]
    createMany?: EstudiantePrerequisitoCreateManyPrerequisitoInputEnvelope
    connect?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EstudiantePrerequisitoUpdateManyWithoutPrerequisitoNestedInput = {
    create?: XOR<EstudiantePrerequisitoCreateWithoutPrerequisitoInput, EstudiantePrerequisitoUncheckedCreateWithoutPrerequisitoInput> | EstudiantePrerequisitoCreateWithoutPrerequisitoInput[] | EstudiantePrerequisitoUncheckedCreateWithoutPrerequisitoInput[]
    connectOrCreate?: EstudiantePrerequisitoCreateOrConnectWithoutPrerequisitoInput | EstudiantePrerequisitoCreateOrConnectWithoutPrerequisitoInput[]
    upsert?: EstudiantePrerequisitoUpsertWithWhereUniqueWithoutPrerequisitoInput | EstudiantePrerequisitoUpsertWithWhereUniqueWithoutPrerequisitoInput[]
    createMany?: EstudiantePrerequisitoCreateManyPrerequisitoInputEnvelope
    set?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
    disconnect?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
    delete?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
    connect?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
    update?: EstudiantePrerequisitoUpdateWithWhereUniqueWithoutPrerequisitoInput | EstudiantePrerequisitoUpdateWithWhereUniqueWithoutPrerequisitoInput[]
    updateMany?: EstudiantePrerequisitoUpdateManyWithWhereWithoutPrerequisitoInput | EstudiantePrerequisitoUpdateManyWithWhereWithoutPrerequisitoInput[]
    deleteMany?: EstudiantePrerequisitoScalarWhereInput | EstudiantePrerequisitoScalarWhereInput[]
  }

  export type EstudiantePrerequisitoUncheckedUpdateManyWithoutPrerequisitoNestedInput = {
    create?: XOR<EstudiantePrerequisitoCreateWithoutPrerequisitoInput, EstudiantePrerequisitoUncheckedCreateWithoutPrerequisitoInput> | EstudiantePrerequisitoCreateWithoutPrerequisitoInput[] | EstudiantePrerequisitoUncheckedCreateWithoutPrerequisitoInput[]
    connectOrCreate?: EstudiantePrerequisitoCreateOrConnectWithoutPrerequisitoInput | EstudiantePrerequisitoCreateOrConnectWithoutPrerequisitoInput[]
    upsert?: EstudiantePrerequisitoUpsertWithWhereUniqueWithoutPrerequisitoInput | EstudiantePrerequisitoUpsertWithWhereUniqueWithoutPrerequisitoInput[]
    createMany?: EstudiantePrerequisitoCreateManyPrerequisitoInputEnvelope
    set?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
    disconnect?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
    delete?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
    connect?: EstudiantePrerequisitoWhereUniqueInput | EstudiantePrerequisitoWhereUniqueInput[]
    update?: EstudiantePrerequisitoUpdateWithWhereUniqueWithoutPrerequisitoInput | EstudiantePrerequisitoUpdateWithWhereUniqueWithoutPrerequisitoInput[]
    updateMany?: EstudiantePrerequisitoUpdateManyWithWhereWithoutPrerequisitoInput | EstudiantePrerequisitoUpdateManyWithWhereWithoutPrerequisitoInput[]
    deleteMany?: EstudiantePrerequisitoScalarWhereInput | EstudiantePrerequisitoScalarWhereInput[]
  }

  export type CatalogoPrerequisitoCreateNestedOneWithoutEstudiantePrerequisitosInput = {
    create?: XOR<CatalogoPrerequisitoCreateWithoutEstudiantePrerequisitosInput, CatalogoPrerequisitoUncheckedCreateWithoutEstudiantePrerequisitosInput>
    connectOrCreate?: CatalogoPrerequisitoCreateOrConnectWithoutEstudiantePrerequisitosInput
    connect?: CatalogoPrerequisitoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutPrerequisitosInput = {
    create?: XOR<UsuarioCreateWithoutPrerequisitosInput, UsuarioUncheckedCreateWithoutPrerequisitosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPrerequisitosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type CatalogoPrerequisitoUpdateOneRequiredWithoutEstudiantePrerequisitosNestedInput = {
    create?: XOR<CatalogoPrerequisitoCreateWithoutEstudiantePrerequisitosInput, CatalogoPrerequisitoUncheckedCreateWithoutEstudiantePrerequisitosInput>
    connectOrCreate?: CatalogoPrerequisitoCreateOrConnectWithoutEstudiantePrerequisitosInput
    upsert?: CatalogoPrerequisitoUpsertWithoutEstudiantePrerequisitosInput
    connect?: CatalogoPrerequisitoWhereUniqueInput
    update?: XOR<XOR<CatalogoPrerequisitoUpdateToOneWithWhereWithoutEstudiantePrerequisitosInput, CatalogoPrerequisitoUpdateWithoutEstudiantePrerequisitosInput>, CatalogoPrerequisitoUncheckedUpdateWithoutEstudiantePrerequisitosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutPrerequisitosNestedInput = {
    create?: XOR<UsuarioCreateWithoutPrerequisitosInput, UsuarioUncheckedCreateWithoutPrerequisitosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPrerequisitosInput
    upsert?: UsuarioUpsertWithoutPrerequisitosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPrerequisitosInput, UsuarioUpdateWithoutPrerequisitosInput>, UsuarioUncheckedUpdateWithoutPrerequisitosInput>
  }

  export type UsuarioCreateNestedOneWithoutNotificacionesInput = {
    create?: XOR<UsuarioCreateWithoutNotificacionesInput, UsuarioUncheckedCreateWithoutNotificacionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutNotificacionesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutNotificacionesNestedInput = {
    create?: XOR<UsuarioCreateWithoutNotificacionesInput, UsuarioUncheckedCreateWithoutNotificacionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutNotificacionesInput
    upsert?: UsuarioUpsertWithoutNotificacionesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutNotificacionesInput, UsuarioUpdateWithoutNotificacionesInput>, UsuarioUncheckedUpdateWithoutNotificacionesInput>
  }

  export type PropuestaCreateNestedOneWithoutEntregablesFinalesInput = {
    create?: XOR<PropuestaCreateWithoutEntregablesFinalesInput, PropuestaUncheckedCreateWithoutEntregablesFinalesInput>
    connectOrCreate?: PropuestaCreateOrConnectWithoutEntregablesFinalesInput
    connect?: PropuestaWhereUniqueInput
  }

  export type EnumTipoEntregableFieldUpdateOperationsInput = {
    set?: $Enums.TipoEntregable
  }

  export type PropuestaUpdateOneRequiredWithoutEntregablesFinalesNestedInput = {
    create?: XOR<PropuestaCreateWithoutEntregablesFinalesInput, PropuestaUncheckedCreateWithoutEntregablesFinalesInput>
    connectOrCreate?: PropuestaCreateOrConnectWithoutEntregablesFinalesInput
    upsert?: PropuestaUpsertWithoutEntregablesFinalesInput
    connect?: PropuestaWhereUniqueInput
    update?: XOR<XOR<PropuestaUpdateToOneWithWhereWithoutEntregablesFinalesInput, PropuestaUpdateWithoutEntregablesFinalesInput>, PropuestaUncheckedUpdateWithoutEntregablesFinalesInput>
  }

  export type UsuarioCreateNestedOneWithoutComitesInput = {
    create?: XOR<UsuarioCreateWithoutComitesInput, UsuarioUncheckedCreateWithoutComitesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComitesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type PropuestaCreateNestedOneWithoutComitesInput = {
    create?: XOR<PropuestaCreateWithoutComitesInput, PropuestaUncheckedCreateWithoutComitesInput>
    connectOrCreate?: PropuestaCreateOrConnectWithoutComitesInput
    connect?: PropuestaWhereUniqueInput
  }

  export type EnumRolComiteFieldUpdateOperationsInput = {
    set?: $Enums.RolComite
  }

  export type UsuarioUpdateOneRequiredWithoutComitesNestedInput = {
    create?: XOR<UsuarioCreateWithoutComitesInput, UsuarioUncheckedCreateWithoutComitesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComitesInput
    upsert?: UsuarioUpsertWithoutComitesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutComitesInput, UsuarioUpdateWithoutComitesInput>, UsuarioUncheckedUpdateWithoutComitesInput>
  }

  export type PropuestaUpdateOneRequiredWithoutComitesNestedInput = {
    create?: XOR<PropuestaCreateWithoutComitesInput, PropuestaUncheckedCreateWithoutComitesInput>
    connectOrCreate?: PropuestaCreateOrConnectWithoutComitesInput
    upsert?: PropuestaUpsertWithoutComitesInput
    connect?: PropuestaWhereUniqueInput
    update?: XOR<XOR<PropuestaUpdateToOneWithWhereWithoutComitesInput, PropuestaUpdateWithoutComitesInput>, PropuestaUncheckedUpdateWithoutComitesInput>
  }

  export type UsuarioCreateNestedOneWithoutEstudiantePerfilInput = {
    create?: XOR<UsuarioCreateWithoutEstudiantePerfilInput, UsuarioUncheckedCreateWithoutEstudiantePerfilInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEstudiantePerfilInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutEstudiantePerfilNestedInput = {
    create?: XOR<UsuarioCreateWithoutEstudiantePerfilInput, UsuarioUncheckedCreateWithoutEstudiantePerfilInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEstudiantePerfilInput
    upsert?: UsuarioUpsertWithoutEstudiantePerfilInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutEstudiantePerfilInput, UsuarioUpdateWithoutEstudiantePerfilInput>, UsuarioUncheckedUpdateWithoutEstudiantePerfilInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumEstadoPropuestaFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPropuesta | EnumEstadoPropuestaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPropuesta[]
    notIn?: $Enums.EstadoPropuesta[]
    not?: NestedEnumEstadoPropuestaFilter<$PrismaModel> | $Enums.EstadoPropuesta
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumResultadoDefensaNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultadoDefensa | EnumResultadoDefensaFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResultadoDefensa[] | null
    notIn?: $Enums.ResultadoDefensa[] | null
    not?: NestedEnumResultadoDefensaNullableFilter<$PrismaModel> | $Enums.ResultadoDefensa | null
  }

  export type NestedEnumEstadoPropuestaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPropuesta | EnumEstadoPropuestaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPropuesta[]
    notIn?: $Enums.EstadoPropuesta[]
    not?: NestedEnumEstadoPropuestaWithAggregatesFilter<$PrismaModel> | $Enums.EstadoPropuesta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoPropuestaFilter<$PrismaModel>
    _max?: NestedEnumEstadoPropuestaFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumResultadoDefensaNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultadoDefensa | EnumResultadoDefensaFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResultadoDefensa[] | null
    notIn?: $Enums.ResultadoDefensa[] | null
    not?: NestedEnumResultadoDefensaNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResultadoDefensa | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResultadoDefensaNullableFilter<$PrismaModel>
    _max?: NestedEnumResultadoDefensaNullableFilter<$PrismaModel>
  }

  export type NestedEnumTipoActividadFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoActividad | EnumTipoActividadFieldRefInput<$PrismaModel>
    in?: $Enums.TipoActividad[]
    notIn?: $Enums.TipoActividad[]
    not?: NestedEnumTipoActividadFilter<$PrismaModel> | $Enums.TipoActividad
  }

  export type NestedEnumTipoActividadWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoActividad | EnumTipoActividadFieldRefInput<$PrismaModel>
    in?: $Enums.TipoActividad[]
    notIn?: $Enums.TipoActividad[]
    not?: NestedEnumTipoActividadWithAggregatesFilter<$PrismaModel> | $Enums.TipoActividad
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoActividadFilter<$PrismaModel>
    _max?: NestedEnumTipoActividadFilter<$PrismaModel>
  }

  export type NestedEnumEstadoEvidenciaFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoEvidencia | EnumEstadoEvidenciaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoEvidencia[]
    notIn?: $Enums.EstadoEvidencia[]
    not?: NestedEnumEstadoEvidenciaFilter<$PrismaModel> | $Enums.EstadoEvidencia
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumEstadoEvidenciaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoEvidencia | EnumEstadoEvidenciaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoEvidencia[]
    notIn?: $Enums.EstadoEvidencia[]
    not?: NestedEnumEstadoEvidenciaWithAggregatesFilter<$PrismaModel> | $Enums.EstadoEvidencia
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoEvidenciaFilter<$PrismaModel>
    _max?: NestedEnumEstadoEvidenciaFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumTipoEntregableFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEntregable | EnumTipoEntregableFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEntregable[]
    notIn?: $Enums.TipoEntregable[]
    not?: NestedEnumTipoEntregableFilter<$PrismaModel> | $Enums.TipoEntregable
  }

  export type NestedEnumTipoEntregableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEntregable | EnumTipoEntregableFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEntregable[]
    notIn?: $Enums.TipoEntregable[]
    not?: NestedEnumTipoEntregableWithAggregatesFilter<$PrismaModel> | $Enums.TipoEntregable
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoEntregableFilter<$PrismaModel>
    _max?: NestedEnumTipoEntregableFilter<$PrismaModel>
  }

  export type NestedEnumRolComiteFilter<$PrismaModel = never> = {
    equals?: $Enums.RolComite | EnumRolComiteFieldRefInput<$PrismaModel>
    in?: $Enums.RolComite[]
    notIn?: $Enums.RolComite[]
    not?: NestedEnumRolComiteFilter<$PrismaModel> | $Enums.RolComite
  }

  export type NestedEnumRolComiteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RolComite | EnumRolComiteFieldRefInput<$PrismaModel>
    in?: $Enums.RolComite[]
    notIn?: $Enums.RolComite[]
    not?: NestedEnumRolComiteWithAggregatesFilter<$PrismaModel> | $Enums.RolComite
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolComiteFilter<$PrismaModel>
    _max?: NestedEnumRolComiteFilter<$PrismaModel>
  }

  export type AuthCreateWithoutUsuarioInput = {
    username: string
    password: string
  }

  export type AuthUncheckedCreateWithoutUsuarioInput = {
    id?: number
    username: string
    password: string
  }

  export type AuthCreateOrConnectWithoutUsuarioInput = {
    where: AuthWhereUniqueInput
    create: XOR<AuthCreateWithoutUsuarioInput, AuthUncheckedCreateWithoutUsuarioInput>
  }

  export type PropuestaCreateWithoutEstudianteInput = {
    titulo: string
    objetivos: string
    problematica?: string | null
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
    areaConocimiento: AreaConocimientoCreateNestedOneWithoutPropuestasInput
    trabajosTitulacion?: TrabajoTitulacionCreateNestedManyWithoutPropuestaInput
    actividades?: ActividadCreateNestedManyWithoutPropuestaInput
    comites?: ComiteCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaUncheckedCreateWithoutEstudianteInput = {
    id?: number
    titulo: string
    objetivos: string
    problematica?: string | null
    areaConocimientoId: number
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
    trabajosTitulacion?: TrabajoTitulacionUncheckedCreateNestedManyWithoutPropuestaInput
    actividades?: ActividadUncheckedCreateNestedManyWithoutPropuestaInput
    comites?: ComiteUncheckedCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalUncheckedCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaCreateOrConnectWithoutEstudianteInput = {
    where: PropuestaWhereUniqueInput
    create: XOR<PropuestaCreateWithoutEstudianteInput, PropuestaUncheckedCreateWithoutEstudianteInput>
  }

  export type PropuestaCreateManyEstudianteInputEnvelope = {
    data: PropuestaCreateManyEstudianteInput | PropuestaCreateManyEstudianteInput[]
    skipDuplicates?: boolean
  }

  export type ComentarioCreateWithoutUsuarioInput = {
    descripcion?: string | null
    evidencia: EvidenciaCreateNestedOneWithoutComentariosInput
  }

  export type ComentarioUncheckedCreateWithoutUsuarioInput = {
    id?: number
    evidenciaId: number
    descripcion?: string | null
  }

  export type ComentarioCreateOrConnectWithoutUsuarioInput = {
    where: ComentarioWhereUniqueInput
    create: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput>
  }

  export type ComentarioCreateManyUsuarioInputEnvelope = {
    data: ComentarioCreateManyUsuarioInput | ComentarioCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type NotificacionCreateWithoutUsuarioInput = {
    mensaje: string
    leido?: boolean
    fechaCreacion?: Date | string
  }

  export type NotificacionUncheckedCreateWithoutUsuarioInput = {
    id?: number
    mensaje: string
    leido?: boolean
    fechaCreacion?: Date | string
  }

  export type NotificacionCreateOrConnectWithoutUsuarioInput = {
    where: NotificacionWhereUniqueInput
    create: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput>
  }

  export type NotificacionCreateManyUsuarioInputEnvelope = {
    data: NotificacionCreateManyUsuarioInput | NotificacionCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type ComiteCreateWithoutUsuarioInput = {
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
    propuesta: PropuestaCreateNestedOneWithoutComitesInput
  }

  export type ComiteUncheckedCreateWithoutUsuarioInput = {
    propuestaId: number
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
  }

  export type ComiteCreateOrConnectWithoutUsuarioInput = {
    where: ComiteWhereUniqueInput
    create: XOR<ComiteCreateWithoutUsuarioInput, ComiteUncheckedCreateWithoutUsuarioInput>
  }

  export type ComiteCreateManyUsuarioInputEnvelope = {
    data: ComiteCreateManyUsuarioInput | ComiteCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type EstudiantePrerequisitoCreateWithoutEstudianteInput = {
    cumplido?: boolean
    archivoUrl?: string | null
    fechaCumplimiento?: Date | string | null
    prerequisito: CatalogoPrerequisitoCreateNestedOneWithoutEstudiantePrerequisitosInput
  }

  export type EstudiantePrerequisitoUncheckedCreateWithoutEstudianteInput = {
    id?: number
    prerequisitoId: number
    cumplido?: boolean
    archivoUrl?: string | null
    fechaCumplimiento?: Date | string | null
  }

  export type EstudiantePrerequisitoCreateOrConnectWithoutEstudianteInput = {
    where: EstudiantePrerequisitoWhereUniqueInput
    create: XOR<EstudiantePrerequisitoCreateWithoutEstudianteInput, EstudiantePrerequisitoUncheckedCreateWithoutEstudianteInput>
  }

  export type EstudiantePrerequisitoCreateManyEstudianteInputEnvelope = {
    data: EstudiantePrerequisitoCreateManyEstudianteInput | EstudiantePrerequisitoCreateManyEstudianteInput[]
    skipDuplicates?: boolean
  }

  export type EstudiantePerfilCreateWithoutUsuarioInput = {
    sexo?: string | null
    estadoEscuela?: string | null
    sede?: string | null
    escuela?: string | null
    codigoMalla?: string | null
    malla?: string | null
    periodoLectivo?: string | null
    ciudad?: string | null
    provincia?: string | null
    pais?: string | null
  }

  export type EstudiantePerfilUncheckedCreateWithoutUsuarioInput = {
    id?: number
    sexo?: string | null
    estadoEscuela?: string | null
    sede?: string | null
    escuela?: string | null
    codigoMalla?: string | null
    malla?: string | null
    periodoLectivo?: string | null
    ciudad?: string | null
    provincia?: string | null
    pais?: string | null
  }

  export type EstudiantePerfilCreateOrConnectWithoutUsuarioInput = {
    where: EstudiantePerfilWhereUniqueInput
    create: XOR<EstudiantePerfilCreateWithoutUsuarioInput, EstudiantePerfilUncheckedCreateWithoutUsuarioInput>
  }

  export type AuthUpsertWithoutUsuarioInput = {
    update: XOR<AuthUpdateWithoutUsuarioInput, AuthUncheckedUpdateWithoutUsuarioInput>
    create: XOR<AuthCreateWithoutUsuarioInput, AuthUncheckedCreateWithoutUsuarioInput>
    where?: AuthWhereInput
  }

  export type AuthUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: AuthWhereInput
    data: XOR<AuthUpdateWithoutUsuarioInput, AuthUncheckedUpdateWithoutUsuarioInput>
  }

  export type AuthUpdateWithoutUsuarioInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type AuthUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type PropuestaUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: PropuestaWhereUniqueInput
    update: XOR<PropuestaUpdateWithoutEstudianteInput, PropuestaUncheckedUpdateWithoutEstudianteInput>
    create: XOR<PropuestaCreateWithoutEstudianteInput, PropuestaUncheckedCreateWithoutEstudianteInput>
  }

  export type PropuestaUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: PropuestaWhereUniqueInput
    data: XOR<PropuestaUpdateWithoutEstudianteInput, PropuestaUncheckedUpdateWithoutEstudianteInput>
  }

  export type PropuestaUpdateManyWithWhereWithoutEstudianteInput = {
    where: PropuestaScalarWhereInput
    data: XOR<PropuestaUpdateManyMutationInput, PropuestaUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type PropuestaScalarWhereInput = {
    AND?: PropuestaScalarWhereInput | PropuestaScalarWhereInput[]
    OR?: PropuestaScalarWhereInput[]
    NOT?: PropuestaScalarWhereInput | PropuestaScalarWhereInput[]
    id?: IntFilter<"Propuesta"> | number
    titulo?: StringFilter<"Propuesta"> | string
    objetivos?: StringFilter<"Propuesta"> | string
    problematica?: StringNullableFilter<"Propuesta"> | string | null
    areaConocimientoId?: IntFilter<"Propuesta"> | number
    alcance?: StringNullableFilter<"Propuesta"> | string | null
    archivoUrl?: StringNullableFilter<"Propuesta"> | string | null
    fechaPublicacion?: DateTimeFilter<"Propuesta"> | Date | string
    estado?: EnumEstadoPropuestaFilter<"Propuesta"> | $Enums.EstadoPropuesta
    fkEstudiante?: IntFilter<"Propuesta"> | number
    fechaDefensa?: DateTimeNullableFilter<"Propuesta"> | Date | string | null
    resultadoDefensa?: EnumResultadoDefensaNullableFilter<"Propuesta"> | $Enums.ResultadoDefensa | null
  }

  export type ComentarioUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ComentarioWhereUniqueInput
    update: XOR<ComentarioUpdateWithoutUsuarioInput, ComentarioUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput>
  }

  export type ComentarioUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ComentarioWhereUniqueInput
    data: XOR<ComentarioUpdateWithoutUsuarioInput, ComentarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type ComentarioUpdateManyWithWhereWithoutUsuarioInput = {
    where: ComentarioScalarWhereInput
    data: XOR<ComentarioUpdateManyMutationInput, ComentarioUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ComentarioScalarWhereInput = {
    AND?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
    OR?: ComentarioScalarWhereInput[]
    NOT?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
    id?: IntFilter<"Comentario"> | number
    evidenciaId?: IntFilter<"Comentario"> | number
    usuarioId?: IntFilter<"Comentario"> | number
    descripcion?: StringNullableFilter<"Comentario"> | string | null
  }

  export type NotificacionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: NotificacionWhereUniqueInput
    update: XOR<NotificacionUpdateWithoutUsuarioInput, NotificacionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput>
  }

  export type NotificacionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: NotificacionWhereUniqueInput
    data: XOR<NotificacionUpdateWithoutUsuarioInput, NotificacionUncheckedUpdateWithoutUsuarioInput>
  }

  export type NotificacionUpdateManyWithWhereWithoutUsuarioInput = {
    where: NotificacionScalarWhereInput
    data: XOR<NotificacionUpdateManyMutationInput, NotificacionUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type NotificacionScalarWhereInput = {
    AND?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
    OR?: NotificacionScalarWhereInput[]
    NOT?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
    id?: IntFilter<"Notificacion"> | number
    mensaje?: StringFilter<"Notificacion"> | string
    leido?: BoolFilter<"Notificacion"> | boolean
    fechaCreacion?: DateTimeFilter<"Notificacion"> | Date | string
    usuarioId?: IntFilter<"Notificacion"> | number
  }

  export type ComiteUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ComiteWhereUniqueInput
    update: XOR<ComiteUpdateWithoutUsuarioInput, ComiteUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ComiteCreateWithoutUsuarioInput, ComiteUncheckedCreateWithoutUsuarioInput>
  }

  export type ComiteUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ComiteWhereUniqueInput
    data: XOR<ComiteUpdateWithoutUsuarioInput, ComiteUncheckedUpdateWithoutUsuarioInput>
  }

  export type ComiteUpdateManyWithWhereWithoutUsuarioInput = {
    where: ComiteScalarWhereInput
    data: XOR<ComiteUpdateManyMutationInput, ComiteUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ComiteScalarWhereInput = {
    AND?: ComiteScalarWhereInput | ComiteScalarWhereInput[]
    OR?: ComiteScalarWhereInput[]
    NOT?: ComiteScalarWhereInput | ComiteScalarWhereInput[]
    usuarioId?: IntFilter<"Comite"> | number
    propuestaId?: IntFilter<"Comite"> | number
    rol?: EnumRolComiteFilter<"Comite"> | $Enums.RolComite
    calificacion?: DecimalNullableFilter<"Comite"> | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: DateTimeNullableFilter<"Comite"> | Date | string | null
  }

  export type EstudiantePrerequisitoUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: EstudiantePrerequisitoWhereUniqueInput
    update: XOR<EstudiantePrerequisitoUpdateWithoutEstudianteInput, EstudiantePrerequisitoUncheckedUpdateWithoutEstudianteInput>
    create: XOR<EstudiantePrerequisitoCreateWithoutEstudianteInput, EstudiantePrerequisitoUncheckedCreateWithoutEstudianteInput>
  }

  export type EstudiantePrerequisitoUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: EstudiantePrerequisitoWhereUniqueInput
    data: XOR<EstudiantePrerequisitoUpdateWithoutEstudianteInput, EstudiantePrerequisitoUncheckedUpdateWithoutEstudianteInput>
  }

  export type EstudiantePrerequisitoUpdateManyWithWhereWithoutEstudianteInput = {
    where: EstudiantePrerequisitoScalarWhereInput
    data: XOR<EstudiantePrerequisitoUpdateManyMutationInput, EstudiantePrerequisitoUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type EstudiantePrerequisitoScalarWhereInput = {
    AND?: EstudiantePrerequisitoScalarWhereInput | EstudiantePrerequisitoScalarWhereInput[]
    OR?: EstudiantePrerequisitoScalarWhereInput[]
    NOT?: EstudiantePrerequisitoScalarWhereInput | EstudiantePrerequisitoScalarWhereInput[]
    id?: IntFilter<"EstudiantePrerequisito"> | number
    prerequisitoId?: IntFilter<"EstudiantePrerequisito"> | number
    cumplido?: BoolFilter<"EstudiantePrerequisito"> | boolean
    archivoUrl?: StringNullableFilter<"EstudiantePrerequisito"> | string | null
    fechaCumplimiento?: DateTimeNullableFilter<"EstudiantePrerequisito"> | Date | string | null
    fkEstudiante?: IntFilter<"EstudiantePrerequisito"> | number
  }

  export type EstudiantePerfilUpsertWithoutUsuarioInput = {
    update: XOR<EstudiantePerfilUpdateWithoutUsuarioInput, EstudiantePerfilUncheckedUpdateWithoutUsuarioInput>
    create: XOR<EstudiantePerfilCreateWithoutUsuarioInput, EstudiantePerfilUncheckedCreateWithoutUsuarioInput>
    where?: EstudiantePerfilWhereInput
  }

  export type EstudiantePerfilUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: EstudiantePerfilWhereInput
    data: XOR<EstudiantePerfilUpdateWithoutUsuarioInput, EstudiantePerfilUncheckedUpdateWithoutUsuarioInput>
  }

  export type EstudiantePerfilUpdateWithoutUsuarioInput = {
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    estadoEscuela?: NullableStringFieldUpdateOperationsInput | string | null
    sede?: NullableStringFieldUpdateOperationsInput | string | null
    escuela?: NullableStringFieldUpdateOperationsInput | string | null
    codigoMalla?: NullableStringFieldUpdateOperationsInput | string | null
    malla?: NullableStringFieldUpdateOperationsInput | string | null
    periodoLectivo?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    provincia?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EstudiantePerfilUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    estadoEscuela?: NullableStringFieldUpdateOperationsInput | string | null
    sede?: NullableStringFieldUpdateOperationsInput | string | null
    escuela?: NullableStringFieldUpdateOperationsInput | string | null
    codigoMalla?: NullableStringFieldUpdateOperationsInput | string | null
    malla?: NullableStringFieldUpdateOperationsInput | string | null
    periodoLectivo?: NullableStringFieldUpdateOperationsInput | string | null
    ciudad?: NullableStringFieldUpdateOperationsInput | string | null
    provincia?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuarioCreateWithoutAuthInput = {
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    propuestas?: PropuestaCreateNestedManyWithoutEstudianteInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput
    comites?: ComiteCreateNestedManyWithoutUsuarioInput
    prerequisitos?: EstudiantePrerequisitoCreateNestedManyWithoutEstudianteInput
    estudiantePerfil?: EstudiantePerfilCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutAuthInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    propuestas?: PropuestaUncheckedCreateNestedManyWithoutEstudianteInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    comites?: ComiteUncheckedCreateNestedManyWithoutUsuarioInput
    prerequisitos?: EstudiantePrerequisitoUncheckedCreateNestedManyWithoutEstudianteInput
    estudiantePerfil?: EstudiantePerfilUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutAuthInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutAuthInput, UsuarioUncheckedCreateWithoutAuthInput>
  }

  export type UsuarioUpsertWithoutAuthInput = {
    update: XOR<UsuarioUpdateWithoutAuthInput, UsuarioUncheckedUpdateWithoutAuthInput>
    create: XOR<UsuarioCreateWithoutAuthInput, UsuarioUncheckedCreateWithoutAuthInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutAuthInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutAuthInput, UsuarioUncheckedUpdateWithoutAuthInput>
  }

  export type UsuarioUpdateWithoutAuthInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestas?: PropuestaUpdateManyWithoutEstudianteNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput
    comites?: ComiteUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: EstudiantePrerequisitoUpdateManyWithoutEstudianteNestedInput
    estudiantePerfil?: EstudiantePerfilUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutAuthInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestas?: PropuestaUncheckedUpdateManyWithoutEstudianteNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    comites?: ComiteUncheckedUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: EstudiantePrerequisitoUncheckedUpdateManyWithoutEstudianteNestedInput
    estudiantePerfil?: EstudiantePerfilUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type PropuestaCreateWithoutAreaConocimientoInput = {
    titulo: string
    objetivos: string
    problematica?: string | null
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
    estudiante: UsuarioCreateNestedOneWithoutPropuestasInput
    trabajosTitulacion?: TrabajoTitulacionCreateNestedManyWithoutPropuestaInput
    actividades?: ActividadCreateNestedManyWithoutPropuestaInput
    comites?: ComiteCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaUncheckedCreateWithoutAreaConocimientoInput = {
    id?: number
    titulo: string
    objetivos: string
    problematica?: string | null
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fkEstudiante: number
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
    trabajosTitulacion?: TrabajoTitulacionUncheckedCreateNestedManyWithoutPropuestaInput
    actividades?: ActividadUncheckedCreateNestedManyWithoutPropuestaInput
    comites?: ComiteUncheckedCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalUncheckedCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaCreateOrConnectWithoutAreaConocimientoInput = {
    where: PropuestaWhereUniqueInput
    create: XOR<PropuestaCreateWithoutAreaConocimientoInput, PropuestaUncheckedCreateWithoutAreaConocimientoInput>
  }

  export type PropuestaCreateManyAreaConocimientoInputEnvelope = {
    data: PropuestaCreateManyAreaConocimientoInput | PropuestaCreateManyAreaConocimientoInput[]
    skipDuplicates?: boolean
  }

  export type PropuestaUpsertWithWhereUniqueWithoutAreaConocimientoInput = {
    where: PropuestaWhereUniqueInput
    update: XOR<PropuestaUpdateWithoutAreaConocimientoInput, PropuestaUncheckedUpdateWithoutAreaConocimientoInput>
    create: XOR<PropuestaCreateWithoutAreaConocimientoInput, PropuestaUncheckedCreateWithoutAreaConocimientoInput>
  }

  export type PropuestaUpdateWithWhereUniqueWithoutAreaConocimientoInput = {
    where: PropuestaWhereUniqueInput
    data: XOR<PropuestaUpdateWithoutAreaConocimientoInput, PropuestaUncheckedUpdateWithoutAreaConocimientoInput>
  }

  export type PropuestaUpdateManyWithWhereWithoutAreaConocimientoInput = {
    where: PropuestaScalarWhereInput
    data: XOR<PropuestaUpdateManyMutationInput, PropuestaUncheckedUpdateManyWithoutAreaConocimientoInput>
  }

  export type AreaConocimientoCreateWithoutPropuestasInput = {
    codigo: string
    nombre: string
    descripcion?: string | null
  }

  export type AreaConocimientoUncheckedCreateWithoutPropuestasInput = {
    id?: number
    codigo: string
    nombre: string
    descripcion?: string | null
  }

  export type AreaConocimientoCreateOrConnectWithoutPropuestasInput = {
    where: AreaConocimientoWhereUniqueInput
    create: XOR<AreaConocimientoCreateWithoutPropuestasInput, AreaConocimientoUncheckedCreateWithoutPropuestasInput>
  }

  export type UsuarioCreateWithoutPropuestasInput = {
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    auth?: AuthCreateNestedOneWithoutUsuarioInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput
    comites?: ComiteCreateNestedManyWithoutUsuarioInput
    prerequisitos?: EstudiantePrerequisitoCreateNestedManyWithoutEstudianteInput
    estudiantePerfil?: EstudiantePerfilCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPropuestasInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    auth?: AuthUncheckedCreateNestedOneWithoutUsuarioInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    comites?: ComiteUncheckedCreateNestedManyWithoutUsuarioInput
    prerequisitos?: EstudiantePrerequisitoUncheckedCreateNestedManyWithoutEstudianteInput
    estudiantePerfil?: EstudiantePerfilUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPropuestasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPropuestasInput, UsuarioUncheckedCreateWithoutPropuestasInput>
  }

  export type TrabajoTitulacionCreateWithoutPropuestaInput = {
    fkTutorId: number
  }

  export type TrabajoTitulacionUncheckedCreateWithoutPropuestaInput = {
    fkTutorId: number
  }

  export type TrabajoTitulacionCreateOrConnectWithoutPropuestaInput = {
    where: TrabajoTitulacionWhereUniqueInput
    create: XOR<TrabajoTitulacionCreateWithoutPropuestaInput, TrabajoTitulacionUncheckedCreateWithoutPropuestaInput>
  }

  export type TrabajoTitulacionCreateManyPropuestaInputEnvelope = {
    data: TrabajoTitulacionCreateManyPropuestaInput | TrabajoTitulacionCreateManyPropuestaInput[]
    skipDuplicates?: boolean
  }

  export type ActividadCreateWithoutPropuestaInput = {
    nombre: string
    descripcion?: string | null
    tipo?: $Enums.TipoActividad
    evidencias?: EvidenciaCreateNestedManyWithoutActividadInput
  }

  export type ActividadUncheckedCreateWithoutPropuestaInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    tipo?: $Enums.TipoActividad
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutActividadInput
  }

  export type ActividadCreateOrConnectWithoutPropuestaInput = {
    where: ActividadWhereUniqueInput
    create: XOR<ActividadCreateWithoutPropuestaInput, ActividadUncheckedCreateWithoutPropuestaInput>
  }

  export type ActividadCreateManyPropuestaInputEnvelope = {
    data: ActividadCreateManyPropuestaInput | ActividadCreateManyPropuestaInput[]
    skipDuplicates?: boolean
  }

  export type ComiteCreateWithoutPropuestaInput = {
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
    usuario: UsuarioCreateNestedOneWithoutComitesInput
  }

  export type ComiteUncheckedCreateWithoutPropuestaInput = {
    usuarioId: number
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
  }

  export type ComiteCreateOrConnectWithoutPropuestaInput = {
    where: ComiteWhereUniqueInput
    create: XOR<ComiteCreateWithoutPropuestaInput, ComiteUncheckedCreateWithoutPropuestaInput>
  }

  export type ComiteCreateManyPropuestaInputEnvelope = {
    data: ComiteCreateManyPropuestaInput | ComiteCreateManyPropuestaInput[]
    skipDuplicates?: boolean
  }

  export type EntregableFinalCreateWithoutPropuestaInput = {
    tipo: $Enums.TipoEntregable
    urlArchivo: string
    fechaSubida?: Date | string
  }

  export type EntregableFinalUncheckedCreateWithoutPropuestaInput = {
    id?: number
    tipo: $Enums.TipoEntregable
    urlArchivo: string
    fechaSubida?: Date | string
  }

  export type EntregableFinalCreateOrConnectWithoutPropuestaInput = {
    where: EntregableFinalWhereUniqueInput
    create: XOR<EntregableFinalCreateWithoutPropuestaInput, EntregableFinalUncheckedCreateWithoutPropuestaInput>
  }

  export type EntregableFinalCreateManyPropuestaInputEnvelope = {
    data: EntregableFinalCreateManyPropuestaInput | EntregableFinalCreateManyPropuestaInput[]
    skipDuplicates?: boolean
  }

  export type AreaConocimientoUpsertWithoutPropuestasInput = {
    update: XOR<AreaConocimientoUpdateWithoutPropuestasInput, AreaConocimientoUncheckedUpdateWithoutPropuestasInput>
    create: XOR<AreaConocimientoCreateWithoutPropuestasInput, AreaConocimientoUncheckedCreateWithoutPropuestasInput>
    where?: AreaConocimientoWhereInput
  }

  export type AreaConocimientoUpdateToOneWithWhereWithoutPropuestasInput = {
    where?: AreaConocimientoWhereInput
    data: XOR<AreaConocimientoUpdateWithoutPropuestasInput, AreaConocimientoUncheckedUpdateWithoutPropuestasInput>
  }

  export type AreaConocimientoUpdateWithoutPropuestasInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AreaConocimientoUncheckedUpdateWithoutPropuestasInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuarioUpsertWithoutPropuestasInput = {
    update: XOR<UsuarioUpdateWithoutPropuestasInput, UsuarioUncheckedUpdateWithoutPropuestasInput>
    create: XOR<UsuarioCreateWithoutPropuestasInput, UsuarioUncheckedCreateWithoutPropuestasInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutPropuestasInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutPropuestasInput, UsuarioUncheckedUpdateWithoutPropuestasInput>
  }

  export type UsuarioUpdateWithoutPropuestasInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUpdateOneWithoutUsuarioNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput
    comites?: ComiteUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: EstudiantePrerequisitoUpdateManyWithoutEstudianteNestedInput
    estudiantePerfil?: EstudiantePerfilUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPropuestasInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUncheckedUpdateOneWithoutUsuarioNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    comites?: ComiteUncheckedUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: EstudiantePrerequisitoUncheckedUpdateManyWithoutEstudianteNestedInput
    estudiantePerfil?: EstudiantePerfilUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type TrabajoTitulacionUpsertWithWhereUniqueWithoutPropuestaInput = {
    where: TrabajoTitulacionWhereUniqueInput
    update: XOR<TrabajoTitulacionUpdateWithoutPropuestaInput, TrabajoTitulacionUncheckedUpdateWithoutPropuestaInput>
    create: XOR<TrabajoTitulacionCreateWithoutPropuestaInput, TrabajoTitulacionUncheckedCreateWithoutPropuestaInput>
  }

  export type TrabajoTitulacionUpdateWithWhereUniqueWithoutPropuestaInput = {
    where: TrabajoTitulacionWhereUniqueInput
    data: XOR<TrabajoTitulacionUpdateWithoutPropuestaInput, TrabajoTitulacionUncheckedUpdateWithoutPropuestaInput>
  }

  export type TrabajoTitulacionUpdateManyWithWhereWithoutPropuestaInput = {
    where: TrabajoTitulacionScalarWhereInput
    data: XOR<TrabajoTitulacionUpdateManyMutationInput, TrabajoTitulacionUncheckedUpdateManyWithoutPropuestaInput>
  }

  export type TrabajoTitulacionScalarWhereInput = {
    AND?: TrabajoTitulacionScalarWhereInput | TrabajoTitulacionScalarWhereInput[]
    OR?: TrabajoTitulacionScalarWhereInput[]
    NOT?: TrabajoTitulacionScalarWhereInput | TrabajoTitulacionScalarWhereInput[]
    propuestasId?: IntFilter<"TrabajoTitulacion"> | number
    fkTutorId?: IntFilter<"TrabajoTitulacion"> | number
  }

  export type ActividadUpsertWithWhereUniqueWithoutPropuestaInput = {
    where: ActividadWhereUniqueInput
    update: XOR<ActividadUpdateWithoutPropuestaInput, ActividadUncheckedUpdateWithoutPropuestaInput>
    create: XOR<ActividadCreateWithoutPropuestaInput, ActividadUncheckedCreateWithoutPropuestaInput>
  }

  export type ActividadUpdateWithWhereUniqueWithoutPropuestaInput = {
    where: ActividadWhereUniqueInput
    data: XOR<ActividadUpdateWithoutPropuestaInput, ActividadUncheckedUpdateWithoutPropuestaInput>
  }

  export type ActividadUpdateManyWithWhereWithoutPropuestaInput = {
    where: ActividadScalarWhereInput
    data: XOR<ActividadUpdateManyMutationInput, ActividadUncheckedUpdateManyWithoutPropuestaInput>
  }

  export type ActividadScalarWhereInput = {
    AND?: ActividadScalarWhereInput | ActividadScalarWhereInput[]
    OR?: ActividadScalarWhereInput[]
    NOT?: ActividadScalarWhereInput | ActividadScalarWhereInput[]
    id?: IntFilter<"Actividad"> | number
    nombre?: StringFilter<"Actividad"> | string
    descripcion?: StringNullableFilter<"Actividad"> | string | null
    propuestaId?: IntFilter<"Actividad"> | number
    tipo?: EnumTipoActividadFilter<"Actividad"> | $Enums.TipoActividad
  }

  export type ComiteUpsertWithWhereUniqueWithoutPropuestaInput = {
    where: ComiteWhereUniqueInput
    update: XOR<ComiteUpdateWithoutPropuestaInput, ComiteUncheckedUpdateWithoutPropuestaInput>
    create: XOR<ComiteCreateWithoutPropuestaInput, ComiteUncheckedCreateWithoutPropuestaInput>
  }

  export type ComiteUpdateWithWhereUniqueWithoutPropuestaInput = {
    where: ComiteWhereUniqueInput
    data: XOR<ComiteUpdateWithoutPropuestaInput, ComiteUncheckedUpdateWithoutPropuestaInput>
  }

  export type ComiteUpdateManyWithWhereWithoutPropuestaInput = {
    where: ComiteScalarWhereInput
    data: XOR<ComiteUpdateManyMutationInput, ComiteUncheckedUpdateManyWithoutPropuestaInput>
  }

  export type EntregableFinalUpsertWithWhereUniqueWithoutPropuestaInput = {
    where: EntregableFinalWhereUniqueInput
    update: XOR<EntregableFinalUpdateWithoutPropuestaInput, EntregableFinalUncheckedUpdateWithoutPropuestaInput>
    create: XOR<EntregableFinalCreateWithoutPropuestaInput, EntregableFinalUncheckedCreateWithoutPropuestaInput>
  }

  export type EntregableFinalUpdateWithWhereUniqueWithoutPropuestaInput = {
    where: EntregableFinalWhereUniqueInput
    data: XOR<EntregableFinalUpdateWithoutPropuestaInput, EntregableFinalUncheckedUpdateWithoutPropuestaInput>
  }

  export type EntregableFinalUpdateManyWithWhereWithoutPropuestaInput = {
    where: EntregableFinalScalarWhereInput
    data: XOR<EntregableFinalUpdateManyMutationInput, EntregableFinalUncheckedUpdateManyWithoutPropuestaInput>
  }

  export type EntregableFinalScalarWhereInput = {
    AND?: EntregableFinalScalarWhereInput | EntregableFinalScalarWhereInput[]
    OR?: EntregableFinalScalarWhereInput[]
    NOT?: EntregableFinalScalarWhereInput | EntregableFinalScalarWhereInput[]
    id?: IntFilter<"EntregableFinal"> | number
    tipo?: EnumTipoEntregableFilter<"EntregableFinal"> | $Enums.TipoEntregable
    urlArchivo?: StringFilter<"EntregableFinal"> | string
    fechaSubida?: DateTimeFilter<"EntregableFinal"> | Date | string
    propuestasId?: IntFilter<"EntregableFinal"> | number
  }

  export type PropuestaCreateWithoutTrabajosTitulacionInput = {
    titulo: string
    objetivos: string
    problematica?: string | null
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
    areaConocimiento: AreaConocimientoCreateNestedOneWithoutPropuestasInput
    estudiante: UsuarioCreateNestedOneWithoutPropuestasInput
    actividades?: ActividadCreateNestedManyWithoutPropuestaInput
    comites?: ComiteCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaUncheckedCreateWithoutTrabajosTitulacionInput = {
    id?: number
    titulo: string
    objetivos: string
    problematica?: string | null
    areaConocimientoId: number
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fkEstudiante: number
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
    actividades?: ActividadUncheckedCreateNestedManyWithoutPropuestaInput
    comites?: ComiteUncheckedCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalUncheckedCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaCreateOrConnectWithoutTrabajosTitulacionInput = {
    where: PropuestaWhereUniqueInput
    create: XOR<PropuestaCreateWithoutTrabajosTitulacionInput, PropuestaUncheckedCreateWithoutTrabajosTitulacionInput>
  }

  export type PropuestaUpsertWithoutTrabajosTitulacionInput = {
    update: XOR<PropuestaUpdateWithoutTrabajosTitulacionInput, PropuestaUncheckedUpdateWithoutTrabajosTitulacionInput>
    create: XOR<PropuestaCreateWithoutTrabajosTitulacionInput, PropuestaUncheckedCreateWithoutTrabajosTitulacionInput>
    where?: PropuestaWhereInput
  }

  export type PropuestaUpdateToOneWithWhereWithoutTrabajosTitulacionInput = {
    where?: PropuestaWhereInput
    data: XOR<PropuestaUpdateWithoutTrabajosTitulacionInput, PropuestaUncheckedUpdateWithoutTrabajosTitulacionInput>
  }

  export type PropuestaUpdateWithoutTrabajosTitulacionInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
    areaConocimiento?: AreaConocimientoUpdateOneRequiredWithoutPropuestasNestedInput
    estudiante?: UsuarioUpdateOneRequiredWithoutPropuestasNestedInput
    actividades?: ActividadUpdateManyWithoutPropuestaNestedInput
    comites?: ComiteUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaUncheckedUpdateWithoutTrabajosTitulacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaConocimientoId?: IntFieldUpdateOperationsInput | number
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fkEstudiante?: IntFieldUpdateOperationsInput | number
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
    actividades?: ActividadUncheckedUpdateManyWithoutPropuestaNestedInput
    comites?: ComiteUncheckedUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUncheckedUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaCreateWithoutActividadesInput = {
    titulo: string
    objetivos: string
    problematica?: string | null
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
    areaConocimiento: AreaConocimientoCreateNestedOneWithoutPropuestasInput
    estudiante: UsuarioCreateNestedOneWithoutPropuestasInput
    trabajosTitulacion?: TrabajoTitulacionCreateNestedManyWithoutPropuestaInput
    comites?: ComiteCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaUncheckedCreateWithoutActividadesInput = {
    id?: number
    titulo: string
    objetivos: string
    problematica?: string | null
    areaConocimientoId: number
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fkEstudiante: number
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
    trabajosTitulacion?: TrabajoTitulacionUncheckedCreateNestedManyWithoutPropuestaInput
    comites?: ComiteUncheckedCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalUncheckedCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaCreateOrConnectWithoutActividadesInput = {
    where: PropuestaWhereUniqueInput
    create: XOR<PropuestaCreateWithoutActividadesInput, PropuestaUncheckedCreateWithoutActividadesInput>
  }

  export type EvidenciaCreateWithoutActividadInput = {
    semana: number
    contenido: string
    archivoUrl?: string | null
    fechaEntrega?: Date | string
    estado?: $Enums.EstadoEvidencia
    calificacion?: Decimal | DecimalJsLike | number | string | null
    comentarios?: ComentarioCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaUncheckedCreateWithoutActividadInput = {
    id?: number
    semana: number
    contenido: string
    archivoUrl?: string | null
    fechaEntrega?: Date | string
    estado?: $Enums.EstadoEvidencia
    calificacion?: Decimal | DecimalJsLike | number | string | null
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaCreateOrConnectWithoutActividadInput = {
    where: EvidenciaWhereUniqueInput
    create: XOR<EvidenciaCreateWithoutActividadInput, EvidenciaUncheckedCreateWithoutActividadInput>
  }

  export type EvidenciaCreateManyActividadInputEnvelope = {
    data: EvidenciaCreateManyActividadInput | EvidenciaCreateManyActividadInput[]
    skipDuplicates?: boolean
  }

  export type PropuestaUpsertWithoutActividadesInput = {
    update: XOR<PropuestaUpdateWithoutActividadesInput, PropuestaUncheckedUpdateWithoutActividadesInput>
    create: XOR<PropuestaCreateWithoutActividadesInput, PropuestaUncheckedCreateWithoutActividadesInput>
    where?: PropuestaWhereInput
  }

  export type PropuestaUpdateToOneWithWhereWithoutActividadesInput = {
    where?: PropuestaWhereInput
    data: XOR<PropuestaUpdateWithoutActividadesInput, PropuestaUncheckedUpdateWithoutActividadesInput>
  }

  export type PropuestaUpdateWithoutActividadesInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
    areaConocimiento?: AreaConocimientoUpdateOneRequiredWithoutPropuestasNestedInput
    estudiante?: UsuarioUpdateOneRequiredWithoutPropuestasNestedInput
    trabajosTitulacion?: TrabajoTitulacionUpdateManyWithoutPropuestaNestedInput
    comites?: ComiteUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaUncheckedUpdateWithoutActividadesInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaConocimientoId?: IntFieldUpdateOperationsInput | number
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fkEstudiante?: IntFieldUpdateOperationsInput | number
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
    trabajosTitulacion?: TrabajoTitulacionUncheckedUpdateManyWithoutPropuestaNestedInput
    comites?: ComiteUncheckedUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUncheckedUpdateManyWithoutPropuestaNestedInput
  }

  export type EvidenciaUpsertWithWhereUniqueWithoutActividadInput = {
    where: EvidenciaWhereUniqueInput
    update: XOR<EvidenciaUpdateWithoutActividadInput, EvidenciaUncheckedUpdateWithoutActividadInput>
    create: XOR<EvidenciaCreateWithoutActividadInput, EvidenciaUncheckedCreateWithoutActividadInput>
  }

  export type EvidenciaUpdateWithWhereUniqueWithoutActividadInput = {
    where: EvidenciaWhereUniqueInput
    data: XOR<EvidenciaUpdateWithoutActividadInput, EvidenciaUncheckedUpdateWithoutActividadInput>
  }

  export type EvidenciaUpdateManyWithWhereWithoutActividadInput = {
    where: EvidenciaScalarWhereInput
    data: XOR<EvidenciaUpdateManyMutationInput, EvidenciaUncheckedUpdateManyWithoutActividadInput>
  }

  export type EvidenciaScalarWhereInput = {
    AND?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
    OR?: EvidenciaScalarWhereInput[]
    NOT?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
    id?: IntFilter<"Evidencia"> | number
    semana?: IntFilter<"Evidencia"> | number
    contenido?: StringFilter<"Evidencia"> | string
    archivoUrl?: StringNullableFilter<"Evidencia"> | string | null
    fechaEntrega?: DateTimeFilter<"Evidencia"> | Date | string
    estado?: EnumEstadoEvidenciaFilter<"Evidencia"> | $Enums.EstadoEvidencia
    calificacion?: DecimalNullableFilter<"Evidencia"> | Decimal | DecimalJsLike | number | string | null
    actividadId?: IntFilter<"Evidencia"> | number
  }

  export type ActividadCreateWithoutEvidenciasInput = {
    nombre: string
    descripcion?: string | null
    tipo?: $Enums.TipoActividad
    propuesta: PropuestaCreateNestedOneWithoutActividadesInput
  }

  export type ActividadUncheckedCreateWithoutEvidenciasInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    propuestaId: number
    tipo?: $Enums.TipoActividad
  }

  export type ActividadCreateOrConnectWithoutEvidenciasInput = {
    where: ActividadWhereUniqueInput
    create: XOR<ActividadCreateWithoutEvidenciasInput, ActividadUncheckedCreateWithoutEvidenciasInput>
  }

  export type ComentarioCreateWithoutEvidenciaInput = {
    descripcion?: string | null
    usuario: UsuarioCreateNestedOneWithoutComentariosInput
  }

  export type ComentarioUncheckedCreateWithoutEvidenciaInput = {
    id?: number
    usuarioId: number
    descripcion?: string | null
  }

  export type ComentarioCreateOrConnectWithoutEvidenciaInput = {
    where: ComentarioWhereUniqueInput
    create: XOR<ComentarioCreateWithoutEvidenciaInput, ComentarioUncheckedCreateWithoutEvidenciaInput>
  }

  export type ComentarioCreateManyEvidenciaInputEnvelope = {
    data: ComentarioCreateManyEvidenciaInput | ComentarioCreateManyEvidenciaInput[]
    skipDuplicates?: boolean
  }

  export type ActividadUpsertWithoutEvidenciasInput = {
    update: XOR<ActividadUpdateWithoutEvidenciasInput, ActividadUncheckedUpdateWithoutEvidenciasInput>
    create: XOR<ActividadCreateWithoutEvidenciasInput, ActividadUncheckedCreateWithoutEvidenciasInput>
    where?: ActividadWhereInput
  }

  export type ActividadUpdateToOneWithWhereWithoutEvidenciasInput = {
    where?: ActividadWhereInput
    data: XOR<ActividadUpdateWithoutEvidenciasInput, ActividadUncheckedUpdateWithoutEvidenciasInput>
  }

  export type ActividadUpdateWithoutEvidenciasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoActividadFieldUpdateOperationsInput | $Enums.TipoActividad
    propuesta?: PropuestaUpdateOneRequiredWithoutActividadesNestedInput
  }

  export type ActividadUncheckedUpdateWithoutEvidenciasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    propuestaId?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoActividadFieldUpdateOperationsInput | $Enums.TipoActividad
  }

  export type ComentarioUpsertWithWhereUniqueWithoutEvidenciaInput = {
    where: ComentarioWhereUniqueInput
    update: XOR<ComentarioUpdateWithoutEvidenciaInput, ComentarioUncheckedUpdateWithoutEvidenciaInput>
    create: XOR<ComentarioCreateWithoutEvidenciaInput, ComentarioUncheckedCreateWithoutEvidenciaInput>
  }

  export type ComentarioUpdateWithWhereUniqueWithoutEvidenciaInput = {
    where: ComentarioWhereUniqueInput
    data: XOR<ComentarioUpdateWithoutEvidenciaInput, ComentarioUncheckedUpdateWithoutEvidenciaInput>
  }

  export type ComentarioUpdateManyWithWhereWithoutEvidenciaInput = {
    where: ComentarioScalarWhereInput
    data: XOR<ComentarioUpdateManyMutationInput, ComentarioUncheckedUpdateManyWithoutEvidenciaInput>
  }

  export type EvidenciaCreateWithoutComentariosInput = {
    semana: number
    contenido: string
    archivoUrl?: string | null
    fechaEntrega?: Date | string
    estado?: $Enums.EstadoEvidencia
    calificacion?: Decimal | DecimalJsLike | number | string | null
    actividad: ActividadCreateNestedOneWithoutEvidenciasInput
  }

  export type EvidenciaUncheckedCreateWithoutComentariosInput = {
    id?: number
    semana: number
    contenido: string
    archivoUrl?: string | null
    fechaEntrega?: Date | string
    estado?: $Enums.EstadoEvidencia
    calificacion?: Decimal | DecimalJsLike | number | string | null
    actividadId: number
  }

  export type EvidenciaCreateOrConnectWithoutComentariosInput = {
    where: EvidenciaWhereUniqueInput
    create: XOR<EvidenciaCreateWithoutComentariosInput, EvidenciaUncheckedCreateWithoutComentariosInput>
  }

  export type UsuarioCreateWithoutComentariosInput = {
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    auth?: AuthCreateNestedOneWithoutUsuarioInput
    propuestas?: PropuestaCreateNestedManyWithoutEstudianteInput
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput
    comites?: ComiteCreateNestedManyWithoutUsuarioInput
    prerequisitos?: EstudiantePrerequisitoCreateNestedManyWithoutEstudianteInput
    estudiantePerfil?: EstudiantePerfilCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutComentariosInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    auth?: AuthUncheckedCreateNestedOneWithoutUsuarioInput
    propuestas?: PropuestaUncheckedCreateNestedManyWithoutEstudianteInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    comites?: ComiteUncheckedCreateNestedManyWithoutUsuarioInput
    prerequisitos?: EstudiantePrerequisitoUncheckedCreateNestedManyWithoutEstudianteInput
    estudiantePerfil?: EstudiantePerfilUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutComentariosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutComentariosInput, UsuarioUncheckedCreateWithoutComentariosInput>
  }

  export type EvidenciaUpsertWithoutComentariosInput = {
    update: XOR<EvidenciaUpdateWithoutComentariosInput, EvidenciaUncheckedUpdateWithoutComentariosInput>
    create: XOR<EvidenciaCreateWithoutComentariosInput, EvidenciaUncheckedCreateWithoutComentariosInput>
    where?: EvidenciaWhereInput
  }

  export type EvidenciaUpdateToOneWithWhereWithoutComentariosInput = {
    where?: EvidenciaWhereInput
    data: XOR<EvidenciaUpdateWithoutComentariosInput, EvidenciaUncheckedUpdateWithoutComentariosInput>
  }

  export type EvidenciaUpdateWithoutComentariosInput = {
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actividad?: ActividadUpdateOneRequiredWithoutEvidenciasNestedInput
  }

  export type EvidenciaUncheckedUpdateWithoutComentariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actividadId?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioUpsertWithoutComentariosInput = {
    update: XOR<UsuarioUpdateWithoutComentariosInput, UsuarioUncheckedUpdateWithoutComentariosInput>
    create: XOR<UsuarioCreateWithoutComentariosInput, UsuarioUncheckedCreateWithoutComentariosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutComentariosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutComentariosInput, UsuarioUncheckedUpdateWithoutComentariosInput>
  }

  export type UsuarioUpdateWithoutComentariosInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUpdateOneWithoutUsuarioNestedInput
    propuestas?: PropuestaUpdateManyWithoutEstudianteNestedInput
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput
    comites?: ComiteUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: EstudiantePrerequisitoUpdateManyWithoutEstudianteNestedInput
    estudiantePerfil?: EstudiantePerfilUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutComentariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUncheckedUpdateOneWithoutUsuarioNestedInput
    propuestas?: PropuestaUncheckedUpdateManyWithoutEstudianteNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    comites?: ComiteUncheckedUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: EstudiantePrerequisitoUncheckedUpdateManyWithoutEstudianteNestedInput
    estudiantePerfil?: EstudiantePerfilUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type EstudiantePrerequisitoCreateWithoutPrerequisitoInput = {
    cumplido?: boolean
    archivoUrl?: string | null
    fechaCumplimiento?: Date | string | null
    estudiante: UsuarioCreateNestedOneWithoutPrerequisitosInput
  }

  export type EstudiantePrerequisitoUncheckedCreateWithoutPrerequisitoInput = {
    id?: number
    cumplido?: boolean
    archivoUrl?: string | null
    fechaCumplimiento?: Date | string | null
    fkEstudiante: number
  }

  export type EstudiantePrerequisitoCreateOrConnectWithoutPrerequisitoInput = {
    where: EstudiantePrerequisitoWhereUniqueInput
    create: XOR<EstudiantePrerequisitoCreateWithoutPrerequisitoInput, EstudiantePrerequisitoUncheckedCreateWithoutPrerequisitoInput>
  }

  export type EstudiantePrerequisitoCreateManyPrerequisitoInputEnvelope = {
    data: EstudiantePrerequisitoCreateManyPrerequisitoInput | EstudiantePrerequisitoCreateManyPrerequisitoInput[]
    skipDuplicates?: boolean
  }

  export type EstudiantePrerequisitoUpsertWithWhereUniqueWithoutPrerequisitoInput = {
    where: EstudiantePrerequisitoWhereUniqueInput
    update: XOR<EstudiantePrerequisitoUpdateWithoutPrerequisitoInput, EstudiantePrerequisitoUncheckedUpdateWithoutPrerequisitoInput>
    create: XOR<EstudiantePrerequisitoCreateWithoutPrerequisitoInput, EstudiantePrerequisitoUncheckedCreateWithoutPrerequisitoInput>
  }

  export type EstudiantePrerequisitoUpdateWithWhereUniqueWithoutPrerequisitoInput = {
    where: EstudiantePrerequisitoWhereUniqueInput
    data: XOR<EstudiantePrerequisitoUpdateWithoutPrerequisitoInput, EstudiantePrerequisitoUncheckedUpdateWithoutPrerequisitoInput>
  }

  export type EstudiantePrerequisitoUpdateManyWithWhereWithoutPrerequisitoInput = {
    where: EstudiantePrerequisitoScalarWhereInput
    data: XOR<EstudiantePrerequisitoUpdateManyMutationInput, EstudiantePrerequisitoUncheckedUpdateManyWithoutPrerequisitoInput>
  }

  export type CatalogoPrerequisitoCreateWithoutEstudiantePrerequisitosInput = {
    nombre: string
    descripcion?: string | null
    orden?: number
    activo?: boolean
  }

  export type CatalogoPrerequisitoUncheckedCreateWithoutEstudiantePrerequisitosInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    orden?: number
    activo?: boolean
  }

  export type CatalogoPrerequisitoCreateOrConnectWithoutEstudiantePrerequisitosInput = {
    where: CatalogoPrerequisitoWhereUniqueInput
    create: XOR<CatalogoPrerequisitoCreateWithoutEstudiantePrerequisitosInput, CatalogoPrerequisitoUncheckedCreateWithoutEstudiantePrerequisitosInput>
  }

  export type UsuarioCreateWithoutPrerequisitosInput = {
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    auth?: AuthCreateNestedOneWithoutUsuarioInput
    propuestas?: PropuestaCreateNestedManyWithoutEstudianteInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput
    comites?: ComiteCreateNestedManyWithoutUsuarioInput
    estudiantePerfil?: EstudiantePerfilCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPrerequisitosInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    auth?: AuthUncheckedCreateNestedOneWithoutUsuarioInput
    propuestas?: PropuestaUncheckedCreateNestedManyWithoutEstudianteInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    comites?: ComiteUncheckedCreateNestedManyWithoutUsuarioInput
    estudiantePerfil?: EstudiantePerfilUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPrerequisitosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPrerequisitosInput, UsuarioUncheckedCreateWithoutPrerequisitosInput>
  }

  export type CatalogoPrerequisitoUpsertWithoutEstudiantePrerequisitosInput = {
    update: XOR<CatalogoPrerequisitoUpdateWithoutEstudiantePrerequisitosInput, CatalogoPrerequisitoUncheckedUpdateWithoutEstudiantePrerequisitosInput>
    create: XOR<CatalogoPrerequisitoCreateWithoutEstudiantePrerequisitosInput, CatalogoPrerequisitoUncheckedCreateWithoutEstudiantePrerequisitosInput>
    where?: CatalogoPrerequisitoWhereInput
  }

  export type CatalogoPrerequisitoUpdateToOneWithWhereWithoutEstudiantePrerequisitosInput = {
    where?: CatalogoPrerequisitoWhereInput
    data: XOR<CatalogoPrerequisitoUpdateWithoutEstudiantePrerequisitosInput, CatalogoPrerequisitoUncheckedUpdateWithoutEstudiantePrerequisitosInput>
  }

  export type CatalogoPrerequisitoUpdateWithoutEstudiantePrerequisitosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CatalogoPrerequisitoUncheckedUpdateWithoutEstudiantePrerequisitosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    orden?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioUpsertWithoutPrerequisitosInput = {
    update: XOR<UsuarioUpdateWithoutPrerequisitosInput, UsuarioUncheckedUpdateWithoutPrerequisitosInput>
    create: XOR<UsuarioCreateWithoutPrerequisitosInput, UsuarioUncheckedCreateWithoutPrerequisitosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutPrerequisitosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutPrerequisitosInput, UsuarioUncheckedUpdateWithoutPrerequisitosInput>
  }

  export type UsuarioUpdateWithoutPrerequisitosInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUpdateOneWithoutUsuarioNestedInput
    propuestas?: PropuestaUpdateManyWithoutEstudianteNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput
    comites?: ComiteUpdateManyWithoutUsuarioNestedInput
    estudiantePerfil?: EstudiantePerfilUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPrerequisitosInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUncheckedUpdateOneWithoutUsuarioNestedInput
    propuestas?: PropuestaUncheckedUpdateManyWithoutEstudianteNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    comites?: ComiteUncheckedUpdateManyWithoutUsuarioNestedInput
    estudiantePerfil?: EstudiantePerfilUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioCreateWithoutNotificacionesInput = {
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    auth?: AuthCreateNestedOneWithoutUsuarioInput
    propuestas?: PropuestaCreateNestedManyWithoutEstudianteInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    comites?: ComiteCreateNestedManyWithoutUsuarioInput
    prerequisitos?: EstudiantePrerequisitoCreateNestedManyWithoutEstudianteInput
    estudiantePerfil?: EstudiantePerfilCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutNotificacionesInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    auth?: AuthUncheckedCreateNestedOneWithoutUsuarioInput
    propuestas?: PropuestaUncheckedCreateNestedManyWithoutEstudianteInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    comites?: ComiteUncheckedCreateNestedManyWithoutUsuarioInput
    prerequisitos?: EstudiantePrerequisitoUncheckedCreateNestedManyWithoutEstudianteInput
    estudiantePerfil?: EstudiantePerfilUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutNotificacionesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutNotificacionesInput, UsuarioUncheckedCreateWithoutNotificacionesInput>
  }

  export type UsuarioUpsertWithoutNotificacionesInput = {
    update: XOR<UsuarioUpdateWithoutNotificacionesInput, UsuarioUncheckedUpdateWithoutNotificacionesInput>
    create: XOR<UsuarioCreateWithoutNotificacionesInput, UsuarioUncheckedCreateWithoutNotificacionesInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutNotificacionesInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutNotificacionesInput, UsuarioUncheckedUpdateWithoutNotificacionesInput>
  }

  export type UsuarioUpdateWithoutNotificacionesInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUpdateOneWithoutUsuarioNestedInput
    propuestas?: PropuestaUpdateManyWithoutEstudianteNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    comites?: ComiteUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: EstudiantePrerequisitoUpdateManyWithoutEstudianteNestedInput
    estudiantePerfil?: EstudiantePerfilUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutNotificacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUncheckedUpdateOneWithoutUsuarioNestedInput
    propuestas?: PropuestaUncheckedUpdateManyWithoutEstudianteNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    comites?: ComiteUncheckedUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: EstudiantePrerequisitoUncheckedUpdateManyWithoutEstudianteNestedInput
    estudiantePerfil?: EstudiantePerfilUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type PropuestaCreateWithoutEntregablesFinalesInput = {
    titulo: string
    objetivos: string
    problematica?: string | null
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
    areaConocimiento: AreaConocimientoCreateNestedOneWithoutPropuestasInput
    estudiante: UsuarioCreateNestedOneWithoutPropuestasInput
    trabajosTitulacion?: TrabajoTitulacionCreateNestedManyWithoutPropuestaInput
    actividades?: ActividadCreateNestedManyWithoutPropuestaInput
    comites?: ComiteCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaUncheckedCreateWithoutEntregablesFinalesInput = {
    id?: number
    titulo: string
    objetivos: string
    problematica?: string | null
    areaConocimientoId: number
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fkEstudiante: number
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
    trabajosTitulacion?: TrabajoTitulacionUncheckedCreateNestedManyWithoutPropuestaInput
    actividades?: ActividadUncheckedCreateNestedManyWithoutPropuestaInput
    comites?: ComiteUncheckedCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaCreateOrConnectWithoutEntregablesFinalesInput = {
    where: PropuestaWhereUniqueInput
    create: XOR<PropuestaCreateWithoutEntregablesFinalesInput, PropuestaUncheckedCreateWithoutEntregablesFinalesInput>
  }

  export type PropuestaUpsertWithoutEntregablesFinalesInput = {
    update: XOR<PropuestaUpdateWithoutEntregablesFinalesInput, PropuestaUncheckedUpdateWithoutEntregablesFinalesInput>
    create: XOR<PropuestaCreateWithoutEntregablesFinalesInput, PropuestaUncheckedCreateWithoutEntregablesFinalesInput>
    where?: PropuestaWhereInput
  }

  export type PropuestaUpdateToOneWithWhereWithoutEntregablesFinalesInput = {
    where?: PropuestaWhereInput
    data: XOR<PropuestaUpdateWithoutEntregablesFinalesInput, PropuestaUncheckedUpdateWithoutEntregablesFinalesInput>
  }

  export type PropuestaUpdateWithoutEntregablesFinalesInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
    areaConocimiento?: AreaConocimientoUpdateOneRequiredWithoutPropuestasNestedInput
    estudiante?: UsuarioUpdateOneRequiredWithoutPropuestasNestedInput
    trabajosTitulacion?: TrabajoTitulacionUpdateManyWithoutPropuestaNestedInput
    actividades?: ActividadUpdateManyWithoutPropuestaNestedInput
    comites?: ComiteUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaUncheckedUpdateWithoutEntregablesFinalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaConocimientoId?: IntFieldUpdateOperationsInput | number
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fkEstudiante?: IntFieldUpdateOperationsInput | number
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
    trabajosTitulacion?: TrabajoTitulacionUncheckedUpdateManyWithoutPropuestaNestedInput
    actividades?: ActividadUncheckedUpdateManyWithoutPropuestaNestedInput
    comites?: ComiteUncheckedUpdateManyWithoutPropuestaNestedInput
  }

  export type UsuarioCreateWithoutComitesInput = {
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    auth?: AuthCreateNestedOneWithoutUsuarioInput
    propuestas?: PropuestaCreateNestedManyWithoutEstudianteInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput
    prerequisitos?: EstudiantePrerequisitoCreateNestedManyWithoutEstudianteInput
    estudiantePerfil?: EstudiantePerfilCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutComitesInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    auth?: AuthUncheckedCreateNestedOneWithoutUsuarioInput
    propuestas?: PropuestaUncheckedCreateNestedManyWithoutEstudianteInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    prerequisitos?: EstudiantePrerequisitoUncheckedCreateNestedManyWithoutEstudianteInput
    estudiantePerfil?: EstudiantePerfilUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutComitesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutComitesInput, UsuarioUncheckedCreateWithoutComitesInput>
  }

  export type PropuestaCreateWithoutComitesInput = {
    titulo: string
    objetivos: string
    problematica?: string | null
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
    areaConocimiento: AreaConocimientoCreateNestedOneWithoutPropuestasInput
    estudiante: UsuarioCreateNestedOneWithoutPropuestasInput
    trabajosTitulacion?: TrabajoTitulacionCreateNestedManyWithoutPropuestaInput
    actividades?: ActividadCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaUncheckedCreateWithoutComitesInput = {
    id?: number
    titulo: string
    objetivos: string
    problematica?: string | null
    areaConocimientoId: number
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fkEstudiante: number
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
    trabajosTitulacion?: TrabajoTitulacionUncheckedCreateNestedManyWithoutPropuestaInput
    actividades?: ActividadUncheckedCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalUncheckedCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaCreateOrConnectWithoutComitesInput = {
    where: PropuestaWhereUniqueInput
    create: XOR<PropuestaCreateWithoutComitesInput, PropuestaUncheckedCreateWithoutComitesInput>
  }

  export type UsuarioUpsertWithoutComitesInput = {
    update: XOR<UsuarioUpdateWithoutComitesInput, UsuarioUncheckedUpdateWithoutComitesInput>
    create: XOR<UsuarioCreateWithoutComitesInput, UsuarioUncheckedCreateWithoutComitesInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutComitesInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutComitesInput, UsuarioUncheckedUpdateWithoutComitesInput>
  }

  export type UsuarioUpdateWithoutComitesInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUpdateOneWithoutUsuarioNestedInput
    propuestas?: PropuestaUpdateManyWithoutEstudianteNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: EstudiantePrerequisitoUpdateManyWithoutEstudianteNestedInput
    estudiantePerfil?: EstudiantePerfilUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutComitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUncheckedUpdateOneWithoutUsuarioNestedInput
    propuestas?: PropuestaUncheckedUpdateManyWithoutEstudianteNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: EstudiantePrerequisitoUncheckedUpdateManyWithoutEstudianteNestedInput
    estudiantePerfil?: EstudiantePerfilUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type PropuestaUpsertWithoutComitesInput = {
    update: XOR<PropuestaUpdateWithoutComitesInput, PropuestaUncheckedUpdateWithoutComitesInput>
    create: XOR<PropuestaCreateWithoutComitesInput, PropuestaUncheckedCreateWithoutComitesInput>
    where?: PropuestaWhereInput
  }

  export type PropuestaUpdateToOneWithWhereWithoutComitesInput = {
    where?: PropuestaWhereInput
    data: XOR<PropuestaUpdateWithoutComitesInput, PropuestaUncheckedUpdateWithoutComitesInput>
  }

  export type PropuestaUpdateWithoutComitesInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
    areaConocimiento?: AreaConocimientoUpdateOneRequiredWithoutPropuestasNestedInput
    estudiante?: UsuarioUpdateOneRequiredWithoutPropuestasNestedInput
    trabajosTitulacion?: TrabajoTitulacionUpdateManyWithoutPropuestaNestedInput
    actividades?: ActividadUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaUncheckedUpdateWithoutComitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaConocimientoId?: IntFieldUpdateOperationsInput | number
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fkEstudiante?: IntFieldUpdateOperationsInput | number
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
    trabajosTitulacion?: TrabajoTitulacionUncheckedUpdateManyWithoutPropuestaNestedInput
    actividades?: ActividadUncheckedUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUncheckedUpdateManyWithoutPropuestaNestedInput
  }

  export type UsuarioCreateWithoutEstudiantePerfilInput = {
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    auth?: AuthCreateNestedOneWithoutUsuarioInput
    propuestas?: PropuestaCreateNestedManyWithoutEstudianteInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput
    comites?: ComiteCreateNestedManyWithoutUsuarioInput
    prerequisitos?: EstudiantePrerequisitoCreateNestedManyWithoutEstudianteInput
  }

  export type UsuarioUncheckedCreateWithoutEstudiantePerfilInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    auth?: AuthUncheckedCreateNestedOneWithoutUsuarioInput
    propuestas?: PropuestaUncheckedCreateNestedManyWithoutEstudianteInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    comites?: ComiteUncheckedCreateNestedManyWithoutUsuarioInput
    prerequisitos?: EstudiantePrerequisitoUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type UsuarioCreateOrConnectWithoutEstudiantePerfilInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEstudiantePerfilInput, UsuarioUncheckedCreateWithoutEstudiantePerfilInput>
  }

  export type UsuarioUpsertWithoutEstudiantePerfilInput = {
    update: XOR<UsuarioUpdateWithoutEstudiantePerfilInput, UsuarioUncheckedUpdateWithoutEstudiantePerfilInput>
    create: XOR<UsuarioCreateWithoutEstudiantePerfilInput, UsuarioUncheckedCreateWithoutEstudiantePerfilInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutEstudiantePerfilInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutEstudiantePerfilInput, UsuarioUncheckedUpdateWithoutEstudiantePerfilInput>
  }

  export type UsuarioUpdateWithoutEstudiantePerfilInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUpdateOneWithoutUsuarioNestedInput
    propuestas?: PropuestaUpdateManyWithoutEstudianteNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput
    comites?: ComiteUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: EstudiantePrerequisitoUpdateManyWithoutEstudianteNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEstudiantePerfilInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUncheckedUpdateOneWithoutUsuarioNestedInput
    propuestas?: PropuestaUncheckedUpdateManyWithoutEstudianteNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    comites?: ComiteUncheckedUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: EstudiantePrerequisitoUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type PropuestaCreateManyEstudianteInput = {
    id?: number
    titulo: string
    objetivos: string
    problematica?: string | null
    areaConocimientoId: number
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
  }

  export type ComentarioCreateManyUsuarioInput = {
    id?: number
    evidenciaId: number
    descripcion?: string | null
  }

  export type NotificacionCreateManyUsuarioInput = {
    id?: number
    mensaje: string
    leido?: boolean
    fechaCreacion?: Date | string
  }

  export type ComiteCreateManyUsuarioInput = {
    propuestaId: number
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
  }

  export type EstudiantePrerequisitoCreateManyEstudianteInput = {
    id?: number
    prerequisitoId: number
    cumplido?: boolean
    archivoUrl?: string | null
    fechaCumplimiento?: Date | string | null
  }

  export type PropuestaUpdateWithoutEstudianteInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
    areaConocimiento?: AreaConocimientoUpdateOneRequiredWithoutPropuestasNestedInput
    trabajosTitulacion?: TrabajoTitulacionUpdateManyWithoutPropuestaNestedInput
    actividades?: ActividadUpdateManyWithoutPropuestaNestedInput
    comites?: ComiteUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaUncheckedUpdateWithoutEstudianteInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaConocimientoId?: IntFieldUpdateOperationsInput | number
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
    trabajosTitulacion?: TrabajoTitulacionUncheckedUpdateManyWithoutPropuestaNestedInput
    actividades?: ActividadUncheckedUpdateManyWithoutPropuestaNestedInput
    comites?: ComiteUncheckedUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUncheckedUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaUncheckedUpdateManyWithoutEstudianteInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaConocimientoId?: IntFieldUpdateOperationsInput | number
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
  }

  export type ComentarioUpdateWithoutUsuarioInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    evidencia?: EvidenciaUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type ComentarioUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    evidenciaId?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ComentarioUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    evidenciaId?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificacionUpdateWithoutUsuarioInput = {
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComiteUpdateWithoutUsuarioInput = {
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propuesta?: PropuestaUpdateOneRequiredWithoutComitesNestedInput
  }

  export type ComiteUncheckedUpdateWithoutUsuarioInput = {
    propuestaId?: IntFieldUpdateOperationsInput | number
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ComiteUncheckedUpdateManyWithoutUsuarioInput = {
    propuestaId?: IntFieldUpdateOperationsInput | number
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EstudiantePrerequisitoUpdateWithoutEstudianteInput = {
    cumplido?: BoolFieldUpdateOperationsInput | boolean
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCumplimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prerequisito?: CatalogoPrerequisitoUpdateOneRequiredWithoutEstudiantePrerequisitosNestedInput
  }

  export type EstudiantePrerequisitoUncheckedUpdateWithoutEstudianteInput = {
    id?: IntFieldUpdateOperationsInput | number
    prerequisitoId?: IntFieldUpdateOperationsInput | number
    cumplido?: BoolFieldUpdateOperationsInput | boolean
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCumplimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EstudiantePrerequisitoUncheckedUpdateManyWithoutEstudianteInput = {
    id?: IntFieldUpdateOperationsInput | number
    prerequisitoId?: IntFieldUpdateOperationsInput | number
    cumplido?: BoolFieldUpdateOperationsInput | boolean
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCumplimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropuestaCreateManyAreaConocimientoInput = {
    id?: number
    titulo: string
    objetivos: string
    problematica?: string | null
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fkEstudiante: number
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
  }

  export type PropuestaUpdateWithoutAreaConocimientoInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
    estudiante?: UsuarioUpdateOneRequiredWithoutPropuestasNestedInput
    trabajosTitulacion?: TrabajoTitulacionUpdateManyWithoutPropuestaNestedInput
    actividades?: ActividadUpdateManyWithoutPropuestaNestedInput
    comites?: ComiteUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaUncheckedUpdateWithoutAreaConocimientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fkEstudiante?: IntFieldUpdateOperationsInput | number
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
    trabajosTitulacion?: TrabajoTitulacionUncheckedUpdateManyWithoutPropuestaNestedInput
    actividades?: ActividadUncheckedUpdateManyWithoutPropuestaNestedInput
    comites?: ComiteUncheckedUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUncheckedUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaUncheckedUpdateManyWithoutAreaConocimientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fkEstudiante?: IntFieldUpdateOperationsInput | number
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
  }

  export type TrabajoTitulacionCreateManyPropuestaInput = {
    fkTutorId: number
  }

  export type ActividadCreateManyPropuestaInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    tipo?: $Enums.TipoActividad
  }

  export type ComiteCreateManyPropuestaInput = {
    usuarioId: number
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
  }

  export type EntregableFinalCreateManyPropuestaInput = {
    id?: number
    tipo: $Enums.TipoEntregable
    urlArchivo: string
    fechaSubida?: Date | string
  }

  export type TrabajoTitulacionUpdateWithoutPropuestaInput = {
    fkTutorId?: IntFieldUpdateOperationsInput | number
  }

  export type TrabajoTitulacionUncheckedUpdateWithoutPropuestaInput = {
    fkTutorId?: IntFieldUpdateOperationsInput | number
  }

  export type TrabajoTitulacionUncheckedUpdateManyWithoutPropuestaInput = {
    fkTutorId?: IntFieldUpdateOperationsInput | number
  }

  export type ActividadUpdateWithoutPropuestaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoActividadFieldUpdateOperationsInput | $Enums.TipoActividad
    evidencias?: EvidenciaUpdateManyWithoutActividadNestedInput
  }

  export type ActividadUncheckedUpdateWithoutPropuestaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoActividadFieldUpdateOperationsInput | $Enums.TipoActividad
    evidencias?: EvidenciaUncheckedUpdateManyWithoutActividadNestedInput
  }

  export type ActividadUncheckedUpdateManyWithoutPropuestaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoActividadFieldUpdateOperationsInput | $Enums.TipoActividad
  }

  export type ComiteUpdateWithoutPropuestaInput = {
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario?: UsuarioUpdateOneRequiredWithoutComitesNestedInput
  }

  export type ComiteUncheckedUpdateWithoutPropuestaInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ComiteUncheckedUpdateManyWithoutPropuestaInput = {
    usuarioId?: IntFieldUpdateOperationsInput | number
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EntregableFinalUpdateWithoutPropuestaInput = {
    tipo?: EnumTipoEntregableFieldUpdateOperationsInput | $Enums.TipoEntregable
    urlArchivo?: StringFieldUpdateOperationsInput | string
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntregableFinalUncheckedUpdateWithoutPropuestaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoEntregableFieldUpdateOperationsInput | $Enums.TipoEntregable
    urlArchivo?: StringFieldUpdateOperationsInput | string
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntregableFinalUncheckedUpdateManyWithoutPropuestaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoEntregableFieldUpdateOperationsInput | $Enums.TipoEntregable
    urlArchivo?: StringFieldUpdateOperationsInput | string
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenciaCreateManyActividadInput = {
    id?: number
    semana: number
    contenido: string
    archivoUrl?: string | null
    fechaEntrega?: Date | string
    estado?: $Enums.EstadoEvidencia
    calificacion?: Decimal | DecimalJsLike | number | string | null
  }

  export type EvidenciaUpdateWithoutActividadInput = {
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    comentarios?: ComentarioUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaUncheckedUpdateWithoutActividadInput = {
    id?: IntFieldUpdateOperationsInput | number
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    comentarios?: ComentarioUncheckedUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaUncheckedUpdateManyWithoutActividadInput = {
    id?: IntFieldUpdateOperationsInput | number
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ComentarioCreateManyEvidenciaInput = {
    id?: number
    usuarioId: number
    descripcion?: string | null
  }

  export type ComentarioUpdateWithoutEvidenciaInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: UsuarioUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type ComentarioUncheckedUpdateWithoutEvidenciaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ComentarioUncheckedUpdateManyWithoutEvidenciaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EstudiantePrerequisitoCreateManyPrerequisitoInput = {
    id?: number
    cumplido?: boolean
    archivoUrl?: string | null
    fechaCumplimiento?: Date | string | null
    fkEstudiante: number
  }

  export type EstudiantePrerequisitoUpdateWithoutPrerequisitoInput = {
    cumplido?: BoolFieldUpdateOperationsInput | boolean
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCumplimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estudiante?: UsuarioUpdateOneRequiredWithoutPrerequisitosNestedInput
  }

  export type EstudiantePrerequisitoUncheckedUpdateWithoutPrerequisitoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cumplido?: BoolFieldUpdateOperationsInput | boolean
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCumplimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fkEstudiante?: IntFieldUpdateOperationsInput | number
  }

  export type EstudiantePrerequisitoUncheckedUpdateManyWithoutPrerequisitoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cumplido?: BoolFieldUpdateOperationsInput | boolean
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCumplimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fkEstudiante?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AreaConocimientoCountOutputTypeDefaultArgs instead
     */
    export type AreaConocimientoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AreaConocimientoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropuestaCountOutputTypeDefaultArgs instead
     */
    export type PropuestaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropuestaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActividadCountOutputTypeDefaultArgs instead
     */
    export type ActividadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActividadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvidenciaCountOutputTypeDefaultArgs instead
     */
    export type EvidenciaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvidenciaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogoPrerequisitoCountOutputTypeDefaultArgs instead
     */
    export type CatalogoPrerequisitoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogoPrerequisitoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuthDefaultArgs instead
     */
    export type AuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuthDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AreaConocimientoDefaultArgs instead
     */
    export type AreaConocimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AreaConocimientoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropuestaDefaultArgs instead
     */
    export type PropuestaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropuestaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrabajoTitulacionDefaultArgs instead
     */
    export type TrabajoTitulacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrabajoTitulacionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActividadDefaultArgs instead
     */
    export type ActividadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActividadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvidenciaDefaultArgs instead
     */
    export type EvidenciaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvidenciaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComentarioDefaultArgs instead
     */
    export type ComentarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComentarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogoPrerequisitoDefaultArgs instead
     */
    export type CatalogoPrerequisitoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogoPrerequisitoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EstudiantePrerequisitoDefaultArgs instead
     */
    export type EstudiantePrerequisitoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EstudiantePrerequisitoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificacionDefaultArgs instead
     */
    export type NotificacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificacionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntregableFinalDefaultArgs instead
     */
    export type EntregableFinalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntregableFinalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComiteDefaultArgs instead
     */
    export type ComiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComiteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EstudiantePerfilDefaultArgs instead
     */
    export type EstudiantePerfilArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EstudiantePerfilDefaultArgs<ExtArgs>
    /**
     * @deprecated Use McpAuthDefaultArgs instead
     */
    export type McpAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = McpAuthDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}